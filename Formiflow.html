<!DOCTYPE html>
<html>
<head>

<script type="text/javascript" src="JS/functions.js"></script>


    <style>
        /* Estilo para los botones */
        .button{

            border: none;
            background-color: #4c77af;
            color: white;
            text-align: center;
            font-size: 12px;
            cursor: pointer;
            padding: 4px 10px;
            margin: 2px;
            text-decoration: none;
            border-radius: 5px;
            height: 30px;
            margin-bottom: 0;
        }
        .button img{  
            height: 18px;
            vertical-align: middle;
            margin-bottom: 0;
        }
        .button-bar {
           /* Estilos para la barra de botones */
           display: flex;
           margin-bottom: 0; 
        }
        /* Estilo para el panel de dibujo de los diagramas de flujo */
        canvas {
            border: 1px solid #000;
        }

        .boton-redondo {
          width: 40px;
          height: 40px;
          border-radius: 50%;
          overflow: hidden;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          background-color: #6ebe92;
          color: white;
          text-align: center;
          text-decoration: none;
          font-weight: bold;
          font-family: Arial, sans-serif;
          cursor: pointer;
          transition: background-color 0.3s;
          position: relative;
          float: right; /* Mueve el bot√≥n a la derecha */
          border: none; /* Quita el borde */
          margin-left: 20px;
          margin-bottom: 0;
      }

      .boton-redondo img {
          width: 24px;
          height: 24px;
          object-fit: cover;
          margin-bottom: 0;
      }

      .boton-redondo:hover {
          background-color: #39803c;
          margin-bottom: 0;
      }

      .title-input {
    width: 700px; /* Establece el ancho deseado en p√≠xeles u otra unidad de medida */
    /* Otros estilos que desees aplicar al campo de entrada */
}

/* Establecer el color de fondo para las opciones con cargo asignado */
#rol option.has-cargo {
    background-color: #d2e6da; /* Cambia el color de fondo a tu elecci√≥n */
}

.fixed-top {
    position: fixed; /* Fija la posici√≥n de la barra */
    top: 0;          /* Alinea la barra en la parte superior de la ventana */
    width: 100%;     /* Opcional: Hace que la barra ocupe todo el ancho de la ventana */
    z-index: 1000;   /* Asegura que la barra se muestre sobre otros elementos */
}

  .label-error::after {
    content: " ‚ö†";
    color: red;
    font-weight: bold;
    margin-left: 4px;
}

.modal {
  position: fixed;
  z-index: 1000;
  left: 0; top: 0;
  width: 100%; height: 100%;
  background-color: rgba(0,0,0,0.5);
  display: flex; align-items: center; justify-content: center;
}

.modal-content {
  background-color: #fff;
  padding: 20px;
  border-radius: 8px;
  max-width: 80vw;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

.close {
  float: right;
  font-size: 1.5rem;
  cursor: pointer;
}





    </style>
</head>
<body>
    <!-- Imagen logo --> 
    <div>
      <img src="media/logo.png" />
    </div>
    <div id="dropdown-container"><!-- Aqu√≠ se insertar√° el men√∫ desplegable de elecci√≥n de modo --></div>
    <!-- Barra de botones --> 
    <div id="top-fixed-bar">
      <div class="button-bar"> 
        <button id="backButton" class="button" onclick="retroceder()"><img src="media/back.png"  title="Volver atr√°s"  /></button>
        <button id="forthButton" class="button" onclick="rehacer()"><img src="media/forth.png"  title="Volver adelante"  /></button>
        <button id="saveFlowChart" class="button" onclick="saveFlowChart()"><img src="media/saveFlowChart.png"  title="Guardar proceso"  /></button>
        <button id="loadFlowChart" class="button" onclick="loadFlowChart()"><img src="media/loadFlowChart.png"  title="Cargar/Editar proceso"  /></button>
        <button id="deleteStepOrPathButton" class="button" onclick="deleteStepOrPath()" button.width="20px"><img src="media/deleteStepOrPath.png"  title="Borrar paso o l√≠nea"  /></button>
        <button id="createStepButton" class="button" onclick="showStepDialog(true, 'step');"><img src="media/addStep.png"  title="Crear paso"  /></button>
        <button id="createMilestoneButton" class="button" onclick="showStepDialog(true, 'milestone');"><img src="media/addMilestone.png"  title="Crear hito"  /></button>
        <button id="createPathButton" class="button" onclick="createPath('path')"><img src="media/addPath.png"  title="Crear l√≠nea"  /></button>
        <button id="createLigtimeButton" class="button" onclick="createPath('ligtime')"><img src="media/addTime.png"  title="Establecer ligadura de tiempo (plazo m√°ximo o m√≠nimo entre tareas"  /></button>
        <button id="reorganizeFlowChartButton" class="button" onclick="reorganizarSteps()"><img src="media/reorganize.png"  title="Reorganizar autom√°ticamente diagrama de flujo"  /></button>
        <button id="saveCanvasImageButton" class="button" oncontextmenu="descargarFlowChart(); return false;"><img src="media/saveImage.png" title="Guardar imagen de diagrama de flujo" />
        <button id="projectDataButton" class="button" onclick="projectDataMenu()"><img src="media/projectData.png"  title="Datos b√°sicos del proyecto"  /></button>
        <button id="projectDataButton" class="button" onclick="mostrarOpcionesVisibilidad()"><img src="media/display.png"  title="Opciones de visibilidad de datos"  /></button>
        <button id="infoButton" class="button"><img src="media/info.png" title="Informaci√≥n sobre el software" /></button>
        <button id="doneButton" class="boton-redondo" onclick="tareaRealizada()"><img src="media/okStep.png"  title="Tarea realizada"  /></button>
        <!-- Modal oculto para informaci√≥n-->
        <div id="licenseModal" class="modal" style="display:none;">
            <div class="modal-content">
                <span id="closeModal" class="close">&times;</span>
                <div id="licenseText" style="max-height:70vh; overflow-y:auto;"></div>
            </div>
        </div>
    </div>
      <div id="messages-bar">
        <!-- barra de mensajes -->
        <p id="messages" style="font-family: Arial; font-size: 16px; color: rgb(50, 170, 158); font-weight: bold; background-color: white;"></p>
      </div>
    </div>
    <!-- T√≠tulo del gr√°fico -->
    <div id="flowChartName-bar">
        <input id="flowChartName" type="text"  class="title-input" style="border: 0; font-weight: bold;" maxlength="150">
    </div>
    <!-- Panel de dibujo de los diagramas de flujo --> 
    <canvas id="flowchartCanvas" width="600" height="800"></canvas>

    <script>

        var Ruta = getAbsolutePath();
        console.log("Ruta: "+Ruta);
        var nombreArchivo = "ProyectosDGED.txt";
        var textoArchivo = "archivo de datos de proyectos";
        // Flowchart data

        var flowchartDataGen;

        // Definici√≥n de variables globales de visibilidad de elementos
        var mostrar_fecha_inicio = true;
        var mostrar_fecha_fin = true;
        var mostrar_duracion = true;
        var mostrar_rol = true;
        // ESto es para en el futuro poder realizar acciones seg√∫n permisos:
        var permiso_administrador = true;
        var permiso_usuario = true;

        //Colores:
        const color_menu_titles = "#154360"; // Color t√≠tulos de men√∫ // Gris claro:"#ABABAB";
        const color_text_titles = "#5499c7"; // Color t√≠tulos de texto
        const color_OK_fondo = "#00c853"; // Color de fondo de tareas OK

        //Municipios:
        const listaLocalidades = [
        "Acebeda, La", "Ajalvir", "Alameda del Valle", "√Ålamo, El", "Alcal√° de Henares", "Alcobendas",
        "Alcorc√≥n", "Aldea del Fresno", "Algete", "Alpedrete", "Ambite", "Anchuelo", "Aranjuez",
        "Arganda del Rey", "Arroyomolinos", "Batres", "Becerril de la Sierra", "Belmonte de Tajo",
        "Berzosa del Lozoya", "Berrueco, El", "Boalo, El", "Braojos", "Brea de Tajo", "Brunete",
        "Buitrago del Lozoya", "Bustarviejo", "Cabanillas de la Sierra", "Cabrera, La", "Cadalso de los Vidrios",
        "Camarma de Esteruelas", "Campo Real", "Canencia", "Caraba√±a", "Casarrubuelos", "Cenicientos",
        "Cercedilla", "Cervera de Buitrago", "Chapiner√≠a", "Chinch√≥n", "Ciempozuelos", "Cobe√±a",
        "Collado Mediano", "Collado Villalba", "Colmenar de Oreja", "Colmenar del Arroyo", "Colmenar Viejo",
        "Colmenarejo", "Corpa", "Coslada", "Cubas de la Sagra", "Daganzo de Arriba", "Escorial, El",
        "Estremera", "Fresnedillas de la Oliva", "Fresno de Torote", "Fuenlabrada", "Fuente el Saz de Jarama",
        "Fuentidue√±a de Tajo", "Galapagar", "Garganta de los Montes", "Gargantilla del Lozoya y Pinilla de Buitrago",
        "Gascones", "Getafe", "Gri√±√≥n", "Guadalix de la Sierra", "Guadarrama", "Hiruela, La", "Horcajo de la Sierra-Aoslos",
        "Horcajuelo de la Sierra", "Hoyo de Manzanares", "Humanes de Madrid", "Legan√©s", "Loeches", "Lozoya",
        "Lozoyuela-Navas-Sieteiglesias", "Madarcos", "Madrid", "Majadahonda", "Manzanares el Real", "Meco",
        "Mejorada del Campo", "Miraflores de la Sierra", "Molinos, Los", "Molar, El", "Molinos, Los", "Moralzarzal",
        "Moraleja de Enmedio", "Morata de Taju√±a", "M√≥stoles", "Navacerrada", "Navalafuente", "Navalagamella",
        "Navalcarnero", "Navarredonda y San Mam√©s", "Navas del Rey", "Nuevo Bazt√°n", "Olmeda de las Fuentes",
        "Orusco de Taju√±a", "Paracuellos de Jarama", "Parla", "Patones", "Pedrezuela", "Pelayos de la Presa",
        "Perales de Taju√±a", "Pezuela de las Torres", "Pinilla del Valle", "Pi√±u√©car-Gandullas", "Pinto",
        "Pozuelo de Alarc√≥n", "Pozuelo del Rey", "Pr√°dena del Rinc√≥n", "Puebla de la Sierra", "Puentes Viejas",
        "Quijorna", "Rascafr√≠a", "Redue√±a", "Ribatejada", "Rivas-Vaciamadrid", "Robledillo de la Jara",
        "Robledo de Chavela", "Robregordo", "Rozas de Madrid, Las", "Rozas de Puerto Real", "San Agust√≠n del Guadalix",
        "San Fernando de Henares", "San Lorenzo de El Escorial", "San Mart√≠n de la Vega", "San Mart√≠n de Valdeiglesias",
        "San Sebasti√°n de los Reyes", "Santa Mar√≠a de la Alameda", "Santorcaz", "Santos de la Humosa, Los",
        "Serna del Monte, La", "Serranillos del Valle", "Sevilla la Nueva", "Somosierra", "Soto del Real",
        "Talamanca de Jarama", "Tielmes", "Titulcia", "Torrej√≥n de Ardoz", "Torrej√≥n de la Calzada",
        "Torrej√≥n de Velasco", "Torrelaguna", "Torrelodones", "Torremocha de Jarama", "Torres de la Alameda",
        "Tres Cantos", "Valdaracete", "Valdeavero", "Valdelaguna", "Valdemanco", "Valdemaqueda", "Valdemorillo",
        "Valdemoro", "Valdeolmos-Alalpardo", "Valdepi√©lagos", "Valdetorres de Jarama", "Valdilecha", "Valverde de Alcal√°",
        "Velilla de San Antonio", "Vell√≥n, El", "Venturada", "Villa del Prado", "Villaconejos", "Villalbilla",
        "Villamanrique de Tajo", "Villamanta", "Villamantilla", "Villanueva de la Ca√±ada", "Villanueva de Perales",
        "Villanueva del Pardillo", "Villar del Olmo", "Villarejo de Salvan√©s", "Villaviciosa de Od√≥n",
        "Villavieja del Lozoya", "Zarzalejo"
    ];

    const tempElementTextos = {};

    //************ Licencia *********************************************************************************************

document.getElementById("infoButton").addEventListener("click", function () {
  const licenseText = `
  <h2>Formiflow 0.1</h2>
  <h3>Autor: Jos√© Antonio Rivero Garc√≠a-Saavedra</h3>
  <p>Esta licencia aplica al software Formiflow 0.1 :
  <h2>Licencia P√∫blica Administrativa (LPA)</h2>
  <h3>Versi√≥n de la licencia 1.0</h3>

  <h4>1. Objeto y √°mbito de aplicaci√≥n</h4>
  <p>El presente software es licenciado bajo los t√©rminos de la Licencia P√∫blica Administrativa (LPA), cuyo prop√≥sito es facilitar su uso, instalaci√≥n, modificaci√≥n y redistribuci√≥n exclusivamente en el √°mbito de las Administraciones P√∫blicas, manteni√©ndose reservados todos los derechos en los dem√°s supuestos.</p>
  <h4>2. Licencia para Administraciones P√∫blicas</h4>
  <p>Se concede a las Administraciones P√∫blicas una licencia gratuita, no exclusiva, mundial y perpetua para:</p>
<ul>
  <li>Usar el software con cualquier fin institucional o administrativo.</li>
  <li>Modificar el software, con obligaci√≥n de reconocer al autor original y al software base.</li>
  <li>Redistribuir versiones originales o modificadas, exclusivamente dentro del √°mbito de otras Administraciones P√∫blicas, con los mismos t√©rminos de esta licencia.</li>
</ul>
<p>A efectos de esta licencia, se entiende por "Administraci√≥n P√∫blica" toda entidad perteneciente al sector p√∫blico estatal, auton√≥mico, local o institucional (organismos aut√≥nomos, entes p√∫blicos, etc.).</p>
  <h4>3. Acceso al c√≥digo por terceros</h4>
  <p>Se permite el acceso p√∫blico al c√≥digo fuente del software. Sin embargo:</p>
<ul>
  <li>No se concede ning√∫n derecho de uso, modificaci√≥n o redistribuci√≥n a entidades o personas distintas de las Administraciones P√∫blicas, salvo lo dispuesto en los apartados siguientes.</li>
<li>Los terceros podr√°n instalar el software en nombre de una Administraci√≥n P√∫blica, o modificarlo para su uso exclusivo en dicha Administraci√≥n, pero no adquieren por ello ning√∫n derecho de uso, propiedad o explotaci√≥n sobre el software ni sobre sus versiones modificadas.</li>
<li>Toda modificaci√≥n deber√° mantener el reconocimiento al autor original y no podr√° presentarse como una obra completamente nueva o desvinculada.</li>
</ul>
<h4>4. Reconocimiento del autor</h4>
  <p>Cualquier copia, modificaci√≥n o redistribuci√≥n del software dentro del √°mbito permitido por esta licencia deber√°:</p>
<ul>
  <li>Mantener los avisos de autor√≠a originales.</li>
<li>Incluir una menci√≥n clara al software base en cualquier documentaci√≥n o presentaci√≥n derivada.</li>
</ul>
  <h4>5. Revocaci√≥n de la licencia</h4>
  <p>Esta licencia podr√° considerarse autom√°ticamente revocada en caso de:</p>
<ul>
  <li>Uso malicioso del software para causar da√±o a terceros.</li>
<li>Incumplimiento de los t√©rminos establecidos en esta licencia.</li>
<li>Suplantaci√≥n de autor√≠a o eliminaci√≥n del reconocimiento al autor original.</li>
</ul>
<p>La revocaci√≥n no impide que se exijan responsabilidades legales adicionales.</p>
  <h4>6. Ausencia de garant√≠a</h4>
  <p>Este software se proporciona "tal cual", sin garant√≠as de ning√∫n tipo, expresas o impl√≠citas. El autor no ser√° responsable de da√±os directos o indirectos derivados del uso del software.</p>

  <h4>7. Ley aplicable y jurisdicci√≥n</h4>
  <p>Esta licencia se regir√° por la legislaci√≥n espa√±ola. Cualquier disputa se someter√° a los tribunales de Madrid (Espa√±a).</p>
  `;

  document.getElementById("licenseText").innerHTML = licenseText;
  document.getElementById("licenseModal").style.display = "flex";
});

document.getElementById("closeModal").addEventListener("click", function () {
  document.getElementById("licenseModal").style.display = "none";
});


//**********************************************************************************************************************************//
// A COMPLETAR CUANDO SE TENGA BACKEND //
function subirArchivoAlBackend(file, proyectoId, tareaId, nombreTarea, nombreElemento) {
    // A completar cuando se tenga backend
    console.log("üì§ Subiendo archivo:", file.name);
    console.log("üîó Proyecto:", proyectoId);
    console.log("üîó ID tarea:", tareaId);
    console.log("üîó Nombre tarea:", nombreTarea);
    console.log("üîó Nombre elemento:", nombreElemento);

    // Aqu√≠ ir√≠a la llamada fetch, XMLHttpRequest, etc.

    // Simular √©xito
    return true;
}

//**********************************************************************************************************************************//



// Funci√≥n para mostrar el cuadro de di√°logo con checkboxes
function mostrarOpcionesVisibilidad() {

  // Verifica si el di√°logo ya existe y lo elimina si es as√≠
  var dialogoExistente = document.getElementById('dialogoConfiguracion');
  if (dialogoExistente) {
    document.body.removeChild(dialogoExistente);
  }

  // Crear el di√°logo y sus elementos internos, estableciendo el atributo checked din√°micamente
  var dialogo = document.createElement("div");
  dialogo.id = 'dialogoConfiguracion';
  dialogo.innerHTML = `
    <h3>Selecciona las opciones que deseas mostrar</h3>
    <input type="checkbox" id="fecha_inicio" name="fecha_inicio" ${mostrar_fecha_inicio ? 'checked' : ''}>
    <label for="fecha_inicio">Mostrar fecha de inicio</label><br>
    <input type="checkbox" id="fecha_fin" name="fecha_fin" ${mostrar_fecha_fin ? 'checked' : ''}>
    <label for="fecha_fin">Mostrar fecha de fin</label><br>
    <input type="checkbox" id="duracion" name="duracion" ${mostrar_duracion ? 'checked' : ''}>
    <label for="duracion">Mostrar duraci√≥n</label><br>
    <input type="checkbox" id="responsable" name="responsable" ${mostrar_rol ? 'checked' : ''}>
    <label for="responsable">Mostrar responsable</label><br>
    <div style="text-align: right;">
      <button onclick="actualizarConfiguracion()">Aceptar</button>
    </div>
  `;

  // Estilo b√°sico para el di√°logo
  dialogo.style.position = 'fixed';
  dialogo.style.left = '50%';
  dialogo.style.top = '50%';
  dialogo.style.transform = 'translate(-50%, -50%)';
  dialogo.style.backgroundColor = '#fff';
  dialogo.style.padding = '20px';
  dialogo.style.boxShadow = '0 0 10px rgba(0,0,0,0.5)';
  dialogo.style.fontFamily = 'Arial, sans-serif';
  dialogo.style.zIndex = '1000';
  document.body.appendChild(dialogo);
}

// Funci√≥n para actualizar las variables globales basada en la selecci√≥n del usuario y cerrar el di√°logo
function actualizarConfiguracion() {
  mostrar_fecha_inicio = document.getElementById("fecha_inicio").checked;
  mostrar_fecha_fin = document.getElementById("fecha_fin").checked;
  mostrar_duracion = document.getElementById("duracion").checked;
  mostrar_rol = document.getElementById("responsable").checked;

  // Cerrar el di√°logo
  var dialogo = document.getElementById('dialogoConfiguracion');
  if (dialogo) {
    document.body.removeChild(dialogo);
  }
  drawFlowchart();
}


        function getAbsolutePath() {
  
  var loc = window.location;
  console.log("window.location: "+loc);
  var pathName = loc.pathname.substring(0, loc.pathname.lastIndexOf('/'));
  console.log("pathName dentro: "+pathName);
  var pathfinal= loc.href.substring(0, loc.href.length - ((loc.pathname + loc.search + loc.hash).length - pathName.length));
  console.log(pathfinal);
  return pathfinal;

}

        let historial = [];
        let historialRehacer = [];
        function retroceder() {
          if (historial.length > 1) {
           // Mueve el √∫ltimo estado al historial de rehacer
            historialRehacer.push(historial.pop());

            // Restaura el pen√∫ltimo estado
            flowchartData = JSON.parse(JSON.stringify(historial[historial.length - 1]));
            drawFlowchart();
          }
        }

        function rehacer() {
          if (historialRehacer.length > 0) {
            // Mueve el √∫ltimo estado del historial de rehacer al historial principal
            let estado = historialRehacer.pop();
            historial.push(estado);

            // Aplica el estado re-hecho
            flowchartData = JSON.parse(JSON.stringify(estado));
            drawFlowchart();
          }
        }

        function guardarEstado() {
          console.log("longitud antes: "+historial.length);
          // Comprueba si la pila ya tiene elementos
          if (historial.length > 0) {
            // Compara el estado actual con el √∫ltimo estado guardado
            // Utiliza JSON.stringify para comparar los objetos como cadenas
            console.log(JSON.stringify(flowchartData));
            console.log(JSON.stringify(historial[historial.length - 1]));
            if (JSON.stringify(flowchartData) === JSON.stringify(historial[historial.length - 1])) {
              console.log("Es igual!!");
            return; 
            }
          }
          // Guarda el estado si la pila est√° vac√≠a o si el estado ha cambiado
          if (historial.length >= 20) {
            historial.shift(); // Elimina el estado m√°s antiguo si se excede el l√≠mite
          }
          console.log("PUSH: "+JSON.stringify(flowchartData));
          historial.push(JSON.parse(JSON.stringify(flowchartData))); // Guarda una copia profunda
          console.log("longitud despues: "+historial.length);
        }






        window.addEventListener('scroll', function() { // Si la barra de botones llega a la parte superior de la pantalla, la bloqueamos.
          var topBar = document.getElementById('top-fixed-bar');
          var offset = topBar.offsetTop;

          if (window.pageYOffset > offset) {
            topBar.classList.add('fixed-top');
          } else {
            topBar.classList.remove('fixed-top');
          }
        });
        var flowchartData={
			    title: "Nombre del proceso"
        };
        var selectedStep = []; // Ahora es un array para selecci√≥n m√∫ltiple
        var isSelecting = false;
        var selectionStart = { x: 0, y: 0 };
        var selectionEnd = { x: 0, y: 0 };
        var selectedPath = null;
        var stepSelected=false;
        var pathSelected=false;
        var numClicksAfterCreatePathButton=0;
        var NewStepIni=null;
        var NewStepEnd=null;
        var createPathOn=false;
        var createligtimeOn=false;
        let expiredTime = true;
        let stepCanMove = true;
        var modoProcesosGenerales = false;

        var dragStart = null; // Guarda el punto inicial del movimiento
        var initialPositions = []; // Guarda las posiciones iniciales de las tareas seleccionadas



// Funci√≥n para crear el desplegable de elecci√≥n de Modo:
function crearDesplegable() {
  // Crear la etiqueta del desplegable
  var label = document.createElement('label');
  label.textContent = 'Modo: ';
  label.htmlFor = 'modo-select';
  label.style.fontSize = '12px';
  label.style.fontFamily = 'Arial, sans-serif';

  // Crear el desplegable
  var select = document.createElement('select');
  select.id = 'modo-select';
  select.style.fontSize = '12px';

  // Opci√≥n "Seguimiento de proyectos"
  var opcion1 = document.createElement('option');
  opcion1.value = 'seguimiento_proyectos';
  opcion1.textContent = 'Seguimiento de proyectos';
  opcion1.selected = true; // Esta opci√≥n estar√° seleccionada por defecto

  // Opci√≥n "Gesti√≥n de procesos generales"
  var opcion2 = document.createElement('option');
  opcion2.value = 'gestion_procesos_generales';
  opcion2.textContent = 'Gesti√≥n de procesos generales';

  // Agregar las opciones al desplegable
  select.appendChild(opcion1);
  select.appendChild(opcion2);

 // Asignar el evento de cambio al select 
 select.addEventListener('change', function() {
    // Actualizar la variable global seg√∫n la selecci√≥n
    modoProcesosGenerales = this.value === 'gestion_procesos_generales';
    // Mostrar u ocultar bot√≥n de datos del proyecto:
    var boton = document.getElementById('projectDataButton');
    if (modoProcesosGenerales) {
      boton.style.display = 'none'; // Oculta el bot√≥n
      textoArchivo = "archivo de procesos generales";
      nombreArchivo = "ProcesosGlobales.txt";
    } else {
      boton.style.display = 'block'; // Muestra el bot√≥n
      textoArchivo = "archivo de datos de proyectos";
      nombreArchivo = "ProyectosDGED.txt";
    }
    // Cambiar el color de fondo si es necesario
    this.style.backgroundColor = modoProcesosGenerales ? 'yellow' : '';
    drawFlowchart();
  });


  // Obtener el contenedor y agregar la etiqueta y el desplegable
  var container = document.getElementById('dropdown-container');
  container.appendChild(label);
  container.appendChild(select);
}

// Ejecutar la funci√≥n para crear el desplegable
crearDesplegable();


        function descargarFlowChart(){ //Funci√≥n temporal que deber√° ser eliminada
  // Supongamos que flowchartData es la variable que contiene los datos del gr√°fico de flujo

    // Convertir el objeto flowchartData a una cadena JSON
    var dataString = JSON.stringify(historial, null, 2);

    // Crear un objeto Blob con los datos en formato JSON
    var blob = new Blob([dataString], { type: 'text/plain' });

    // Crear un elemento <a> para el enlace de descarga
    var a = document.createElement('a');
    a.href = window.URL.createObjectURL(blob);
    
    // Asignar un nombre de archivo para el archivo de texto
    a.download = 'flowchartData.txt';

    // Agregar el elemento <a> al DOM
    document.body.appendChild(a);

    // Simular un clic en el enlace para iniciar la descarga
    a.click();

    // Eliminar el elemento <a> del DOM despu√©s de la descarga
    window.URL.revokeObjectURL(a.href);
    document.body.removeChild(a);
        }



function interpretarApartado(linea) {
    return (linea === "") ? "(Sin t√≠tulo)" : linea;
}

function projectDataMenu() {
    var dialog = document.createElement("dialog");

    // Obtener roles √∫nicos de flowchartData.steps
    var rolesUnicos = [...new Set(flowchartData.steps.map(step => step.rol))];

    var selectOptions = '';
    // Crear opciones para el desplegable de rol
    rolesUnicos.forEach(rol => {
        selectOptions += `<option value="${rol}">${rol}</option>`;
    });

    // Crear una lista de cargos y nombres
    var cargoNombreList = [
        { cargo: "DGED", nombre: "Ignacio Azor√≠n" },
        { cargo: "SGTD", nombre: "Patricia L√°zaro" },
        { cargo: "JATD", nombre: "Jos√© Antonio Rivero" },
        { cargo: "JSTD", nombre: "Jes√∫s Iglesias" },
        { cargo: "TSTD", nombre: "Carmen Arenas" },
        // Agrega m√°s cargos y nombres seg√∫n sea necesario
    ];

       // Crear opciones para el desplegable de rol con una opci√≥n en blanco
       var selectOptions = '<option value="">Seleccione un rol</option>';
    rolesUnicos.forEach(rol => {
        selectOptions += `<option value="${rol}">${rol}</option>`;
    });

    // Crear opciones para el desplegable de cargos y nombres con una opci√≥n en blanco
    var cargoNombreOptions = '<option value="">Seleccione un cargo</option>';
    cargoNombreList.forEach(item => {
        cargoNombreOptions += `<option value="${item.cargo}">${item.cargo} - ${item.nombre}</option>`;
    });

    // Variable para almacenar las asignaciones de roles y cargos temporalmente
    var asignacionesTemporales = [];

    dialog.innerHTML = `
    <form method="dialog" style="width: 300px;">
        <label for="descripcionProyecto"><strong>Descripci√≥n del proyecto:</strong></label>
        <textarea id="descripcionProyecto" rows="4" style="width: 100%;">${flowchartData.descripcionProyecto || ''}</textarea>
        <br><br>
        <label for="fechaInicio"><strong>Fecha de inicio del proyecto:</strong></label>
        <input type="date" id="fechaInicio" value="${flowchartData.fechaInicioProyecto || ''}">
        <br><br>
        <label for="importeEstimado"><strong>Importe del proyecto:</strong></label>
        <input type="text" id="importeEstimado" value="${flowchartData.importeEstimado || ''}" style="text-align: right;" pattern="[0-9]{1,3}(\.[0-9]{3})*(,[0-9]+)?" title="Por favor, ingrese un n√∫mero v√°lido. Use coma como separador decimal. El separador de miles puede ser un punto o no existir.">‚Ç¨
        <span id="error-message" style="color: red;"></span>
        <br><br>
        <label for="asignaRoles"><strong>Asignaci√≥n de personas (cargos) a roles:</strong></label>
        <br>
        <select id="rol">${selectOptions}</select>
        <br>
        <select id="cargoNombre">${cargoNombreOptions}<option value="Otro">Otro</option></select>
        <input type="text" id="cargoInput" style="display: none;" placeholder="Ingrese otro cargo">
        <menu style="margin-top: 10px;">
            <button type="button" style="float: right;" onclick="closeDialog();">Cancelar</button>
            <button type="submit" value="default" style="float: right;">Aceptar</button>
        </menu>
    </form>
`;

dialog.innerHTML = `
    <form method="dialog" style="width: 300px;">
      <label for="descripcionProyecto"><strong>Descripci√≥n del proyecto:</strong></label>
        <textarea id="descripcionProyecto" rows="4" style="width: 100%;">${flowchartData.descripcionProyecto || ''}</textarea>
        <br><br>
        <label for="fechaInicio"><strong>Fecha de inicio del proyecto:</strong></label>
        <input type="date" id="fechaInicio" value="${flowchartData.fechaInicioProyecto || ''}">
        <br><br>
        <label for="importeEstimado"><strong>Importe del proyecto:</strong></label>
        <input type="text" id="importeEstimado" value="${flowchartData.importeEstimado || ''}" style="text-align: right;" pattern="[0-9]{1,3}(\.[0-9]{3})*(,[0-9]+)?" title="Por favor, ingrese un n√∫mero v√°lido. Use coma como separador decimal. El separador de miles puede ser un punto o no existir.">‚Ç¨
        <span id="error-message" style="color: red;"></span>
        <br><br>
        <label for="asignaRoles"><strong>Asignaci√≥n de personas (cargos) a roles:</strong></label>
        <br>
        <select id="rol">${selectOptions}</select>
        <br>
        <select id="cargoNombre">${cargoNombreOptions}<option value="Otro">Otro</option></select>
        <input type="text" id="cargoInput" style="display: none;" placeholder="Ingrese otro cargo">

        <br><br>
        <label for="estadoProyecto"><strong>Proyecto finalizado: </strong></label>
        <label class="switch">
            <input type="checkbox" id="estadoProyecto">
            <span class="slider round"></span>
        </label>
        <br><br>

        <menu style="margin-top: 10px;">
            <button type="button" style="float: right;" onclick="closeDialog();">Cancelar</button>
            <button type="submit" value="default" style="float: right;" onclick="guardarEstado();">Aceptar</button>
        </menu>
    </form>
    <style>
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        .switch input { 
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
        }
        input:checked + .slider {
            background-color: #2196F3;
        }
        input:focus + .slider {
            box-shadow: 0 0 1px #2196F3;
        }
        input:checked + .slider:before {
            -webkit-transform: translateX(26px);
            -ms-transform: translateX(26px);
            transform: translateX(26px);
        }
        /* Estilo redondeado */
        .slider.round {
            border-radius: 34px;
        }
        .slider.round:before {
            border-radius: 50%;
        }
    </style>
`;

    // Mostrar el cuadro de di√°logo modal
    document.body.appendChild(dialog);
    establecerEstadoProyecto();
    dialog.showModal();

    function establecerEstadoProyecto() {
    let estadoProyecto = document.getElementById('estadoProyecto');
    estadoProyecto.checked = flowchartData.estadoProyecto === "cerrado";
    dialog.style.backgroundColor = estadoProyecto.checked ? "lightgrey" : "white";
}

    // Opcional: Agregar controlador de eventos para el interruptor
    document.getElementById('estadoProyecto').addEventListener('change', function() {
    if(this.checked) {
        dialog.style.backgroundColor = "lightgrey";
    } else {
        dialog.style.backgroundColor = "white";
    }
});

 
    var importeInput = document.getElementById("importeEstimado");
    var errorMessage = document.getElementById("error-message");
    var cargoNombreSelect = document.getElementById("cargoNombre");
    var cargoInput = document.getElementById("cargoInput");
    var rolSelect = document.getElementById("rol");

    // Crear una copia de los valores de flowchartData.asignacionRoles en asignacionesTemporales
    if (flowchartData.asignacionRoles) {
        asignacionesTemporales = Object.entries(flowchartData.asignacionRoles).map(([rol, cargo]) => ({ rol, cargo }));
    }

    // Funci√≥n para preseleccionar el cargo en el desplegable de cargos
// Funci√≥n para preseleccionar el cargo en el desplegable de cargos
function preselectCargo() {
    var selectedRol = rolSelect.value;
    var asignacionExistente = asignacionesTemporales.find(asignacion => asignacion.rol === selectedRol);
    
    // Obtener el elemento cargoNombreSelect
    var cargoNombreSelect = document.getElementById("cargoNombre");

    actualizaColorDesplegableRol();

    if (asignacionExistente) {
        var cargoOption = cargoNombreSelect.querySelector(`option[value="${asignacionExistente.cargo}"]`);
        if (cargoOption) {
            cargoOption.selected = true;
            cargoInput.style.display = "none";
        }else{ //Se ha asignado a "Otro".
        cargoNombreSelect.value = "Otro";
          cargoInput.style.display = "block";
          cargoInput.value = asignacionExistente.cargo;
        }
    } else {
        // Si no existe una asignaci√≥n para el rol, seleccionar "Seleccione un cargo"
        cargoNombreSelect.value = "";
        cargoInput.style.display = "none";
    }
}

function actualizaColorDesplegableRol(){
          // Obtener todas las opciones del desplegable de roles
          var rolOptions = document.querySelectorAll("#rol option");
        rolOptions.forEach(option => {
        var rolValue = option.value;
        var hasCargo = asignacionesTemporales.some(asignacion => asignacion.rol === rolValue && asignacion.cargo !== "");
        if (hasCargo) {
            option.classList.add("has-cargo"); // Agregar clase "has-cargo" a las opciones con cargo asignado
        } else {
            option.classList.remove("has-cargo"); // Eliminar clase "has-cargo" de las opciones sin cargo asignado
        }
    });

}


        // Llamar a la funci√≥n para preseleccionar el cargo al iniciar el cuadro de di√°logo
        preselectCargo();

            // Evento de cambio de rol para preseleccionar el cargo
    rolSelect.addEventListener("change", preselectCargo);


    // Funci√≥n para cerrar el cuadro de di√°logo
    window.closeDialog = function() {
        dialog.close();
        // Eliminar el cuadro de di√°logo del DOM despu√©s de cerrarlo
        dialog.remove();
    };

    // Funci√≥n para mostrar u ocultar el campo de entrada de cargo seg√∫n la selecci√≥n
    function updateCargoInputVisibility() {
        if (cargoNombreSelect.value === "Otro") {
            cargoInput.style.display = "block";
        } else {
            cargoInput.style.display = "none";
        }
    }

    // Funci√≥n para almacenar el valor seleccionado al cambiar el selector de rol o cargo
    function updateAsignacionesTemporales() {
        var seleccionRol = rolSelect.value;
        var seleccionCargoNombre = cargoNombreSelect.value === "Otro" ? cargoInput.value : cargoNombreSelect.value;

        // Buscar si ya existe una asignaci√≥n para este rol
        var asignacionExistente = asignacionesTemporales.find(asignacion => asignacion.rol === seleccionRol);

        if (asignacionExistente) {
            // Si ya existe una asignaci√≥n, actualizar el valor del cargo
            asignacionExistente.cargo = seleccionCargoNombre;
        } else {
            // Si no existe una asignaci√≥n, agregar una nueva asignaci√≥n
            asignacionesTemporales.push({ rol: seleccionRol, cargo: seleccionCargoNombre });
        }
        
    }

    cargoNombreSelect.addEventListener("change", function() {
        updateCargoInputVisibility();
        updateAsignacionesTemporales();
        actualizaColorDesplegableRol();
    });

    rolSelect.addEventListener("change", function() {
        updateAsignacionesTemporales();
    });

    cargoInput.addEventListener("change", function() {
        updateAsignacionesTemporales();
        actualizaColorDesplegableRol();
    });


    // Validar el input del importe antes de enviar el formulario
    dialog.querySelector("form").onsubmit = function(event) {


      var descripcionProyecto = document.getElementById("descripcionProyecto").value;
        if ((descripcionProyecto === null) || (descripcionProyecto === undefined) || (descripcionProyecto === "")) {
        } else {
            flowchartData.descripcionProyecto = descripcionProyecto;
        }

        var importeValue = importeInput.value.replace(/\./g, ""); // Eliminar puntos como separadores de miles
        if (isNaN(importeValue.replace(",", ".")) || importeValue === "") {
            errorMessage.textContent = "Por favor, ingrese un n√∫mero v√°lido.";
            event.preventDefault(); // Evitar que el formulario se env√≠e si el importe no es v√°lido
        } else {
            errorMessage.textContent = ""; // Limpiar el mensaje de error si el importe es v√°lido
            // Guardar el importe en flowchartData
            flowchartData.importeEstimado = importeValue.replace(",", ".");
        }
        var fechaInicioInput = document.getElementById("fechaInicio").value;
        if ((fechaInicioInput === null) || (fechaInicioInput === undefined) || (fechaInicioInput === "")) {
        } else {
            flowchartData.fechaInicioProyecto = fechaInicioInput;
        }

        
        // Al hacer clic en "Aceptar", almacenar los datos en flowchartData.asignacionRoles
        if (asignacionesTemporales.length > 0) {
            if (!flowchartData.asignacionRoles) {
                flowchartData.asignacionRoles = {};
            }

            asignacionesTemporales.forEach(asignacion => {
                flowchartData.asignacionRoles[asignacion.rol] = asignacion.cargo;
            });


    // Eliminar las asignaciones con cargos en blanco de flowchartData.asignacionRoles
    if (flowchartData.asignacionRoles) {
        Object.entries(flowchartData.asignacionRoles).forEach(([rol, cargo]) => {
            if (asignacionesTemporales.some(asignacion => asignacion.rol === rol && asignacion.cargo === "")) {
                delete flowchartData.asignacionRoles[rol];
            }
        });
    }

            

        }

        let estadoProyecto = document.getElementById('estadoProyecto').checked;
        flowchartData.estadoProyecto = estadoProyecto ? "cerrado" : "activo";
        console.log (estadoProyecto);
        console.log (flowchartData.estadoProyecto);
        guardarEstado();
        drawFlowchart();
    };

    // Manejar el evento de cierre del cuadro de di√°logo
    dialog.addEventListener('close', function() {
        // Eliminar el cuadro de di√°logo del DOM despu√©s de cerrarlo


        dialog.remove();
    });
}



function esFechaValida(fecha) {
  // Define una expresi√≥n regular para el formato "yyyy-mm-dd"
  var patron = /^\d{4}-\d{2}-\d{2}$/;

  // Usa el m√©todo test() de la expresi√≥n regular para verificar si la fecha coincide con el patr√≥n
  if (patron.test(fecha)) {
    // La fecha tiene el formato correcto
    return true;
  } else {
    // La fecha no tiene el formato correcto
    return false;
  }
}

        function deleteStepOrPath() {
            finishPathProcess();
            //var selectedStep = 'step3'; // ID del elemento que deseas eliminar
            // Buscar y eliminar el elemento de la dimensi√≥n 'steps'
            if(pathSelected===true){
                          //var selectedStep = 'step3'; // ID del elemento que deseas eliminar
            // Buscar y eliminar el elemento de la dimensi√≥n 'steps'
            
            if (flowchartData.hasOwnProperty('paths')) {
              var paths = flowchartData.paths;
            for (var i = 0; i < paths.length; i++) {
             if (paths[i].id === selectedPath) {
                 paths.splice(i, 1);
             }
            }
          }
            }

            if(stepSelected===true){

              // Buscar y eliminar las referencias al elemento en la dimensi√≥n 'paths' (rutas vinculadas a las tareas seleccionadas)
              if (flowchartData.hasOwnProperty('paths')) {
                var paths = flowchartData.paths;
                for (var i = paths.length - 1; i >= 0; i--) {
                  if (selectedStep.includes(paths[i].startStep) || selectedStep.includes(paths[i].endStep)) {
                      paths.splice(i, 1);
                      }
                }
              }  
              //Eliminar las tareas
              if (flowchartData.hasOwnProperty('steps')) {
                var steps = flowchartData.steps;
                for (var i = steps.length - 1; i >= 0; i--) {
                  if (selectedStep.includes(steps[i].id)) {
                      var element=steps[i].id;
                      steps.splice(i, 1);
                      selectedStep = selectedStep.filter(step => step !== element);
                  }
                }

          }
        
        }

        selectedStep =[];
        stepSelected=false;
        selectedPath=null;







            guardarEstado();
            drawFlowchart();
            // Mostrar el array actualizado
        }
function normalizarStructureTextareaValue(textareaValue) {
    if (typeof textareaValue !== "string") return "";

    return textareaValue
        .split("\n")
        .map(linea => linea.trim() === "" ? "(Sin t√≠tulo)" : linea.trim())
        .join("\n");
}




function showStepDialog(isNew, tipo, stepId="", name = "", rol = "", duracion = "", instructions = "", unidadduracion = "", fechafin="",  notes="", multiple="", previous_multiple="") {

            if (!flowchartData.hasOwnProperty('steps')) {
          flowchartData.steps = [];
      }
    // Crear un div para el cuadro de di√°logo
    // Crear un div para el cuadro de di√°logo
    var dialogDiv = document.createElement("div");
    dialogDiv.style.display = "flex";
    dialogDiv.style.flexDirection = "column";
    dialogDiv.style.position = "fixed";
    dialogDiv.style.left = "50%";
    dialogDiv.style.top = "50%";
    dialogDiv.style.transform = "translate(-50%, -50%)";
    dialogDiv.style.backgroundColor = "white";
    dialogDiv.style.padding = "20px";
    dialogDiv.style.border = "1px solid #ccc";
    dialogDiv.style.borderRadius = "5px";
    dialogDiv.style.maxHeight = "90vh";
    dialogDiv.style.width = "800px";
    dialogDiv.style.overflow = "hidden";
    dialogDiv.style.boxShadow = "0 4px 10px rgba(0,0,0,0.2)";
    document.body.appendChild(dialogDiv);

    const tempElementDetalles = {};

    




    // Contenedor desplazable
    const contentContainer = document.createElement("div");
    contentContainer.style.overflowY = "auto";
    contentContainer.style.flex = "1";
    contentContainer.style.paddingRight = "10px";
    dialogDiv.appendChild(contentContainer);


      // Mostrar "Nombre de la tarea:" en una l√≠nea nueva
      var nameLabel = document.createElement("label");
      nameLabel.style.fontFamily = "Arial";
      nameLabel.style.fontSize = "14px";
      nameLabel.style.fontWeight = "bold"; // Establecer negrita
      if (tipo==='step'){
        nameLabel.textContent = "Nombre de la tarea:";
      }
      if (tipo==='milestone'){
        nameLabel.textContent = "Nombre del hito:";
      }
      contentContainer.appendChild(nameLabel);

      // Mostrar el campo de nombre en una l√≠nea nueva
      var nombreInput = document.createElement("input");
      nombreInput.type = "text";
      nombreInput.id = "nombre";
      nombreInput.value = name;
      nombreInput.autocomplete = "off";
      nombreInput.style.fontFamily = "Arial";
      nombreInput.setAttribute("size", "40");
      contentContainer.appendChild(nombreInput);

      // Agregar un retorno de carro
      contentContainer.appendChild(document.createElement("br"));
      contentContainer.appendChild(document.createElement("br"));


        if (tipo==='step'){
          // Mostrar "Rol:" en una l√≠nea nueva
          var rolLabel = document.createElement("label");
      rolLabel.for = "rol";
      rolLabel.style.fontFamily = "Arial";
      rolLabel.style.fontSize = "14px";
      rolLabel.textContent = "Rol:";
      rolLabel.style.fontWeight = "bold";
      contentContainer.appendChild(rolLabel);



        // Mostrar el campo de rol en una l√≠nea nueva
        var rolSelect = document.createElement("select");
      rolSelect.id = "rol";
      rolSelect.style.fontFamily = "Arial";

      var roles = ["Ejecutor", "Supervisor", "Administrador", "Intervenci√≥n", "SGT", "Medios", "Director", "Otro"];
      roles.forEach(function (role) {
          var option = document.createElement("option");
          option.value = role;
          option.textContent = role;
          rolSelect.appendChild(option);
      });

      contentContainer.appendChild(rolSelect);

      // Crear el campo de texto adicional
      var otroRolInput = document.createElement("input");
      otroRolInput.type = "text";
      otroRolInput.id = "otroRol";
      otroRolInput.placeholder = "Especificar otro rol";
      otroRolInput.style.fontFamily = "Arial";

      // Configurar el campo de selecci√≥n de "Rol"
      if (isNew) {
        rolSelect.value = roles[0];
        rol= roles[0];
      }else{
        rolSelect.value = rol;
      }
      

      // Verificar si el valor de "rol" coincide con "Otro" para mostrar u ocultar el campo de texto

      if (roles.includes(rol) && rol !== "Otro") {
        otroRolInput.style.display = "none"; // Ocultar campo de texto adicional
      }else{
        otroRolInput.style.display = "block"; // Mostrar campo de texto adicional
        otroRolInput.value=rol;
        rol="Otro";
        rolSelect.value = rol;
      }

      contentContainer.appendChild(otroRolInput); // Agregar el campo de texto adicional



      // Manejar el cambio en la selecci√≥n de "Rol"
      rolSelect.addEventListener("change", function () {
          var selectedRol = rolSelect.value;
          otroRolInput.style.display = selectedRol === "Otro" ? "block" : "none"; // Mostrar u ocultar campo de texto adicional
      });

      // Agregar un retorno de carro
      contentContainer.appendChild(document.createElement("br"));
      contentContainer.appendChild(document.createElement("br"));


      // Mostrar "Duraci√≥n estimada (d√≠as):" en una l√≠nea nueva
      var duracionLabel = document.createElement("label");
      duracionLabel.for = "duracion";
      duracionLabel.style.fontFamily = "Arial";
      duracionLabel.style.fontSize = "14px";
      duracionLabel.textContent = "Duraci√≥n estimada: ";
      duracionLabel.style.fontWeight = "bold";
      contentContainer.appendChild(duracionLabel);

      // Crear un campo de entrada de tipo n√∫mero para la duraci√≥n
      var duracionInput = document.createElement("input");
      duracionInput.type = "number";
      duracionInput.id = "duracion";
      duracionInput.value = duracion || "";
      duracionInput.style.fontFamily = "Arial";
      duracionInput.setAttribute("maxlength", "5"); // Establecer la longitud m√°xima en 5 caracteres
      duracionInput.style.width = "50px"; // Establecer el ancho deseado en p√≠xeles
      contentContainer.appendChild(duracionInput);


      // Crear un desplegable (select) para elegir entre "d√≠as", "meses" y "a√±os"
      var unidadDuracionSelect = document.createElement("select");
      unidadDuracionSelect.id = "unidadDuracion";
      unidadDuracionSelect.style.fontFamily = "Arial";
      contentContainer.appendChild(unidadDuracionSelect);

      // Crear las opciones para el desplegable "Unidad de duraci√≥n"
      var unidadDuracionOpcionDias = document.createElement("option");
      unidadDuracionOpcionDias.value = "n";
      unidadDuracionOpcionDias.text = "D√≠as naturales";
      unidadDuracionSelect.appendChild(unidadDuracionOpcionDias);

      var unidadDuracionOpcionDias = document.createElement("option");
      unidadDuracionOpcionDias.value = "h";
      unidadDuracionOpcionDias.text = "D√≠as h√°biles";
      unidadDuracionSelect.appendChild(unidadDuracionOpcionDias);

      var unidadDuracionOpcionDias = document.createElement("option");
      unidadDuracionOpcionDias.value = "l";
      unidadDuracionOpcionDias.text = "D√≠as laborables";
      unidadDuracionSelect.appendChild(unidadDuracionOpcionDias);

      var unidadDuracionOpcionMeses = document.createElement("option");
      unidadDuracionOpcionMeses.value = "m";
      unidadDuracionOpcionMeses.text = "Meses";
      unidadDuracionSelect.appendChild(unidadDuracionOpcionMeses);

      var unidadDuracionOpcionAnos = document.createElement("option");
      unidadDuracionOpcionAnos.value = "a";
      unidadDuracionOpcionAnos.text = "A√±os";
      unidadDuracionSelect.appendChild(unidadDuracionOpcionAnos);

      unidadDuracionSelect.value = unidadduracion || "n";


      // Agregar un retorno de carro
      contentContainer.appendChild(document.createElement("br"));


    

//Hasta aqu√≠ llegaba if tipo===step


    
      // Mostrar "Instrucciones:" en una l√≠nea nueva
      var instructionsLabel = document.createElement("label");
      instructionsLabel.for = "instrucciones";
      instructionsLabel.style.verticalAlign = "top";
      instructionsLabel.style.fontFamily = "Arial";
      instructionsLabel.style.fontSize = "14px";
      if (tipo==='step'){
      instructionsLabel.textContent = "Instrucciones: ";
      }
      if (tipo==='milestone'){
        instructionsLabel.textContent = "Descripci√≥n: ";
      }
      instructionsLabel.style.fontWeight = "bold";
      contentContainer.appendChild(document.createElement("br"));
      // Mostrar "Instrucciones:" en una l√≠nea nueva
      var instructionsExpLabel = document.createElement("label");
      instructionsExpLabel.for = "explicaci√≥n instrucciones";
      instructionsExpLabel.style.verticalAlign = "top";
      instructionsExpLabel.style.fontFamily = "Arial";
      instructionsExpLabel.style.fontSize = "14px";


      if (tipo==='step'){
      instructionsExpLabel.textContent = "(para v√≠nculo a archivo cargado poner /*nombrearchivo*/)";
      }
      if (tipo==='milestone'){
        instructionsExpLabel.textContent = "(para v√≠nculo a archivo cargado poner /*nombrearchivo*/)";
      }

      contentContainer.appendChild(instructionsLabel);
      contentContainer.appendChild(document.createElement("br"));

      // Mostrar el campo de instrucciones en una l√≠nea nueva
      var instructionsTextarea = document.createElement("textarea");
      instructionsTextarea.id = "instrucciones";
      instructionsTextarea.rows = "10";
      instructionsTextarea.cols = "65";
      instructionsTextarea.style.fontFamily = "Arial";
      instructionsTextarea.style.overflowY = "auto"; // A√±ade la barra de desplazamiento si es necesario
      instructionsTextarea.style.maxHeight = "200px"; // Altura m√°xima antes de mostrar la barra de desplazamiento
      instructionsTextarea.textContent = instructions;
      contentContainer.appendChild(instructionsTextarea);

      contentContainer.appendChild(document.createElement("br"));
      contentContainer.appendChild(document.createElement("br"));


        // Desplegable para "Gestionar m√∫ltiples tareas en paralelo:"
    var gestionarLabel = document.createElement("label");
    gestionarLabel.textContent = "Hacer esta tarea m√∫ltiples veces en paralelo: ";
    gestionarLabel.style.fontFamily = "Arial";
    gestionarLabel.style.fontSize = "14px";
    gestionarLabel.style.fontWeight = "bold";
    contentContainer.appendChild(gestionarLabel);

    var gestionarSelect = document.createElement("select");
    gestionarSelect.id = "gestionarMultiplesTareas";
    gestionarSelect.style.fontFamily = "Arial";

    ["NO", "SI"].forEach(function (optionText) {
        var option = document.createElement("option");
        option.value = optionText;
        option.textContent = optionText;
        gestionarSelect.appendChild(option);
    });
    contentContainer.appendChild(gestionarSelect);

    // Agregar un retorno de carro
    //dialogDiv.appendChild(document.createElement("br"));
    //dialogDiv.appendChild(document.createElement("br"));

    // Desplegable condicional "Conectar cada tarea m√∫ltiple con las de la tarea anterior:"
    var conectarLabel = document.createElement("label");
    conectarLabel.innerHTML = "Conectar cada tarea m√∫ltiple con las de la tarea anterior: ";
    conectarLabel.style.fontFamily = "Arial";
    conectarLabel.style.fontSize = "14px";
    conectarLabel.style.fontWeight = "bold";
    conectarLabel.style.display = "none"; // Oculto inicialmente
    contentContainer.appendChild(document.createElement("br"));
    contentContainer.appendChild(conectarLabel);

   

    var conectarSelect = document.createElement("select");
    conectarSelect.id = "conectarTareasMultiples";
    conectarSelect.style.fontFamily = "Arial";
    conectarSelect.style.display = "none"; // Oculto inicialmente

    ["NO", "Tarea XX"].forEach(function (optionText) {
        var option = document.createElement("option");
        option.value = optionText;
        option.textContent = optionText;
        conectarSelect.appendChild(option);
    });
    contentContainer.appendChild(conectarSelect);
    contentContainer.appendChild(document.createElement("br"));


    // Inicializar "Gestionar m√∫ltiples tareas en paralelo:"
    gestionarSelect.value = multiple ? "SI" : "NO";

 // Inicializar "Conectar cada tarea m√∫ltiple con las de la tarea anterior:"
// Inicializar "Conectar cada tarea m√∫ltiple con las de la tarea anterior:"
if (multiple) {
    conectarLabel.style.display = "inline";
    conectarSelect.style.display = "inline";

    // Limpiar opciones existentes en el desplegable
    conectarSelect.innerHTML = "";

    // Agregar opci√≥n "NO" al inicio
    var noOption = document.createElement("option");
    noOption.value = "NO";
    noOption.textContent = "NO";
    conectarSelect.appendChild(noOption);

    // Agregar tareas previas con is_a_multiple_task === "true"
    if (flowchartData.hasOwnProperty("paths") && flowchartData.hasOwnProperty("steps")) {
        var previousSteps = [];

        // Buscar pasos previos
        flowchartData.paths.forEach(function (path) {
            if (path.endStep === stepId) {
                previousSteps.push(path.startStep); // Guardar el paso inicial
            }
        });

        // Filtrar pasos previos que tengan is_a_multiple_task === "true"
        previousSteps.forEach(function (prevStepId) {
            var step = flowchartData.steps.find(function (s) {
                return s.id === prevStepId && s.is_a_multiple_task === "true";
            });

            if (step) {
                var option = document.createElement("option");
                option.value = step.id; // Internamente se usa el id
                option.textContent = step.label; // Visualmente se muestra el label
                conectarSelect.appendChild(option);
            }
        });
    }

    console.log("1. previous_multiple: "+previous_multiple);
    // Seleccionar el valor de multiple_task_following_previous o "NO"
    if (typeof previous_multiple === "string" && previous_multiple.startsWith("step")) {
        var previousStep = flowchartData.steps.find(function (s) {
            return s.id === previous_multiple && s.is_a_multiple_task === "true";
        });
        console.log("previousStep: "+previousStep);
        console.log("previous_multiple: "+previous_multiple);


        if (previousStep) {
          conectarSelect.value = previous_multiple; // Seleccionar por id, visualmente mostrar√° el label
       } else {
            conectarSelect.value = "NO"; // Valor por defecto si el step no existe o no cumple el criterio
        }
    } else {
        conectarSelect.value = "NO"; // Valor por defecto si no hay previous_multiple v√°lido
    }
} else {
    // Ocultar el desplegable si no es una tarea m√∫ltiple
    conectarLabel.style.display = "none";
    conectarSelect.style.display = "none";
}




    // L√≥gica para mostrar/ocultar el segundo desplegable
    if (gestionarSelect.value === "SI") {
        conectarLabel.style.display = "inline";
        conectarSelect.style.display = "inline";
    } else {
        conectarLabel.style.display = "none";
        conectarSelect.style.display = "none";
    }
    

    // Agregar l√≥gica para mostrar/ocultar el segundo desplegable
gestionarSelect.addEventListener("change", function () {
    var gestionarValue = gestionarSelect.value;

    if (gestionarValue === "NO") {
        // Verificar si hay elementos "Uno para cada √≠tem"
        var elementosConflictivos = infoElements.filter(e => e.scope === "Uno para cada √≠tem");
        if (elementosConflictivos.length > 0) {
            var nombres = elementosConflictivos.map(e => `- ${e.name}`).join("\n");
            alert("No puedes cambiar a 'NO' porque tienes elementos definidos como 'Uno para cada √≠tem':\n\n" + nombres);
            
            // Volver a poner la selecci√≥n en "SI"
            gestionarSelect.value = "SI";
            return; // Detener la ejecuci√≥n
        }
    }


    if (gestionarValue === "SI") {
        conectarLabel.style.display = "inline";
        conectarSelect.style.display = "inline";

        // Limpiar opciones existentes en el desplegable
        conectarSelect.innerHTML = ""; 

        // Buscar tareas previas
        var previousSteps = [];
        if (flowchartData.hasOwnProperty("paths")) {
            var paths = flowchartData.paths;


            for (var i = 0; i < paths.length; i++) {
                if (paths[i].endStep === stepId) {
                    previousSteps.push(paths[i].startStep); // Obtener el paso inicial (previo)
                }
            }
        }

        // Agregar opci√≥n "NO" al inicio
        var noOption = document.createElement("option");
        noOption.value = "NO";
        noOption.textContent = "NO";
        conectarSelect.appendChild(noOption);

        // Agregar tareas previas al desplegable
        previousSteps.forEach(function (stepId) {
            var step = flowchartData.steps.find(function (s) {
                return s.id === stepId;
            });
            if (step) {
                var option = document.createElement("option");
                option.value = step.id;
                option.textContent = step.label || `Tarea ${step.id}`;
                conectarSelect.appendChild(option);
            }
        });

    } else {
        conectarLabel.style.display = "none";
        conectarSelect.style.display = "none";
        conectarSelect.value = "NO"; // Restablecer a "NO" si se desactiva
   
    }
    actualizarVisibilidadScope(); // Asegurarse de que se oculte/visualice el campo Aplicaci√≥n
    updateInfoList(); // Actualizar la lista para ocultar/mostrar el scope
});



// Contenedor de elementos recibidos
var receivedContainer = document.createElement("div");
receivedContainer.style.marginTop = "20px";
contentContainer.appendChild(receivedContainer);

// T√≠tulo
var receivedTitle = document.createElement("h4");
receivedTitle.style.fontFamily = "Arial";
receivedTitle.textContent = "Elementos de Informaci√≥n recibidos:";
receivedContainer.appendChild(receivedTitle);

// Desplegable de tareas conectadas anteriores por path.type === 'path'
var taskSelectLabel = document.createElement("label");
taskSelectLabel.textContent = "A√±adir informaci√≥n de tarea previa o bloque de texto o html:";
taskSelectLabel.style.fontFamily = "Arial";
receivedContainer.appendChild(taskSelectLabel);

var taskSelect = document.createElement("select");
taskSelect.style.marginLeft = "10px";
taskSelect.style.fontFamily = "Arial";
receivedContainer.appendChild(taskSelect);

// Opci√≥n para bloque de HTML
var htmlOption = document.createElement("option");
htmlOption.value = "__html_block__";
htmlOption.textContent = "[A√±adir bloque de texto o html]";
taskSelect.appendChild(htmlOption);

// Cargar tareas conectadas por path

// Cargar tareas conectadas por path
var connectedSteps = (flowchartData.paths || [])
  .filter(p => p.type === "path" && p.endStep === stepId)
  .map(p => p.startStep);

connectedSteps.forEach(stepId => {
  var step = flowchartData.steps.find(s => s.id === stepId);
  if (step) {
    var option = document.createElement("option");
    option.value = step.id;
    option.textContent = step.label || `Tarea ${step.id}`;
    taskSelect.appendChild(option);
  }
});

// Desplegable de elementos disponibles en esa tarea
var elementLabel = document.createElement("span");
elementLabel.textContent = "Selecciona un elemento: ";
var elementSelect = document.createElement("select");
elementSelect.style.fontFamily = "Arial";
elementSelect.style.marginTop = "10px";
elementSelect.style.marginLeft = "10px";
receivedContainer.appendChild(document.createElement("br"));
receivedContainer.appendChild(elementLabel);
receivedContainer.appendChild(elementSelect);

// Bot√≥n de a√±adir elemento recibido
var addReceivedBtn = document.createElement("button");
addReceivedBtn.textContent = "A√±adir";
addReceivedBtn.style.marginLeft = "10px";
receivedContainer.appendChild(addReceivedBtn);

// Lista visual de elementos a√±adidos
var receivedList = document.createElement("ul");
receivedList.style.marginTop = "10px";
receivedContainer.appendChild(receivedList);

// Lista l√≥gica para guardar los elementos seleccionados
var receivedElements = [];

// cargamos los datos si exist√≠an
if (!isNew) {
    const selectedStepData = flowchartData.steps.find(step => step.id === stepId);
    if (Array.isArray(selectedStepData.receivedElements)) {
        receivedElements = JSON.parse(JSON.stringify(selectedStepData.receivedElements));
        renderReceivedList(); 
    } else {
        receivedElements = [];
    }  
}

// Actualizar elementos disponibles al cambiar de tarea
function actualizarElementos() {
  const selectedValue = taskSelect.value;
  elementSelect.innerHTML = "";

  const esHTML = selectedValue === "__html_block__";
  elementLabel.style.display = esHTML ? "none" : "inline";
  elementSelect.style.display = esHTML ? "none" : "inline";

  if (!esHTML) {
    const selectedTask = flowchartData.steps.find(s => s.id === selectedValue);
    if (selectedTask?.infoElements) {
      selectedTask.infoElements.forEach(e => {
        var option = document.createElement("option");
        option.value = JSON.stringify({ stepId: selectedTask.id, element: e });
        var apartado = e.apartado ? ` | ${e.apartado}` : "";
        option.textContent = `${e.name}${apartado}`;
        elementSelect.appendChild(option);
      });
    }
  }
}

taskSelect.addEventListener("change", actualizarElementos);

// A√±adir a la lista
addReceivedBtn.addEventListener("click", function () {
  const selectedValue = taskSelect.value;

  if (selectedValue === "__html_block__") {
    receivedElements.push({ type: "htmlBlock", content: "" });
  } else if (elementSelect.value) {
    var parsed = JSON.parse(elementSelect.value);
    receivedElements.push(parsed);
  } else {
    return;
  }

  renderReceivedList();
});

function renderReceivedList() {
  receivedList.innerHTML = "";
  receivedElements.forEach((e, idx) => {
    const item = document.createElement("li");
    item.style.fontFamily = "Arial";
    item.style.display = "flex";
    item.style.alignItems = "center";
    item.style.marginBottom = "4px";

    // Contenedor horizontal para botones ‚ñ≤ ‚ñº
    const btnContainer = document.createElement("div");
    btnContainer.style.display = "flex";
    btnContainer.style.gap = "2px"; // Espacio muy peque√±o entre botones
    btnContainer.style.marginRight = "6px";

    const upBtn = document.createElement("span");
    upBtn.textContent = "‚ñ≤";
    upBtn.style.cursor = "pointer";
    upBtn.style.userSelect = "none";
    upBtn.onclick = () => {
      if (idx > 0) {
        const temp = receivedElements[idx];
        receivedElements[idx] = receivedElements[idx - 1];
        receivedElements[idx - 1] = temp;
        renderReceivedList();
      }
    };

    const downBtn = document.createElement("span");
    downBtn.textContent = "‚ñº";
    downBtn.style.cursor = "pointer";
    downBtn.style.userSelect = "none";
    downBtn.onclick = () => {
      if (idx < receivedElements.length - 1) {
        const temp = receivedElements[idx];
        receivedElements[idx] = receivedElements[idx + 1];
        receivedElements[idx + 1] = temp;
        renderReceivedList();
      }
    };

    btnContainer.appendChild(upBtn);
    btnContainer.appendChild(downBtn);

    // Texto del elemento
    const labelSpan = document.createElement("span");
    if (e.type === "htmlBlock") {
      labelSpan.textContent = "[Bloque de texto o html]";
    } else {
      const step = flowchartData.steps.find(s => s.id === e.stepId);
      const stepLabel = step?.label || e.stepId;
      labelSpan.textContent = `${e.element.name} (${e.element.type}) [${stepLabel}]`;
    }

    // Bot√≥n borrar
    const delBtn = document.createElement("button");
    delBtn.textContent = "Borrar";
    delBtn.style.marginLeft = "10px";
    delBtn.onclick = () => {
      receivedElements.splice(idx, 1);
      renderReceivedList();
    };

    item.appendChild(btnContainer);
    item.appendChild(labelSpan);
    item.appendChild(delBtn);

    // Si es bloque de HTML, a√±adir bot√≥n de desplegar
    if (e.type === "htmlBlock") {
      const toggleBtn = document.createElement("button");
      toggleBtn.textContent = "‚ñº";
      toggleBtn.style.marginLeft = "10px";

      const textArea = document.createElement("textarea");
      textArea.value = e.html || "";
      textArea.style.display = "none";
      textArea.style.marginTop = "5px";
      textArea.style.width = "100%";
      textArea.rows = 4;
      textArea.addEventListener("input", () => {
        e.html = textArea.value;
      });

      toggleBtn.onclick = () => {
        const visible = textArea.style.display !== "none";
        textArea.style.display = visible ? "none" : "block";
      };

      item.appendChild(toggleBtn);
      item.appendChild(document.createElement("br"));
      item.appendChild(textArea);
    }

    receivedList.appendChild(item);
  });
}




// Preseleccionar primera tarea si hay alguna
taskSelect.selectedIndex = 0;
actualizarElementos();



// Contenedor para los elementos de informaci√≥n
var infoContainer = document.createElement("div");
infoContainer.style.marginTop = "20px";
contentContainer.appendChild(infoContainer);

// T√≠tulo para los elementos de informaci√≥n
var infoTitle = document.createElement("h4");
infoTitle.style.fontFamily = "Arial";
infoTitle.fontSize = "12px";
infoTitle.textContent = "Elementos de Informaci√≥n a aportar:";
infoContainer.appendChild(infoTitle);

// Cuadro de texto para estructura de apartados
var structureLabel = document.createElement("label");
structureLabel.textContent = "Estructura de apartados (una l√≠nea por apartado, usar > y >> para subniveles):";
structureLabel.style.fontFamily = "Arial";
structureLabel.style.fontSize = "14px";
structureLabel.style.fontWeight = "bold";
infoContainer.appendChild(structureLabel);

var structureTextarea = document.createElement("textarea");
structureTextarea.id = "estructuraApartados";
structureTextarea.style.width = "100%";
structureTextarea.style.height = "100px";
structureTextarea.style.fontFamily = "Arial";
// Cargar estructura de apartados si existe
if (!isNew) {
    selectedStepData = flowchartData.steps.find(step => step.id === stepId);
    if (selectedStepData && selectedStepData.estructuraApartados) {
        let estructuraTexto = "";

        if (typeof selectedStepData.estructuraApartados === "string") {
            estructuraTexto = selectedStepData.estructuraApartados;
        } else if (Array.isArray(selectedStepData.estructuraApartados)) {
            estructuraTexto = selectedStepData.estructuraApartados.join("\n");
        } else {
            console.warn("‚ö†Ô∏è estructuraApartados tiene un formato inesperado:", selectedStepData.estructuraApartados);
            estructuraTexto = "";
        }

        structureTextarea.value = estructuraTexto
            .split("\n")
            .map(s => s === "(Sin t√≠tulo)" ? "" : s)
            .join("\n");

        infoElements = selectedStepData.infoElements || [];

        // Asignar "(Seleccionar apartado)" a elementos hu√©rfanos
        if (structureTextarea.value.trim() !== "") {
            infoElements.forEach(e => {
                if (!e.apartado) {
                    e.apartado = "(Seleccionar apartado)";
                }
            });
        }
    }
}


structureTextarea.addEventListener("blur", function () {
    console.log("üîµ BLUR lanzado");

    // Normalizamos el texto
    const apartadosValidos = obtenerApartadosConRutaCompleta();
    const estructuraApartados = normalizarStructureTextareaValue(structureTextarea.value).trim();


    console.log("‚úÖ Apartados v√°lidos normalizados:", apartadosValidos);

    const items = infoList.querySelectorAll("li");
    console.log("infoList:", infoList);
    console.log("√≠tems:", items);

    items.forEach((item, index) => {
        const element = infoElements[index];
        // Eliminar select antiguo si existe
        let selectAntiguo = item.querySelector("select");
        if (selectAntiguo) {
            item.removeChild(selectAntiguo);
        }

        // Crear select nuevo siempre
        const select = document.createElement("select");
        select.style.marginLeft = "10px";
        select.style.fontFamily = "Arial";

        // Crear las opciones
        apartadosValidos.forEach(ap => {
            const option = document.createElement("option");
            option.value = ap;
            option.textContent = ap;
            select.appendChild(option);
        });

        // Asignar el valor actual
        select.value = element.apartado || "(Sin t√≠tulo)";

        // üî• Ahora s√≠, conectar el listener
        select.addEventListener("change", function () {
            console.log("‚úèÔ∏è EVENTO CHANGE ACTIVADO en este SELECT:", select);
            console.log("- Nuevo select.value:", select.value);
            console.log("- Antes element.apartado era:", element.apartado);

            element.apartado = select.value;

            console.log("- Ahora element.apartado es:", element.apartado);

            select.style.border = "";

            if (typeof infoElementsDataPorInstancia !== "undefined") {
                console.log("- Estado actual de infoElementsDataPorInstancia:", infoElementsDataPorInstancia);
            }

           // updateInfoList();
        });
        console.log("üõ†Ô∏è SELECT construido y listener a√±adido:", select);



        // Insertar el nuevo select en el √≠tem
        item.appendChild(select);



        console.log(`üî∏ Opciones creadas en SELECT del elemento ${index}:`, apartadosValidos);

        // Recuperar valor previo
        const valorPrevio = element.apartado || "(Sin t√≠tulo)";
        console.log(`üî∏ Valor previo del elemento ${index}:`, valorPrevio);

        // Seleccionar autom√°ticamente si existe
        if (apartadosValidos.includes(valorPrevio)) {
            select.value = valorPrevio;
            console.log(`‚úÖ Valor seleccionado autom√°ticamente en SELECT ${index}:`, valorPrevio);
            select.style.border = "";
        } else {
            console.warn(`‚ö†Ô∏è Valor previo NO encontrado en apartados v√°lidos:`, valorPrevio);
            select.style.border = "2px solid red"; // üî•
        }


          select.addEventListener("change", function () {
          console.log("‚úèÔ∏è Cambio detectado en select:");
          console.log("- Nuevo select.value:", select.value);
          console.log("- Antes element.apartado era:", element.apartado);

          element.apartado = select.value;

          console.log("- Ahora element.apartado es:", element.apartado);

          select.style.border = "";

          // Opcional: ¬øTienes infoElementsDataPorInstancia?
          if (typeof infoElementsDataPorInstancia !== "undefined") {
              console.log("- Estado actual de infoElementsDataPorInstancia:", infoElementsDataPorInstancia);
          }

         // updateInfoList();
      });


            select.dataset.listenerAttached = "true";
        
    });

    // üî• Despu√©s de recorrer todos los elementos...
    const algunElementoMalAsignado = infoElements.some(e => !apartadosValidos.includes(e.apartado || "(Seleccionar apartado)"));

    if (algunElementoMalAsignado) {
        console.error("üö® Hay elementos cuyo apartado no coincide con el cuadro de texto actual.");
        alert("Hay elementos cuyo apartado no coincide con el cuadro de texto actual. Por favor, rev√≠salos.");
    }

    updateInfoList();
});







infoContainer.appendChild(structureTextarea);
infoContainer.appendChild(document.createElement("br"));
infoContainer.appendChild(document.createElement("br"));


// Desplegable para seleccionar el tipo de elemento de informaci√≥n
var infoTypeLabel = document.createElement("label");
infoTypeLabel.textContent = "Tipo: ";
infoTypeLabel.style.fontFamily = "Arial";
infoTypeLabel.style.fontSize = "14px";
infoContainer.appendChild(infoTypeLabel);

var infoTypeSelect = document.createElement("select");
infoTypeSelect.style.fontFamily = "Arial";

[
    "Archivo",
    "Texto corto",
    "Texto largo",
    "Texto ocultado",
    "Texto o html (no editable)",
    "Fecha",
    "Hora",
    "N√∫mero",
    "Importe en ‚Ç¨",
    "Porcentaje",
    "NIF",
    "Cuenta bancaria",
    "C√≥digo postal",
    "Localidad",
    "Coordenadas WGS84",
    "Desplegable selecci√≥n √∫nica",
    "Desplegable selecci√≥n m√∫ltiple",
    "Check independiente",
    "Check ligado a grupo",
    "Tabla"
].forEach(function (optionText) {
    const option = document.createElement("option");
    option.value = optionText;
    option.textContent = optionText;
    infoTypeSelect.appendChild(option);
});
infoContainer.appendChild(infoTypeSelect);

// Campo de texto para el nombre del elemento
var infoNameLabel = document.createElement("label");
infoNameLabel.textContent = " Nombre: ";
infoNameLabel.style.fontFamily = "Arial";
infoNameLabel.style.fontSize = "14px";
infoContainer.appendChild(infoNameLabel);

var infoNameInput = document.createElement("input");
infoNameInput.type = "text";
infoNameInput.style.fontFamily = "Arial";
infoContainer.appendChild(infoNameInput);



// Campo de selecci√≥n de apartado (si existe estructura)
var apartadoSelectLabel = document.createElement("label");
apartadoSelectLabel.textContent = " Apartado: ";
apartadoSelectLabel.style.fontFamily = "Arial";
apartadoSelectLabel.style.fontSize = "14px";

var apartadoSelect = document.createElement("select");
apartadoSelect.style.fontFamily = "Arial";

// Solo mostrar si hay estructura
function actualizarApartadoSelect() {
    apartadoSelect.innerHTML = "";
    const estructuraTexto = normalizarStructureTextareaValue(structureTextarea.value).trim();
    const lineas = estructuraTexto.split("\n");

    if (estructuraTexto === "") {
        apartadoSelect.style.display = "none";
        apartadoSelectLabel.style.display = "none";
        return;
    }

    apartadoSelect.style.display = "inline";
    apartadoSelectLabel.style.display = "inline";

    let apartados = [];
    let rutaActual = [];

    lineas.forEach(function (linea) {
        const texto = linea.trim();
        if (texto.startsWith(">>")) {
            if (rutaActual.length > 1) rutaActual = rutaActual.slice(0, 2);
            rutaActual[2] = texto.substring(2).trim();
        } else if (texto.startsWith(">")) {
            if (rutaActual.length > 0) rutaActual = rutaActual.slice(0, 1);
            rutaActual[1] = texto.substring(1).trim();
        } else {
            rutaActual = [texto];
        }
        apartados.push(rutaActual.join(">"));
    });

    apartados.forEach(function (ruta) {
        const opcion = document.createElement("option");
        opcion.value = ruta;
        opcion.textContent = ruta;
        apartadoSelect.appendChild(opcion);
    });

    // Opci√≥n por defecto al final
    const opcionSinTitulo = document.createElement("option");
    opcionSinTitulo.value = "(Seleccionar apartado)";
    opcionSinTitulo.textContent = "(Seleccionar apartado)";
    apartadoSelect.appendChild(opcionSinTitulo);

    apartadoSelect.value = "(Seleccionar apartado)";
}
actualizarApartadoSelect();
structureTextarea.addEventListener("input", actualizarApartadoSelect);

// A√±adir al contenedor
infoContainer.appendChild(apartadoSelectLabel);
infoContainer.appendChild(apartadoSelect);


// Desplegable para la opci√≥n de aplicaci√≥n
var infoScopeLabel = document.createElement("label");
infoScopeLabel.textContent = " Aplicaci√≥n en paralelo: ";
infoScopeLabel.style.fontFamily = "Arial";
infoScopeLabel.style.fontSize = "14px";
infoContainer.appendChild(infoScopeLabel);

var infoScopeSelect = document.createElement("select");
infoScopeSelect.style.fontFamily = "Arial";
["Uno para todos los √≠tems", "Uno para cada √≠tem"].forEach(function (optionText) {
    var option = document.createElement("option");
    option.value = optionText;
    option.textContent = optionText;
    infoScopeSelect.appendChild(option);
});
infoContainer.appendChild(infoScopeSelect);

// Contenedor para el campo de aplicaci√≥n (para mostrar/ocultar f√°cilmente)
var scopeContainer = document.createElement("span");
scopeContainer.appendChild(infoScopeLabel);
scopeContainer.appendChild(infoScopeSelect);
infoContainer.appendChild(scopeContainer);

// Mostrar u ocultar el desplegable de aplicaci√≥n seg√∫n la selecci√≥n de "gestionar m√∫ltiples"
function actualizarVisibilidadScope() {
    const esMultiple = gestionarSelect.value === "SI";
    scopeContainer.style.display = esMultiple ? "inline" : "none";
}
actualizarVisibilidadScope(); // Llamada inicial
gestionarSelect.addEventListener("change", actualizarVisibilidadScope);



// Bot√≥n para a√±adir el elemento a la lista
var addInfoButton = document.createElement("button");
addInfoButton.textContent = "A√±adir";
addInfoButton.style.marginLeft = "10px";
infoContainer.appendChild(addInfoButton);

// Lista para mostrar los elementos a√±adidos
var infoList = document.createElement("ul");
infoList.style.marginTop = "20px";
infoContainer.appendChild(infoList);

// L√≥gica para a√±adir elementos a la lista
var infoElements = [];

addInfoButton.addEventListener("click", function () {
    var type = infoTypeSelect.value;
    var name = infoNameInput.value.trim();

    if (!name) {
        alert("Por favor, introduce un nombre para el elemento.");
        return;
    }

    var scope = gestionarSelect.value === "SI" ? infoScopeSelect.value : "Uno para todos los √≠tems";

    // Obtener valor del apartado seleccionado, si existe
    let apartadoElegido = "(Seleccionar apartado)";
    if (structureTextarea.value.trim() !== "" && typeof apartadoSelect !== "undefined") {
        apartadoElegido = apartadoSelect.value || "(Seleccionar apartado)";
    }

    var newElement = {
        type,
        name,
        scope,
        apartado: apartadoElegido
    };

    if (type === "Texto o html (no editable)") {
        newElement.obligatorio = false; // expl√≠citamente no obligatorio
    }

    if (type === "Tabla") {
        newElement.tabla = {
            rows: []
        };
    }

    if (type === "Desplegable selecci√≥n √∫nica") {
        newElement.opciones = [];
    }

    infoElements.push(newElement);

    // Actualizar la lista visual
    updateInfoList();
});



function obtenerApartadosConRutaCompleta() {
    const estructuraTexto = normalizarStructureTextareaValue(structureTextarea.value).trim();
    const lineas = estructuraTexto.split("\n");

    let apartados = [];
    let rutaActual = [];

    lineas.forEach(function (linea) {
        const texto = linea.trim();
        if (texto === "(Seleccionar apartado)") return;

        if (texto.startsWith(">>")) {
            // üî• Nivel 2: sobreescribimos el √∫ltimo nivel 2
            if (rutaActual.length > 1) {
                rutaActual = rutaActual.slice(0, 2); // Solo ra√≠z y sub1
            }
            rutaActual[2] = texto.substring(2).trim(); // Nuevo subsub
        } else if (texto.startsWith(">")) {
            // üî• Nivel 1: sobreescribimos dejando solo ra√≠z
            if (rutaActual.length > 0) {
                rutaActual = rutaActual.slice(0, 1);
            }
            rutaActual[1] = texto.substring(1).trim(); // Nuevo sub1
        } else {
            // üî• Nivel 0: ra√≠z nueva
            rutaActual = [texto];
        }

        apartados.push(rutaActual.join(">"));
    });

    //apartados.push("(Sin t√≠tulo)");

    return apartados;
}

function moverElemento(elemento, direccion) {
    const indexActual = infoElements.indexOf(elemento);
    if (indexActual === -1) return;

    // Obtener el apartado actual del elemento
    const apartadoActual = elemento.apartado || "(Seleccionar apartado)";

    // Filtrar los elementos que est√°n en el mismo apartado
    const indicesMismoApartado = infoElements
        .map((el, idx) => ({ el, idx }))
        .filter(({ el }) => (el.apartado || "(Seleccionar apartado)") === apartadoActual)
        .map(({ idx }) => idx);

    const posDentroDelApartado = indicesMismoApartado.indexOf(indexActual);
    const nuevaPos = posDentroDelApartado + direccion;

    if (nuevaPos < 0 || nuevaPos >= indicesMismoApartado.length) return; // fuera de rango

    // Intercambiar elementos en infoElements
    const idxDestino = indicesMismoApartado[nuevaPos];
    const temp = infoElements[indexActual];
    infoElements[indexActual] = infoElements[idxDestino];
    infoElements[idxDestino] = temp;
}


// Funci√≥n para actualizar la lista visual de elementos
function updateInfoList() {
    infoList.innerHTML = "";

    const estructuraTexto = normalizarStructureTextareaValue(structureTextarea.value).trim();
    const lineas = estructuraTexto.split("\n");
    const campoEstaRealmenteVacio = structureTextarea.value.trim() === "";

    let apartadosEnOrden = [];
    let rutaActual = [];

    lineas.forEach(function (linea) {
        const texto = linea.trim();
        if (texto === "(Seleccionar apartado)") return;

        if (texto.startsWith(">>")) {
            if (rutaActual.length > 1) rutaActual = rutaActual.slice(0, 2);
            rutaActual[2] = texto.substring(2).trim();
        } else if (texto.startsWith(">")) {
            if (rutaActual.length > 0) rutaActual = rutaActual.slice(0, 1);
            rutaActual[1] = texto.substring(1).trim();
        } else {
            rutaActual = [texto];
        }

        apartadosEnOrden.push(rutaActual.join(">"));
    });

    const haySinAsignar = infoElements.some(e => e.apartado === "(Seleccionar apartado)");
    if (haySinAsignar) apartadosEnOrden.push("(Seleccionar apartado)");

    if (campoEstaRealmenteVacio) {
        infoElements.forEach(function (element) {
            crearItemElemento(element, false);
        });
        return;
    }

    // üîÅ Asegurar que todos los elementos tengan apartados v√°lidos
    infoElements.forEach(e => {
        if (!e.apartado || !apartadosEnOrden.includes(e.apartado)) {
            e.apartado = "(Seleccionar apartado)";
        }
    });

    // üî∑ Separar por tipo de aplicaci√≥n
    const elementosTodos = infoElements.filter(e => e.scope !== "Uno para cada √≠tem");
    const elementosCada = infoElements.filter(e => e.scope === "Uno para cada √≠tem");


    // üî¥ Mostrar elementos sin asignar
    const sinAsignarTodos = infoElements.filter(e => 
        (e.scope !== "Uno para cada √≠tem") && e.apartado === "(Seleccionar apartado)"
    );
    const sinAsignarCada = infoElements.filter(e => 
        e.scope === "Uno para cada √≠tem" && e.apartado === "(Seleccionar apartado)"
    );


    if (sinAsignarTodos.length + sinAsignarCada.length > 0) {
        const header = document.createElement("h5");
        header.innerHTML = "Elementos sin asignar:";
        header.style.fontFamily = "Arial";
        header.style.marginTop = "16px";
        header.style.marginBottom = "4px";
        header.style.color = "red";
        header.style.fontSize = "16px";
        header.style.fontWeight = "bold";
        infoList.appendChild(header);
    }

    sinAsignarTodos.forEach(e => crearItemElemento(e, true));
    sinAsignarCada.forEach(e => crearItemElemento(e, true));

    // üî∑ Recorrer estructura para elementos "uno para todos"
    apartadosEnOrden.forEach(function (apartadoRutaCompleta) {
        if (apartadoRutaCompleta === "(Seleccionar apartado)") return;
        const partes = apartadoRutaCompleta.split(">");
        const nivelActual = partes.length - 1;
        const nombreVisible = partes[partes.length - 1];

        const hayElementos = elementosTodos.some(e =>
            e.apartado === apartadoRutaCompleta || e.apartado.startsWith(apartadoRutaCompleta + ">")
        );

        if (hayElementos) {
            const header = document.createElement("h5");
            header.innerHTML = "&nbsp;".repeat(nivelActual * 4) + nombreVisible;
            header.style.fontFamily = "Arial";
            header.style.marginTop = nivelActual === 0 ? "16px" : "8px";
            header.style.marginBottom = "12px";
            header.style.color = color_text_titles;

            if (nivelActual === 0) {
                header.style.fontSize = "16px";
                header.style.fontWeight = "bold";
            } else if (nivelActual === 1) {
                header.style.fontSize = "14px";
            } else {
                header.style.fontSize = "13px";
                header.style.fontStyle = "italic";
            }

            infoList.appendChild(header);
        }

        const elementosEnEsteApartado = elementosTodos.filter(e => e.apartado === apartadoRutaCompleta);
        elementosEnEsteApartado.forEach(e => crearItemElemento(e, true));
    });

    // üü® T√çTULO PARA CADA √çTEM
    if (elementosCada.length > 0) {
        const tituloCada = document.createElement("div");
        tituloCada.style.fontFamily = "Arial";
        tituloCada.style.fontSize = "14px";
        tituloCada.style.fontWeight = "bold";
        tituloCada.style.color = color_menu_titles;
        tituloCada.style.padding = "8px";
        tituloCada.style.margin = "20px 0 10px 0";
        tituloCada.textContent = "PARA CADA √çTEM:";
        infoList.appendChild(tituloCada);
    }

    // üî∑ Recorrer estructura para elementos "uno para cada"
    apartadosEnOrden.forEach(function (apartadoRutaCompleta) {
        if (apartadoRutaCompleta === "(Seleccionar apartado)") return;
        const partes = apartadoRutaCompleta.split(">");
        const nivelActual = partes.length - 1;
        const nombreVisible = partes[partes.length - 1];

        const hayElementos = elementosCada.some(e =>
            e.apartado === apartadoRutaCompleta || e.apartado.startsWith(apartadoRutaCompleta + ">")
        );

        if (hayElementos) {
            const header = document.createElement("h5");
            header.innerHTML = "&nbsp;".repeat(nivelActual * 4) + nombreVisible;
            header.style.fontFamily = "Arial";
            header.style.marginTop = nivelActual === 0 ? "16px" : "8px";
            header.style.marginBottom = "12px";
            header.style.color = color_text_titles;

            if (nivelActual === 0) {
                header.style.fontSize = "16px";
                header.style.fontWeight = "bold";
            } else if (nivelActual === 1) {
                header.style.fontSize = "14px";
            } else {
                header.style.fontSize = "13px";
                header.style.fontStyle = "italic";
            }

            infoList.appendChild(header);
        }

        const elementosEnEsteApartado = elementosCada.filter(e => e.apartado === apartadoRutaCompleta);
        elementosEnEsteApartado.forEach(e => crearItemElemento(e, true));
    });
}




function crearItemElemento(element, mostrarApartados) {
    const listItem = document.createElement("div");
    listItem.style.display = "flex";
    listItem.style.alignItems = "center";
    listItem.style.marginBottom = "6px";

    listItem.style.marginBottom = "10px";
    listItem.style.fontFamily = "Arial";
    listItem.style.fontSize = "14px";

    const textoElemento = document.createElement("span");
    const mostrarScope = gestionarSelect?.value === "SI";
      textoElemento.textContent = mostrarScope
        ? `${element.name} (${element.type} | ${element.scope})`
        : `${element.name} (${element.type})`;

    // Bot√≥n subir
    const btnSubir = document.createElement("button");
    btnSubir.textContent = "‚ñ≤"; 
    btnSubir.title = "Mover hacia arriba";
    btnSubir.style.border = "none";
    btnSubir.style.background = "none";
    btnSubir.style.color = "#666"; // gris
    btnSubir.style.fontSize = "14px";
    btnSubir.style.cursor = "pointer";
    btnSubir.style.marginRight = "1px";
    btnSubir.style.padding = "0";
    btnSubir.onclick = () => {
        moverElemento(element, -1);
        updateInfoList();
    };

    // Bot√≥n bajar
    const btnBajar = document.createElement("button");
    btnBajar.textContent = "‚ñº"; 
    btnBajar.title = "Mover hacia abajo";
    btnBajar.style.border = "none";
    btnBajar.style.background = "none";
    btnBajar.style.color = "#666"; // gris
    btnBajar.style.fontSize = "14px";
    btnBajar.style.cursor = "pointer";
    btnBajar.style.marginRight = "8px";
    btnBajar.style.padding = "0";
    btnBajar.onclick = () => {
        moverElemento(element, +1);
        updateInfoList();
    };

    // Insertar flechas antes del texto
    listItem.appendChild(btnSubir);
    listItem.appendChild(btnBajar);
    listItem.appendChild(textoElemento);





    // Bot√≥n eliminar
    const deleteButton = document.createElement("button");
    deleteButton.textContent = "Eliminar";
    deleteButton.style.marginLeft = "10px";
    deleteButton.addEventListener("click", function () {
        infoElements.splice(infoElements.indexOf(element), 1);
        updateInfoList();
    });
    listItem.appendChild(deleteButton);

    // Bot√≥n editar (siempre presente)
    const editarBtnGeneral = document.createElement("button");
    editarBtnGeneral.textContent = "Editar";
    editarBtnGeneral.style.marginLeft = "10px";
    editarBtnGeneral.addEventListener("click", function () {
        openElementEditor(element);
    });
    listItem.appendChild(editarBtnGeneral);


    // Bot√≥n editar para desplegables
    if (element.type === "Desplegable selecci√≥n √∫nica" || element.type === "Desplegable selecci√≥n m√∫ltiple") {
        const editarBtn = document.createElement("button");
        editarBtn.textContent = "Editar";
        editarBtn.style.marginLeft = "10px";
        editarBtn.addEventListener("click", function () {
            openDesplegableEditor(element);
        });
        listItem.appendChild(editarBtn);
    }
/*
    // Bot√≥n editar para tablas
    if (element.type === "Tabla") {
        const editButton = document.createElement("button");
        editButton.textContent = "Editar";
        editButton.style.marginLeft = "10px";
        editButton.addEventListener("click", function () {
            openTableEditor(element);
        });
        listItem.appendChild(editButton);
    }

    if (element.type === "Texto o html (no editable)") {
        const editButton = document.createElement("button");
        editButton.textContent = "Editar";
        editButton.style.marginLeft = "10px";
        editButton.addEventListener("click", function () {
          openHtmlEditDialog(element.name);;
        });
        listItem.appendChild(editButton);
      }
*/

    // üî• Solo mostrar desplegable de apartados si corresponde
    if (mostrarApartados) {
        const apartadosValidos = obtenerApartadosConRutaCompleta();

        console.log("apartados v√°lidos:", apartadosValidos);

        const selectApartado = document.createElement("select");
        selectApartado.style.marginLeft = "10px";
        selectApartado.style.fontFamily = "Arial";

        // üëâ Opci√≥n por defecto
        const opcionDefault = document.createElement("option");
        opcionDefault.value = "(Seleccionar apartado)";
        opcionDefault.textContent = "(Seleccionar apartado)";
        selectApartado.appendChild(opcionDefault);

        // üëâ Resto de apartados v√°lidos
        apartadosValidos.forEach(function (linea) {
            const option = document.createElement("option");
            option.value = interpretarApartado(linea);
            option.textContent = interpretarApartado(linea);
            selectApartado.appendChild(option);
        });


        // üî• Asignar el valor actual
        selectApartado.value = element.apartado || "(Seleccionar apartado)";

        // üî• Marcar borde rojo si el apartado actual no existe
        if (!apartadosValidos.includes(element.apartado)) {
            selectApartado.style.border = "2px solid red";
        } else {
            selectApartado.style.border = "";
        }

        selectApartado.addEventListener("change", function () {
            element.apartado = selectApartado.value;
            selectApartado.style.border = "";

            updateInfoList();
        });

        listItem.appendChild(selectApartado);
    }

    infoList.appendChild(listItem);
}


function openHtmlEditDialog(elementName) {
  // Fondo semitransparente para bloquear clics
  const overlay = document.createElement("div");
  overlay.style.position = "fixed";
  overlay.style.top = "0";
  overlay.style.left = "0";
  overlay.style.width = "100%";
  overlay.style.height = "100%";
  overlay.style.backgroundColor = "rgba(0, 0, 0, 0.3)";
  overlay.style.zIndex = "100001";

  const dialog = document.createElement("div");
  dialog.className = "modal";
  dialog.style.position = "fixed";
  dialog.style.left = "50%";
  dialog.style.top = "50%";
  dialog.style.transform = "translate(-50%, -50%)";
  dialog.style.backgroundColor = "#fff";
  dialog.style.border = "1px solid #ccc";
  dialog.style.padding = "20px";
  dialog.style.zIndex = "100002"; // mayor que overlay y dialogDiv
  dialog.style.maxWidth = "700px";
  dialog.style.width = "90%";
  dialog.style.maxHeight = "80vh";
  dialog.style.overflow = "auto";
  dialog.style.boxShadow = "0 4px 10px rgba(0,0,0,0.3)";
  dialog.style.borderRadius = "8px";

  const title = document.createElement("h3");
  title.textContent = `Editar contenido de "${elementName}"`;
  dialog.appendChild(title);

  const textarea = document.createElement("textarea");
  textarea.style.width = "100%";
  textarea.style.height = "300px";
  textarea.value = tempElementTextos[elementName] || "";
  dialog.appendChild(textarea);

  const buttons = document.createElement("div");
  buttons.style.marginTop = "15px";
  buttons.style.textAlign = "right";

  const acceptButton = document.createElement("button");
  acceptButton.textContent = "Aceptar";
  acceptButton.onclick = () => {
    tempElementTextos[elementName] = textarea.value;
    document.body.removeChild(dialog);
    document.body.removeChild(overlay);
    //renderShowStepDialog(); // actualizar vista
  };
  buttons.appendChild(acceptButton);

  const cancelButton = document.createElement("button");
  cancelButton.textContent = "Cancelar";
  cancelButton.style.marginLeft = "10px";
  cancelButton.onclick = () => {
    document.body.removeChild(dialog);
    document.body.removeChild(overlay);
  };
  buttons.appendChild(cancelButton);

  dialog.appendChild(buttons);
  document.body.appendChild(overlay);
  document.body.appendChild(dialog);
}






function openDesplegableEditor(element) {
    const dialog = document.createElement("div");
    dialog.style.position = "fixed";
    dialog.style.left = "50%";
    dialog.style.top = "50%";
    dialog.style.transform = "translate(-50%, -50%)";
    dialog.style.background = "#fff";
    dialog.style.border = "1px solid #ccc";
    dialog.style.padding = "20px";
    dialog.style.zIndex = "1000";
    dialog.style.borderRadius = "8px";
    dialog.style.fontFamily = "Arial";
    dialog.style.width = "400px";

    const title = document.createElement("h3");
    title.textContent = "Editar opciones del desplegable";
    dialog.appendChild(title);

    const instruction = document.createElement("p");
    instruction.textContent = "Introduce una opci√≥n por l√≠nea. Puedes pegar una lista desde otro sitio.";
    instruction.style.fontSize = "14px";
    dialog.appendChild(instruction);

    const textarea = document.createElement("textarea");
    textarea.style.width = "100%";
    textarea.style.height = "200px";
    textarea.value = (element.opciones || []).join("\n");
    dialog.appendChild(textarea);

    dialog.appendChild(document.createElement("br"));
    dialog.appendChild(document.createElement("br"));

    const saveBtn = document.createElement("button");
    saveBtn.textContent = "Guardar";
    saveBtn.style.marginRight = "10px";
    saveBtn.onclick = () => {
        const values = textarea.value
            .split("\n")
            .map(line => line.trim())
            .filter(line => line !== "");
        element.opciones = values;
        document.body.removeChild(dialog);
    };
    dialog.appendChild(saveBtn);

    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = "Cancelar";
    cancelBtn.onclick = () => document.body.removeChild(dialog);
    dialog.appendChild(cancelBtn);

    document.body.appendChild(dialog);
}



function openTableEditor(element) {
  // Crear modal
  var overlay = document.createElement("div");
  overlay.style.position = "fixed";
  overlay.style.top = "0";
  overlay.style.left = "0";
  overlay.style.width = "100%";
  overlay.style.height = "100%";
  overlay.style.backgroundColor = "rgba(0, 0, 0, 0.4)";
  overlay.style.zIndex = "9999";

  var modal = document.createElement("div");
  modal.style.background = "white";
  modal.style.padding = "20px";
  modal.style.borderRadius = "8px";
  modal.style.width = "600px";
  modal.style.maxHeight = "80vh";
  modal.style.overflowY = "auto";
  modal.style.position = "absolute";
  modal.style.top = "50%";
  modal.style.left = "50%";
  modal.style.transform = "translate(-50%, -50%)";
  overlay.appendChild(modal);

  // T√≠tulo
  var title = document.createElement("h3");
  title.textContent = `Editor de tabla - ${element.name}`;
  title.style.marginBottom = "10px";
  title.style.fontFamily = "Arial";
  modal.appendChild(title);
  console.log("Editor de tabla de openTableEditor");
  console.log(JSON.stringify(flowchartData));

  // √Årea para las filas
  var rowsLabel = document.createElement("label");
  rowsLabel.textContent = "Contenido de la tabla (una fila por l√≠nea, separa columnas por '|||'):";
  rowsLabel.style.fontFamily = "Arial";
  modal.appendChild(rowsLabel);
  modal.appendChild(document.createElement("br"));
  modal.appendChild(document.createElement("br"));

  var rowsTextarea = document.createElement("textarea");
  rowsTextarea.style.width = "100%";
  rowsTextarea.style.height = "150px";
  if (element.tabla && Array.isArray(element.tabla.rows)) {
    rowsTextarea.value = element.tabla.rows.map(row => row.join("\t")).join("\n");
  } else {
    rowsTextarea.value = ""; // vaciar si no hay tabla previa
  }

  modal.appendChild(rowsTextarea);
  modal.appendChild(document.createElement("br"));
  modal.appendChild(document.createElement("br"));

  var previewTable = document.createElement("table");
  previewTable.style.marginTop = "10px";
  previewTable.style.width = "100%";
  previewTable.style.borderCollapse = "collapse";
  previewTable.style.fontFamily = "Arial";
  previewTable.innerHTML = "";

  // Detectar si se pega una tabla de Excel/Word en la tabla de vista previa
  previewTable.addEventListener("paste", function (e) {
   
    e.preventDefault();

    var pastedText = (e.clipboardData || window.clipboardData).getData("text");

    if (!pastedText.includes("\t")) {
      alert("No se detecta contenido tabulado. ¬øHas copiado una tabla de Excel o Word?");
      return;
    }

    var lines = pastedText.trim().split("\n");

    if (lines.length < 1) {
      alert("La tabla est√° vac√≠a.");
      return;
    }

    var rawRows = lines.map(line => line.split("\t").map(cell => cell.trim()));


    rowsTextarea.value = rawRows.map(row => row.join("|||")).join("\n");


    renderPreviewTable();

    //pasteZone.textContent = "¬°Tabla pegada! Puedes editarla arriba.";
  });


  function renderPreviewTable() {
    previewTable.innerHTML = "";

    const rows = rowsTextarea.value
      .split("\n")
      .map(line => line.split("|||").map(cell => cell.trim()))
      .filter(row => row.length > 0);

    const maxCols = Math.max(...rows.map(r => r.length));

    const tbody = document.createElement("tbody");
    rows.forEach(row => {
      const tr = document.createElement("tr");
      const completeRow = [...row];

      // Rellenar columnas vac√≠as
      while (completeRow.length < maxCols) {
        completeRow.push("");
      }

      completeRow.forEach(cell => {
        const td = document.createElement("td");
        td.textContent = cell;
        td.style.border = "1px solid #ccc";
        td.style.padding = "5px";

        // Fondo gris para celdas con contenido
        if (cell.trim() !== "") {
          td.style.backgroundColor = "#f0f0f0";
        }

        tr.appendChild(td);
      });

      tbody.appendChild(tr);
    });

    previewTable.appendChild(tbody);
  }

  


  renderPreviewTable();

  rowsTextarea.addEventListener("input", renderPreviewTable);

  // Llamar una vez para mostrar la tabla inicial
  //renderPreviewTable();


  // Contenedor para previsualizaci√≥n
  var previewLabel = document.createElement("label");
  previewLabel.textContent = "Vista previa de la tabla (puedes pegar aqu√≠ una tabla de Word o Excel):";
  previewLabel.style.fontFamily = "Arial";
  modal.appendChild(previewLabel);
  modal.appendChild(previewTable);





  modal.appendChild(document.createElement("br"));


  var buttonContainer = document.createElement("div");
  buttonContainer.style.textAlign = "right"; // üëà Alineaci√≥n a la derecha
  modal.appendChild(buttonContainer);

  // Bot√≥n guardar
  var saveBtn = document.createElement("button");
  saveBtn.textContent = "Guardar tabla";
  saveBtn.addEventListener("click", function () {
    element.tabla.rows = rowsTextarea.value
      .split("\n")
      .map(line => line.split("\t").map(cell => cell.trim()))
      .filter(row => row.length > 0);

   //   if (element.tabla.headers.length === 0 && element.tabla.rows.length > 0) {
   //     element.tabla.rows = element.tabla.rows.slice(1); // Elimina la fila de encabezados de las filas normales
   //   }

    document.body.removeChild(overlay);
  });
  buttonContainer.appendChild(saveBtn);




  // Bot√≥n cancelar
  var cancelBtn = document.createElement("button");
  cancelBtn.textContent = "Cancelar";
  cancelBtn.style.marginLeft = "10px";
  cancelBtn.addEventListener("click", function () {
    document.body.removeChild(overlay);
  });
  buttonContainer.appendChild(cancelBtn);

  document.body.appendChild(overlay);
}
// Cargar elementos de informaci√≥n existentes al abrir el cuadro de di√°logo
if (!isNew) {
    var selectedStepData = flowchartData.steps.find(function (step) {
        return step.id === stepId;
    });

    if (selectedStepData && Array.isArray(selectedStepData.infoElements)) {
      infoElements = JSON.parse(JSON.stringify(selectedStepData.infoElements || []));      // Cargar elementos de informaci√≥n

        // ‚ö†Ô∏è Copiar los valores del campo 'valor' al buffer temporal
        updateInfoList(); // Actualizar la lista visual
    }
}

      contentContainer.appendChild(document.createElement("br"));
      contentContainer.appendChild(document.createElement("br"));
} //Fin de if(tipo==='step')
      contentContainer.appendChild(document.createElement("br"));




      // Crear un bot√≥n de aceptar para guardar los valores
      var btnAceptar = document.createElement("button");
      btnAceptar.textContent = "Aceptar";
      btnAceptar.style.position = "absolute";
      btnAceptar.style.bottom = "10px";
      btnAceptar.style.right = "90px"; // Mover a la esquina inferior derecha
      btnAceptar.addEventListener("click", function () {
          // Obtener los valores de los campos
          var nombre = document.getElementById("nombre").value;

          var estructuraTexto;
          var estructuraApartados;
          var estructuraVacia;
          if (tipo === "step") {
              var gestionarValue = gestionarSelect.value;
              var conectarValue = conectarSelect.value;
              var instrucciones = document.getElementById("instrucciones").value;

              estructuraTexto = structureTextarea.value.trim();
              estructuraApartados = normalizarStructureTextareaValue(structureTextarea.value).trim();
              estructuraVacia = estructuraTexto === "";

              const apartadosValidos = estructuraVacia ? [] : obtenerApartadosConRutaCompleta();

              let hayErrores = false;

              if (!estructuraVacia) {
                  infoElements.forEach(e => {
                      if (!e.apartado ||
                          e.apartado === "(Seleccionar apartado)" ||
                          !apartadosValidos.includes(e.apartado)) {
                          hayErrores = true;
                      }
                  });
              }

              if (hayErrores) {
                  alert("Hay elementos sin apartado asignado o con apartado no v√°lido. Por favor, corr√≠gelos antes de continuar.");
                  return;
              }
            }

          if (isNew) {
              var canvas = document.getElementById('flowchartCanvas');
              var ctx = canvas.getContext('2d');
              var anchoCanvas = canvas.width;
              var altoCanvas = canvas.height;
              var scrollY = window.scrollY;
              var scrollX = window.scrollX;
              var anchoTarea = 100;
              var altoTarea = 50;
              var altoEncabezado = 350;
              var x = scrollX + 2*(anchoTarea + 100);
             // var y = altoCanvas - altoTarea + scrollY - altoEncabezado;
             var y = scrollY + altoTarea + 100;
              var notas = "";
              var fechaFin = "";

              if (x < 100) x = 100;
              if (x > (anchoCanvas - 100)) x = anchoCanvas - 100;
              if (y < 100) y = 100;
              if (y > (altoCanvas - 100)) y = altoCanvas - 100;

              var nuevoStepId = generarNuevoStepId();
              var nuevostep={};
              if (tipo === "step") {
                    nuevoStep = {
                        id: nuevoStepId,
                        label: nombre,
                        x: x,
                        y: y,
                        instrucciones: instrucciones,
                        infoElements: infoElements,
                        estructuraApartados: estructuraApartados,
                        receivedElements: receivedElements 
                    };
                }

              if (tipo === "milestone") {
                 nuevoStep = {
                      id: nuevoStepId,
                      label: nombre,
                      x: x,
                      y: y,
                  };
              }

              if (tipo === "step") {
                  var rol = rolSelect.value === "Otro" ? document.getElementById("otroRol").value : rolSelect.value;
                  nuevoStep.tipo = "step";
                  nuevoStep.rol = rol;
                  nuevoStep.Duracion = duracionInput.value;
                  nuevoStep.unidadduracion = unidadDuracionSelect.value;
                  if (!modoProcesosGenerales) {
                      if (notas.length > 0) nuevoStep.notas = notas;
                      if (esFechaValida(fechaFin.value)) {
                          nuevoStep.fechafin = fechaFin.value;
                      } else {
                          delete nuevoStep.fechafin;
                      }
                  }

                  if (gestionarValue === "SI") {
                      nuevoStep.is_a_multiple_task = "true";
                      if (conectarValue !== "NO") {
                          nuevoStep.multiple_task_following_previous = conectarValue;
                      }
                  }
              }

              if (tipo === "milestone") {
                  nuevoStep.tipo = "milestone";
              }

              flowchartData.steps.push(nuevoStep);
              selectedStep = [nuevoStepId];
              stepSelected = true;
              stepCanMove = true;
              expiredTime = true;

              
                // Recuperar referencia para que no sea undefined m√°s abajo
                selectedStepData = flowchartData.steps.find(s => s.id === nuevoStepId);

          } else {
              var selectedStepData = flowchartData.steps.find(function (step) {
                  return step.id === selectedStep[0];
              });

              if (selectedStepData) {
                  if (tipo === "step") {
                      var rol = rolSelect.value === "Otro" ? document.getElementById("otroRol").value : rolSelect.value;
                      selectedStepData.label = nombre;
                      selectedStepData.rol = rol;
                      selectedStepData.Duracion = duracionInput.value;
                      selectedStepData.instrucciones = instrucciones;
                      selectedStepData.unidadduracion = unidadDuracionSelect.value;
                      infoElements.forEach(e => {
                          if (!e.apartado || estructuraVacia) {
                              delete e.apartado;
                          }
                      });
                      console.log("üîç infoElements antes de guardar:", JSON.stringify(infoElements, null, 2));

                      selectedStepData.infoElements = infoElements;
                      selectedStepData.estructuraApartados = estructuraApartados;

                      if (gestionarValue === "SI") {
                          selectedStepData.is_a_multiple_task = "true";
                          if (conectarValue !== "NO") {
                              selectedStepData.multiple_task_following_previous = conectarValue;
                          } else {
                              delete selectedStepData.multiple_task_following_previous;
                          }
                      } else {
                          delete selectedStepData.is_a_multiple_task;
                          delete selectedStepData.multiple_task_following_previous;
                      }
                  }

                  if (tipo === "milestone") {
                      selectedStepData.label = nombre;
                      selectedStepData.instrucciones = instrucciones;
                  }
              }
          }

          if (tipo === "step") {
            selectedStepData.receivedElements = receivedElements;
        }




          document.body.removeChild(dialogDiv);
          drawFlowchart();
      });



  //   dialogDiv.appendChild(btnAceptar);

      var btnCancelar = document.createElement("button");
  btnCancelar.textContent = "Cancelar";
  btnCancelar.style.position = "absolute";
  btnCancelar.style.bottom = "10px";
  btnCancelar.style.right = "10px"; // Mover a la esquina inferior derecha

  // Manejador de eventos para el bot√≥n "Cancelar"
  btnCancelar.addEventListener("click", function () {
      // Cerrar el cuadro de di√°logo sin guardar los datos
      document.body.removeChild(dialogDiv);
  });

  // Crear botones de pie fijos
  var buttonsContainer = document.createElement("div");
  buttonsContainer.style.display = "flex";
  buttonsContainer.style.justifyContent = "flex-end";
  buttonsContainer.style.gap = "10px";
  buttonsContainer.style.borderTop = "1px solid #ccc";
  buttonsContainer.style.paddingTop = "10px";
  buttonsContainer.style.marginTop = "10px";

  // Estilo limpio para los botones
  btnAceptar.style.position = "static";
  btnAceptar.style.margin = "0";

  btnCancelar.style.position = "static";
  btnCancelar.style.margin = "0";

  // A√±adir botones al contenedor y al cuadro principal
  buttonsContainer.appendChild(btnCancelar);
  buttonsContainer.appendChild(btnAceptar);
  dialogDiv.appendChild(buttonsContainer);


}


function openElementEditor(element) {
  const overlay = document.createElement("div");
  overlay.style.position = "fixed";
  overlay.style.top = "0";
  overlay.style.left = "0";
  overlay.style.width = "100%";
  overlay.style.height = "100%";
  overlay.style.backgroundColor = "rgba(0, 0, 0, 0.3)";
  overlay.style.zIndex = "100001";

  const dialog = document.createElement("div");
  dialog.style.position = "fixed";
  dialog.style.left = "50%";
  dialog.style.top = "50%";
  dialog.style.transform = "translate(-50%, -50%)";
  dialog.style.background = "#fff";
  dialog.style.border = "1px solid #ccc";
  dialog.style.padding = "20px";
  dialog.style.zIndex = "100002";
  dialog.style.borderRadius = "8px";
  dialog.style.width = "500px";
  dialog.style.maxHeight = "80vh";
  dialog.style.overflowY = "auto";
  dialog.style.fontFamily = "Arial";

  const title = document.createElement("h3");
  title.textContent = `Editar "${element.name}"`;
  dialog.appendChild(title);


  const obligatorioCheckbox = document.createElement("input");
  if (element.type !== "Texto o html (no editable)") {
    const obligatorioLabel = document.createElement("label");
    obligatorioLabel.textContent = "¬øObligatorio?";
    obligatorioCheckbox.type = "checkbox";
    obligatorioCheckbox.checked = element.obligatorio !== false; // default true
    dialog.appendChild(obligatorioCheckbox);
    dialog.appendChild(obligatorioLabel);
    dialog.appendChild(document.createElement("br"));
    dialog.appendChild(document.createElement("br"));
  }


  const infoLabel = document.createElement("label");
  if (element.type === "Texto o html (no editable)") {
    infoLabel.textContent = "Texto o html:";
  }else{
    infoLabel.textContent = "Texto informativo (se mostrar√° junto al campo, puede ser html):";
    }
  dialog.appendChild(infoLabel);

  const infoTextarea = document.createElement("textarea");
  infoTextarea.style.width = "100%";
  infoTextarea.style.height = "150px";
  infoTextarea.value = element.informacion || "";
  dialog.appendChild(infoTextarea);
  dialog.appendChild(document.createElement("br"));
  dialog.appendChild(document.createElement("br"));


  if (element.type === "Desplegable selecci√≥n √∫nica" || element.type === "Desplegable selecci√≥n m√∫ltiple") {
    const opLabel = document.createElement("label");
    opLabel.textContent = "Opciones (una por l√≠nea):";
    dialog.appendChild(opLabel);
    const opTextarea = document.createElement("textarea");
    opTextarea.style.width = "100%";
    opTextarea.style.height = "150px";
    opTextarea.value = (element.opciones || []).join("\n");
    dialog.appendChild(opTextarea);
    dialog._opcionesTextarea = opTextarea;
  }

  if (element.type === "Tabla") {
  const tablaLabel = document.createElement("label");
  tablaLabel.textContent = "Estructura de tabla (una fila por l√≠nea, columnas separadas por '|||'):";
  dialog.appendChild(tablaLabel);

  const tablaTextarea = document.createElement("textarea");
  tablaTextarea.style.width = "100%";
  tablaTextarea.style.height = "150px";
  tablaTextarea.value = element.tabla?.rows?.map(r => r.join("|||")).join("\n") || "";
  dialog.appendChild(tablaTextarea);

  const tablaPreview = document.createElement("table");
  tablaPreview.style.marginTop = "10px";
  tablaPreview.style.width = "100%";
  tablaPreview.style.borderCollapse = "collapse";
  tablaPreview.style.fontFamily = "Arial";
  tablaPreview.style.border = "1px solid #ccc";
  dialog.appendChild(tablaPreview);

  function renderPreviewTableFromTextarea() {
    tablaPreview.innerHTML = "";
    const rows = tablaTextarea.value
      .split("\n")
      .map(line => line.split("|||").map(cell => cell.trim()))
      .filter(row => row.length > 0);

    const maxCols = Math.max(...rows.map(r => r.length), 1);

    rows.forEach(row => {
      const tr = document.createElement("tr");
      for (let i = 0; i < maxCols; i++) {
        const td = document.createElement("td");
        td.textContent = row[i] || "";
        td.style.border = "1px solid #ccc";
        td.style.padding = "4px";
        if ((row[i] || "").trim() !== "") {
          td.style.backgroundColor = "#f0f0f0";
        }
        tr.appendChild(td);
      }
      tablaPreview.appendChild(tr);
    });
  }

  tablaTextarea.addEventListener("input", renderPreviewTableFromTextarea);
  renderPreviewTableFromTextarea(); // Mostrar al cargar

  dialog._tablaTextarea = tablaTextarea;
}


  const btns = document.createElement("div");
  btns.style.textAlign = "right";
  btns.style.marginTop = "10px";

  const btnGuardar = document.createElement("button");
  btnGuardar.textContent = "Aceptar";
  btnGuardar.onclick = () => {
  if (element.type !== "Texto o html (no editable)") {
    if (!obligatorioCheckbox.checked) {
      element.optional = true; // Guardar solo si se desmarca
    } else {
      delete element.optional; // No guardar si est√° marcado
    }
  } else {
    element.optional = true; // No editables siempre opcionales
  }

  element.informacion = infoTextarea.value;



    if (dialog._opcionesTextarea) {
      element.opciones = dialog._opcionesTextarea.value
        .split("\n")
        .map(l => l.trim())
        .filter(l => l.length > 0);
    }

    if (dialog._tablaTextarea) {
      element.tabla = {
        rows: dialog._tablaTextarea.value
          .split("\n")
          .map(r => r.split("|||").map(c => c.trim()))
          .filter(r => r.length > 0)
      };
    }

    document.body.removeChild(dialog);
    document.body.removeChild(overlay);
  };

  const btnCancelar = document.createElement("button");
  btnCancelar.textContent = "Cancelar";
  btnCancelar.style.marginLeft = "10px";
  btnCancelar.onclick = () => {
    document.body.removeChild(dialog);
    document.body.removeChild(overlay);
  };

  btns.appendChild(btnGuardar);
  btns.appendChild(btnCancelar);
  dialog.appendChild(btns);
  document.body.appendChild(overlay);
  document.body.appendChild(dialog);
}

function showPathDialog(isNew, startStepId = "", endStepId = "", id = "", tipo="", condicion="", maxmin = "", duracion = "", unidadduracion = "", tipoduracion = "") {
// Crear un div para el cuadro de di√°logo
var dialogDiv = document.createElement("div");
dialogDiv.style.display = "block";
dialogDiv.style.position = "fixed"; // Cambiar de "absolute" a "fixed"
dialogDiv.style.backgroundColor = "white";
dialogDiv.style.padding = "20px";
dialogDiv.style.border = "1px solid #ccc";
dialogDiv.style.borderRadius = "5px";
dialogDiv.style.left = "50%";
dialogDiv.style.top = "50%";
dialogDiv.style.transform = "translate(-50%, -50%)";
document.body.appendChild(dialogDiv);


    // Mostrar el campo de "nombre" en una l√≠nea nueva
    if (tipo === "path") {
    var condicionLabel = document.createElement("label");
    condicionLabel.for = "condicion";
    condicionLabel.textContent = "Condici√≥n (dejar vac√≠o si no hay): ";
    condicionLabel.style.fontFamily = "Arial";
    condicionLabel.style.fontSize = "14px";
    dialogDiv.appendChild(condicionLabel);

    var condicionInput = document.createElement("input");
    condicionInput.type = "text";
    condicionInput.id = "nombre";
    condicionInput.value = condicion || "";
    condicionInput.style.fontFamily = "Arial";
    dialogDiv.appendChild(condicionInput);

        // Agregar un retorno de carro
        dialogDiv.appendChild(document.createElement("br"));
    dialogDiv.appendChild(document.createElement("br"));
    }
    // Mostrar el campo de "duraci√≥n" en una l√≠nea nueva
    if (tipo === "ligtime") {
    // Crear un label para el tipo de limitaci√≥n
    var maxminLabel = document.createElement("label");
    maxminLabel.for = "maxmin";
    maxminLabel.textContent = "Tipo de limitaci√≥n: ";
    maxminLabel.style.fontFamily = "Arial";
    maxminLabel.style.fontSize = "14px";
    dialogDiv.appendChild(maxminLabel);

    // Crear un desplegable (select) para elegir entre "M√°ximo" y "M√≠nimo"
    var maxminSelect = document.createElement("select");
    maxminSelect.id = "maxmin";
    maxminSelect.style.fontFamily = "Arial";
    dialogDiv.appendChild(maxminSelect);

    // Crear las opciones para el desplegable "maxmin"
    var maxminOpcionMaximo = document.createElement("option");
    maxminOpcionMaximo.value = "MX";
    maxminOpcionMaximo.text = "M√°ximo";
    maxminSelect.appendChild(maxminOpcionMaximo);

    var maxminOpcionMinimo = document.createElement("option");
    maxminOpcionMinimo.value = "MN";
    maxminOpcionMinimo.text = "M√≠nimo";
    maxminSelect.appendChild(maxminOpcionMinimo);

    maxminSelect.value=maxmin || "MX";

    // Agregar un retorno de carro
    dialogDiv.appendChild(document.createElement("br"));
    dialogDiv.appendChild(document.createElement("br"));

    // Crear un label para la duraci√≥n
    var duracionLabel = document.createElement("label");
    duracionLabel.for = "duracion";
    duracionLabel.textContent = "Duraci√≥n: ";
    duracionLabel.style.fontFamily = "Arial";
    duracionLabel.style.fontSize = "14px";
    dialogDiv.appendChild(duracionLabel);

    // Crear un campo de entrada de tipo n√∫mero para la duraci√≥n
    var duracionInput = document.createElement("input");
    duracionInput.type = "number";
    duracionInput.id = "duracion";
    duracionInput.value = duracion || "";
    duracionInput.style.fontFamily = "Arial";
    duracionInput.setAttribute("maxlength", "5"); // Establecer la longitud m√°xima en 5 caracteres
    duracionInput.style.width = "50px"; // Establecer el ancho deseado en p√≠xeles
    dialogDiv.appendChild(duracionInput);




    // Crear un desplegable (select) para elegir entre "d√≠as", "meses" y "a√±os"
    var unidadDuracionSelect = document.createElement("select");
    unidadDuracionSelect.id = "unidadDuracion";
    unidadDuracionSelect.style.fontFamily = "Arial";
    dialogDiv.appendChild(unidadDuracionSelect);

    // Crear las opciones para el desplegable "Unidad de duraci√≥n"
    var unidadDuracionOpcionDias = document.createElement("option");
    unidadDuracionOpcionDias.value = "n";
    unidadDuracionOpcionDias.text = "D√≠as naturales";
    unidadDuracionSelect.appendChild(unidadDuracionOpcionDias);

    var unidadDuracionOpcionDias = document.createElement("option");
    unidadDuracionOpcionDias.value = "h";
    unidadDuracionOpcionDias.text = "D√≠as h√°biles";
    unidadDuracionSelect.appendChild(unidadDuracionOpcionDias);

    var unidadDuracionOpcionDias = document.createElement("option");
    unidadDuracionOpcionDias.value = "l";
    unidadDuracionOpcionDias.text = "D√≠as laborables";
    unidadDuracionSelect.appendChild(unidadDuracionOpcionDias);

    var unidadDuracionOpcionMeses = document.createElement("option");
    unidadDuracionOpcionMeses.value = "m";
    unidadDuracionOpcionMeses.text = "Meses";
    unidadDuracionSelect.appendChild(unidadDuracionOpcionMeses);

    var unidadDuracionOpcionAnos = document.createElement("option");
    unidadDuracionOpcionAnos.value = "a";
    unidadDuracionOpcionAnos.text = "A√±os";
    unidadDuracionSelect.appendChild(unidadDuracionOpcionAnos);

    unidadDuracionSelect.value = unidadduracion || "n";

        // Agregar un retorno de carro
        dialogDiv.appendChild(document.createElement("br"));
    dialogDiv.appendChild(document.createElement("br"));

            // Crear un label para el inicio o fin
            var tipoDuracionLabel = document.createElement("label");
        tipoDuracionLabel.for = "tipoDuracion";
        tipoDuracionLabel.textContent = "Desde/hasta el inicio o fin de la tarea (1¬™-2¬™): ";
        tipoDuracionLabel.style.fontFamily = "Arial";
        tipoDuracionLabel.style.fontSize = "14px";
    dialogDiv.appendChild(tipoDuracionLabel);

    // Crear un desplegable (select) para elegir tipo de duraci√≥n
    var tipoDuracionSelect = document.createElement("select");
    tipoDuracionSelect.id = "tipoDuracion";
    tipoDuracionSelect.style.fontFamily = "Arial";
    dialogDiv.appendChild(tipoDuracionSelect);


    // Crear las opciones para el desplegable de inicio o fin
    var tipoDuracionOpcionFF = document.createElement("option");
    tipoDuracionOpcionFF.value = "FF";
    tipoDuracionOpcionFF.text = "Fin-Fin";
    tipoDuracionSelect.appendChild(tipoDuracionOpcionFF);

    var tipoDuracionOpcionII = document.createElement("option");
    tipoDuracionOpcionII.value = "II";
    tipoDuracionOpcionII.text = "Inicio-Inicio";
    tipoDuracionSelect.appendChild(tipoDuracionOpcionII);

    var tipoDuracionOpcionFI = document.createElement("option");
    tipoDuracionOpcionFI.value = "FI";
    tipoDuracionOpcionFI.text = "Fin-Inicio";
    tipoDuracionSelect.appendChild(tipoDuracionOpcionFI);

    var tipoDuracionOpcionIF = document.createElement("option");
    tipoDuracionOpcionIF.value = "IF";
    tipoDuracionOpcionIF.text = "Inicio-Fin";
    tipoDuracionSelect.appendChild(tipoDuracionOpcionIF);

    tipoDuracionSelect.value = tipoduracion || "FF";


    // Agregar un retorno de carro
    dialogDiv.appendChild(document.createElement("br"));
    dialogDiv.appendChild(document.createElement("br"));
    dialogDiv.appendChild(document.createElement("br"));
}


    // Crear un bot√≥n de aceptar para guardar los valores
    var btnAceptar = document.createElement("button");
    btnAceptar.textContent = "Aceptar";
    btnAceptar.style.position = "absolute";
    btnAceptar.style.bottom = "10px";
    btnAceptar.style.right = "10px"; // Mover a la esquina inferior derechagenerarNuevoPathId
    btnAceptar.addEventListener("click", function () {
        // Obtener los valores de los campos
        var nuevaCondicion = condicion;
        if (tipo === "path") {
          nuevaCondicion =condicionInput.value;
        }
        
        var nuevaDuracion = duracion;
        if (tipo === "ligtime") {
          nuevaDuracion=duracionInput.value;
        }


        // Dependiendo de si es una operaci√≥n nueva o de edici√≥n, realiza la acci√≥n correspondiente
        if (isNew) {
            // Realiza la acci√≥n para una operaci√≥n nueva
            var nuevoPathId = generarNuevoPathId('path'); // Generar un ID √∫nico para el nuevo path

            var nuevoPath = {
                id: nuevoPathId,
                startStep: startStepId,
                endStep: endStepId,
            };

            if (tipo === "path") {
              nuevoPath.condicion=nuevaCondicion;
              nuevoPath.type="path";
            }
            if (tipo === "ligtime") {
              nuevoPath.type="ligtime";
              nuevoPath.duracion=nuevaDuracion;
              nuevoPath.unidadduracion=unidadDuracionSelect.value;
              nuevoPath.tipoduracion=tipoDuracionSelect.value;
              nuevoPath.maxmin=maxminSelect.value;
            }

            if (flowchartData.hasOwnProperty('paths')) {
                flowchartData.paths.push(nuevoPath);
            } else {
                flowchartData.paths = [nuevoPath];
            }

            // ... (resto del c√≥digo de manejo de paths nuevos)
        } else {


            // Realiza la acci√≥n para la edici√≥n de una operaci√≥n existente
            var selectedPathData = flowchartData.paths.find(function (path) {
                return path.id === selectedPath;
            });
            

            if (selectedPathData) {
              if ((tipo === "path")&&(nuevaCondicion !== "")) {
                selectedPathData.condicion = nuevaCondicion; // Actualiza la condici√≥n
              }
              if ((tipo === "ligtime")&&(nuevaDuracion !== "")) {
                selectedPathData.duracion = nuevaDuracion; // Actualiza la duraci√≥n
                selectedPathData.unidadduracion = unidadDuracionSelect.value;
                selectedPathData.tipoduracion=tipoDuracionSelect.value;
                selectedPathData.maxmin=maxminSelect.value;
              }
            }
        }

        // Cerrar el cuadro de di√°logo
        document.body.removeChild(dialogDiv);
        guardarEstado();
        drawFlowchart();
    });
    dialogDiv.appendChild(btnAceptar);
}












        function generarNuevoStepId() {
          var nuevoId = "step1"; // Valor inicial para el nuevo ID
          if (flowchartData.hasOwnProperty('steps')) {
            var steps = flowchartData.steps;
            // Buscar el siguiente n√∫mero disponible para el ID
            for (var i = 0; i < steps.length; i++) {
              var stepId = steps[i].id;
              var stepNumber = parseInt(stepId.substring(4));

                if (!isNaN(stepNumber) && stepNumber >= parseInt(nuevoId.substring(4))) {
                 nuevoId = "step" + (stepNumber + 1);
                }
            }
          }else{
            nuevoId="step1";
          }
        return nuevoId;
        }

        function createPath(pathtype){
          if (flowchartData.hasOwnProperty('steps')) {
            document.getElementById("deleteStepOrPathButton").style.backgroundColor="#4c77af";
            numClicksAfterCreatePathButton=0;
            createPathOn=true;
            if(pathtype=='path') {
              document.getElementById("createPathButton").style.backgroundColor="#839192";
              document.getElementById("createLigtimeButton").style.backgroundColor="#4c77af";
            }
            if(pathtype=='ligtime'){
              createligtimeOn=true;
              document.getElementById("createLigtimeButton").style.backgroundColor="#839192";
              document.getElementById("createPathButton").style.backgroundColor="#4c77af";
            }
            document.getElementById("messages").innerHTML = "Haga click en el primer proceso a relacionar";
          }
        }




        function insertarNuevoPath(startStepId, endStepId, condicion, tipo) {
            eliminarPath(startStepId, endStepId, tipo);

            var nuevoPathId = generarNuevoPathId('path'); // Generar un ID √∫nico para el nuevo path

            var nuevoPath = {};
            var nuevoPath = {
            id: nuevoPathId,
            startStep: startStepId,
            endStep: endStepId,
            condicion: condicion,
            type: tipo
            };


            if (flowchartData.hasOwnProperty('paths')) {
              flowchartData.paths.push(nuevoPath);
            }else{
              flowchartData.paths=[{id: nuevoPathId, startStep: startStepId, endStep: endStepId, condicion: condicion, type: tipo}];
            }
            selectedPath = nuevoPathId;
            selectedStep=null;
            guardarEstado();
            drawFlowchart();
            // Mostrar el array actualizado
        }

        function generarNuevoPathId(prefix) {
          var nuevoId = prefix + '1'; // Valor inicial para el nuevo ID
          if (flowchartData.hasOwnProperty('paths')) {
            var paths = flowchartData.paths;


            // Buscar el siguiente n√∫mero disponible para el ID
            for (var i = 0; i < paths.length; i++) {
                var pathId = paths[i].id;
                var pathNumber = parseInt(pathId.substring(4));

                if (!isNaN(pathNumber) && pathNumber >= parseInt(nuevoId.substring(4))) {
                    nuevoId = prefix + (pathNumber + 1);
                }
            }
          }
         return nuevoId;
        }

        function eliminarPath(startStep, endStep, tipo){
          if (flowchartData.hasOwnProperty('paths')) {
            var paths = flowchartData.paths;
            for (var i = 0; i < paths.length; i++) {
                var path = paths[i];
                if (path.startStep === startStep && path.endStep === endStep && path.type === tipo) {
                paths.splice(i, 1);
                break;
                }
            }
          }
            guardarEstado();
            drawFlowchart();
        }

        //Devolver los botones al estado original
        function finishPathProcess(){
            createPathOn=false;
            document.getElementById("createPathButton").style.backgroundColor="#4c77af";
            document.getElementById("deleteStepOrPathButton").style.backgroundColor="#4c77af";
        }

        function setupFlowChartName(){
            flowchartData.title= document.getElementById("flowChartName").value;
        }



// Definir una variable global para almacenar los datos cargados
var datosCargados = [];



function saveFlowChart() {
  var input = document.createElement('input');
  input.type = 'file';
  input.accept = '.txt';

  input.addEventListener('change', function (event) {
    var archivoCargado = event.target.files[0];

    // Verificar si el nombre del archivo es 'DatosGenerales.txt'
    if ((!modoProcesosGenerales)&&(archivoCargado.name === 'ProcesosGlobales.txt')) {
      showAlertOnCanvas("En modo de seguimiento de proyectos no se puede guardar datos en el archivo de procesos generales. Por favor, elija el archivo de proyectos para guardar sus datos.");
      //alert("En modo de seguimiento de proyectos no se puede guardar datos en el archivo de procesos generales. Por favor, elija el archivo de proyectos para guardar sus datos.");
      return; // No continuar con el procesamiento y salir de la funci√≥n
    }

    // Leer el contenido del archivo cargado
    var lector = new FileReader();
    lector.onload = function (eventoLector) {
      var contenidoCargado = eventoLector.target.result;

      // Procesar el contenido cargado
      datosCargados = JSON.parse(contenidoCargado);

      // Procesar y modificar los datos seg√∫n sea necesario


      var datos = flowchartData;

      if(modoProcesosGenerales){
      // Recorrer todos los steps y eliminar "fechafin" si existe
      datos.steps.forEach(step => {
        if (step.fechafin) {
            delete step.fechafin;
        }
      });

      // Eliminar "importeEstimado", "fechaInicioProyecto" y "asignacionRoles" del objeto principal si existen
      delete datos.importeEstimado;
      delete datos.fechaInicioProyecto;
      delete datos.asignacionRoles;
      delete datos.descripcionProyecto;
      }


      var tituloExistente = false;
      for (var i = 0; i < datosCargados.length; i++) {
        if (datosCargados[i].title === datos.title) {
          datosCargados[i] = datos;
          tituloExistente = true;
          break;
        }
      }

      if (!tituloExistente) {
        datosCargados.push(datos);
      }
      copiarAlPortapapeles(Ruta);
      // Guardar los datos actualizados en el mismo archivo
      guardarArchivoComo(JSON.stringify(datosCargados), archivoCargado.name);
    };

    lector.readAsText(archivoCargado);
  });

  input.style.display = 'none';

  // Agregar el input al DOM y simular un clic en √©l para cargar el archivo
  document.body.appendChild(input);
  input.click();
}

async function guardarArchivoComo(contenido, nombreArchivo) {
  try {
    const blob = new Blob([contenido], { type: 'text/plain;charset=utf-8' });
    const options = {
      types: [
        {
          description: 'Archivos de texto',
          accept: { 'text/plain': ['.txt'] },
        },
      ],
      suggestedName: nombreArchivo,
    };

    const fileHandle = await window.showSaveFilePicker(options);
    // Despu√©s de que el usuario haya elegido el nombre, verifica si es 'DatosGenerales.txt'
    if ((!modoProcesosGenerales)&&(fileHandle.name === 'ProcesosGlobales.txt')) {
      showAlertOnCanvas("En modo de seguimiento de proyectos no se puede guardar datos en el archivo de procesos generales. Por favor, elija el archivo de proyectos para guardar sus datos.");
      return; // Salir de la funci√≥n sin guardar el archivo
    }
    const writable = await fileHandle.createWritable();
    await writable.write(blob);
    await writable.close();
  } catch (error) {
    console.error('Error al guardar el archivo:', error);
    showAlertOnCanvas("ERROR: El archivo NO se ha guardado correctamente. Por favor, vuelva a intentarlo (a veces el problema es el tiempo excesivo en la selecci√≥n de archivos).");
  }
}

function showAlertOnCanvas(message) {
  // Configura el ancho y alto para el mensaje en el canvas
  const width = 600;
  const height = 120;
  const padding = 10;
  const lineHeight = 16; // Altura de l√≠nea para separar el texto
  const borderWidth = 5; // Ancho del borde

  // Dibuja el fondo blanco con borde rojo
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, width, height);
  ctx.strokeStyle = 'red';
  ctx.lineWidth = borderWidth;
  ctx.strokeRect(borderWidth / 2, borderWidth / 2, width - borderWidth, height - borderWidth);

  // Configura el texto
  ctx.font = '12px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = 'black';

  // Divide el texto en l√≠neas
  const words = message.split(' ');
  const lines = [];
  let currentLine = words[0];

  for (let i = 1; i < words.length; i++) {
    const word = words[i];
    const measureWidth = ctx.measureText(currentLine + " " + word).width;
    if (measureWidth < width - padding * 2 - borderWidth) {
      currentLine += " " + word;
    } else {
      lines.push(currentLine);
      currentLine = word;
    }
  }
  lines.push(currentLine); // Agrega la √∫ltima l√≠nea

  // Calcula la posici√≥n inicial del texto para centrarlo verticalmente
  const textHeight = lines.length * lineHeight;
  let y = (height - textHeight) / 2 + lineHeight / 2;

  // Dibuja el texto l√≠nea por l√≠nea
  lines.forEach((line) => {
    ctx.fillText(line, width / 2, y);
    y += lineHeight;
  });

  // Dibuja la aspa
  const crossSize = 10; // Tama√±o de la aspa
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 3;
  // Dibuja la primera l√≠nea de la aspa
  ctx.beginPath();
  ctx.moveTo(width - padding - crossSize * 2, padding);
  ctx.lineTo(width - padding - crossSize, padding + crossSize);
  ctx.stroke();
  // Dibuja la segunda l√≠nea de la aspa
  ctx.beginPath();
  ctx.moveTo(width - padding - crossSize, padding);
  ctx.lineTo(width - padding - crossSize * 2, padding + crossSize);
  ctx.stroke();
}






function copiarAlPortapapeles(texto) {
      const elementoTemporal = document.createElement("textarea");
      elementoTemporal.value = texto;
      document.body.appendChild(elementoTemporal);
      elementoTemporal.select();
      document.execCommand("copy");
      document.body.removeChild(elementoTemporal);
    }

        

//drawFlowchart();


function loadFlowChart() {
  copiarAlPortapapeles(Ruta);
  var input = document.createElement('input');
  input.type = 'file';
  input.accept = '.txt';
  input.placeholder = 'Seleccionar archivo';

  input.addEventListener('change', function(event) {
    var archivoCargado = event.target.files[0];

    var lector = new FileReader();
    lector.onload = function(eventoLector) {
      var contenidoCargado = eventoLector.target.result;

      var datosCargados = JSON.parse(contenidoCargado);
      chooseFlowChart(datosCargados, archivoCargado.name);
    };

    lector.readAsText(archivoCargado);
  });

  input.style.display = 'none';

  document.body.appendChild(input);
  input.click();
}




function chooseFlowChart(datosCargados, archivoSeleccionado) {
  var titleList = [];

  for (var i = 0; i < datosCargados.length; i++) {
    titleList.push(datosCargados[i].title);
  }

  var dialog = document.createElement('dialog');
  dialog.style.display = 'block';

  var titleLabel = document.createElement('div');
  titleLabel.textContent = 'Procesos existentes:';
  titleLabel.style.fontWeight = 'bold';
  dialog.appendChild(titleLabel);
  dialog.appendChild(document.createElement("br"));

  var listContainer = document.createElement('div');
  listContainer.style.maxHeight = '300px';
  listContainer.style.overflowY = 'auto';

  var selectedItem = null;  // Variable para el elemento seleccionado actualmente

  for (var i = 0; i < titleList.length; i++) {
    var listItem = document.createElement('div');
    listItem.textContent = titleList[i];
    listItem.style.padding = '5px';
    listItem.style.cursor = 'pointer';

    listItem.addEventListener('click', function(event) {
      if (selectedItem) {
        selectedItem.classList.remove('selected');  // Desmarcar el elemento previamente seleccionado
      }
      selectedItem = event.currentTarget;
      selectedItem.classList.add('selected');  // Marcar el elemento seleccionado actualmente

      // Cambiar el estilo del elemento seleccionado
      selectedItem.style.color = 'white';
      selectedItem.style.background = 'black';

      // Cambiar el estilo de los elementos no seleccionados
      var allItems = listContainer.children;
      for (var j = 0; j < allItems.length; j++) {
        if (allItems[j] !== selectedItem) {
          allItems[j].style.color = 'black';
          allItems[j].style.background = 'white';
        }
      }
    });

    listContainer.appendChild(listItem);
  }
 

  var loadButton = document.createElement('button');
  loadButton.textContent = 'Cargar';
  loadButton.addEventListener('click', function() {
    loadSelectedItem();
  });
  loadButton.style.float = 'left';
  loadButton.style.marginTop = '10px';
  loadButton.style.marginLeft = '10px';

  var deleteButton = document.createElement('button');
  deleteButton.textContent = 'Eliminar';
  deleteButton.addEventListener('click', function() {
    confirmDelete();
  });
  deleteButton.style.float = 'left';
  deleteButton.style.marginTop = '10px';
  deleteButton.style.marginLeft = '10px';


  var cancelButton = document.createElement('button');
  cancelButton.textContent = 'Cancelar';
  cancelButton.addEventListener('click', function() {
    dialog.remove();
  });
  cancelButton.style.float = 'right';
  cancelButton.style.marginTop = '10px';
  cancelButton.style.marginLeft = '10px';
  cancelButton.style.marginRight = '10px';

  

  dialog.appendChild(listContainer);

  dialog.appendChild(document.createElement("br"));
  dialog.appendChild(loadButton);
  if (!((!modoProcesosGenerales)&&(archivoSeleccionado === 'ProcesosGlobales.txt'))) {
    dialog.appendChild(deleteButton);
  }
  dialog.appendChild(cancelButton);

  document.body.appendChild(dialog);
  dialog.showModal();

  function loadSelectedItem() {
    if (selectedItem) {
      var selectedTitle = selectedItem.textContent;
      var selectedFlowchart = datosCargados.find(function(item) {
        return item.title === selectedTitle;
      });

      if (selectedFlowchart) {
        // Cargar el elemento seleccionado
        flowchartData = selectedFlowchart;
        // Ejecutar la funci√≥n externa drawFlowchart() pasando flowchartData como argumento
        //historial = [];
        //historialRehacer = [];
        historial.push(JSON.parse(JSON.stringify(flowchartData)));
        guardarEstado();
        drawFlowchart(flowchartData);
      }
    }
    dialog.remove();
  }

  function confirmDelete() {
    if (selectedItem) {
      var selectedTitle = selectedItem.textContent;
      var confirmation = confirm('¬øEst√°s seguro de que deseas eliminar el proceso <'+selectedTitle+'>?');
      if (confirmation) {
        deleteSelectedItem();
      }
    }
  }

  function deleteSelectedItem() {
    if (selectedItem) {
      var selectedTitle = selectedItem.textContent;
      var selectedFlowchartIndex = datosCargados.findIndex(function(item) {
        return item.title === selectedTitle;
      });

      if (selectedFlowchartIndex !== -1) {
        datosCargados.splice(selectedFlowchartIndex, 1);
        var contenido = JSON.stringify(datosCargados);
        const textoRuta = Ruta;
        const mensaje = "Para guargar los resultados selecciona en la pr√≥xima pantalla el "+textoArchivo+"  "+textoRuta+nombreArchivo+". La ruta se copiar√° en el portapapeles para que puedas pegarla en la b√∫squeda.";
     const opcion = confirm(mensaje);
      if (opcion) {
        copiarAlPortapapeles(textoRuta);
         guardarArchivoComo(contenido, nombreArchivo);
      }

        selectedItem.remove();
        selectedItem = null;
      }
    }
  }
}


function canvasToImage(canvas, filename){
           // Crea una nueva imagen en formato PNG
           var ctx = canvas.getContext('2d');
          var image = new Image();
          image.src = canvas.toDataURL('image/png');
  
          // Crea un enlace para descargar la imagen
         var a = document.createElement('a');
         a.href = image.src;
          a.download = filename || 'canvas_image.png';
  
         // Haz clic en el enlace para iniciar la descarga
          a.click();
        }

            // Agrega un manejador de clic al bot√≥n
    var saveButton = document.getElementById('saveCanvasImageButton');
    var canvas = document.getElementById('ctx'); // Reemplaza 'tuCanvas' con el ID de tu canvas

    saveButton.addEventListener('click', function () {
        canvasToImage(canvas, 'DiagramaFlujo.png');
    });



    function reorganizarSteps() {
  // Definir las constantes de espaciado vertical y horizontal
  const verticalSpacing = 85;
  const horizontalSpacing = 235;
  const marginTop = 80;

  // Encontrar el primer paso
  const stepsFechados = asignarFechas(flowchartData);

  //const primerPaso = stepsFechados[0];

  const primerPaso = flowchartData.steps.find(step => step.id === Object.keys(stepsFechados)[0]);
  
  if (!primerPaso) {
    console.error('No se encontr√≥ el primer paso.');
    return flowchartData;
  }

  // Funci√≥n para comprobar y ajustar la posici√≥n de un step
  function ajustarPosicionx(step) {

    // Verificar si hay otro step en la misma posici√≥n (x, y)
    while (flowchartData.steps.some(s => s !== step && s.x === step.x && s.y === step.y)) {
      step.x += horizontalSpacing;
    }
  }

  // Establecer las coordenadas del primer paso
  primerPaso.x = primerPaso.x || marginLeft;
  primerPaso.y = primerPaso.y || marginTop;

  // Recorrer los steps y ajustar sus posiciones
// Recorrer los paths y ajustar las coordenadas Y de los endSteps
for (const path of flowchartData.paths) {
    const startStep = flowchartData.steps.find(step => step.id === path.startStep);
    const endStep = flowchartData.steps.find(step => step.id === path.endStep);

    if (!startStep || !endStep) {
      continue; // Salta los paths con pasos no encontrados
    }

    // Establecer las coordenadas Y del endStep m√°s abajo que el startStep
    endStep.y = startStep.y + verticalSpacing;
    endStep.x = primerPaso.x;
  }

  for (const step of flowchartData.steps) {
    if (step === primerPaso) {
      continue; // Saltar el primer paso
    }

    ajustarPosicionx(step);
  }
  guardarEstado();
  drawFlowchart();
}


function tareaRealizada() {
     if(stepSelected=true){
              if (flowchartData.hasOwnProperty('steps')) {
            var steps = flowchartData.steps;
            for (var i = 0; i < steps.length; i++) {
             if (selectedStep.includes(steps[i].id)) {

              if (steps[i].hasOwnProperty('notas')) {
                delete steps[i].notas;
              }

              if (steps[i].hasOwnProperty('fechafin')) {
                delete steps[i].fechafin;
              }else{
                const fechaCompleta = new Date();
                const fecha = obtenerFormatoFecha(fechaCompleta);
                const okornot = fechaRealizada(steps[i].id, fecha);
                  if(fechaRealizada(steps[i].id, fecha)){
                    steps[i].fechafin=fecha;
                  }
              }
                 break;
             }
            }
          }
        }
        if(pathSelected=true){
          if (flowchartData.hasOwnProperty('paths')) {
            var paths = flowchartData.paths;
            for (var i = 0; i < paths.length; i++) {
             if (paths[i].id === selectedPath) {
              if (paths[i].hasOwnProperty('closed')) {
                delete paths[i].closed;
              }else{
                paths[i].closed=true;

              }
                 break;
             }
            }
          }
        }
        guardarEstado();
        drawFlowchart();
      }










      function fechaRealizada(stepId, fecha) {
          // Poner c√≥digo para comprobar que steps anteriores no tienen fecha posterior o steps posteriores no tengan fecha anterior. En caso contrario mostrar mensaje de error.
        return true;
    }



      function obtenerFormatoFecha(fechaCompleta) {
    const year = fechaCompleta.getFullYear();
    const month = String(fechaCompleta.getMonth() + 1).padStart(2, '0'); // Sumamos 1 al mes porque los meses en JavaScript van de 0 a 11
    const day = String(fechaCompleta.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}



        var canvas = document.getElementById('flowchartCanvas');
        var ctx = canvas.getContext('2d');


        var stepsHeight=[];

        //**********************************************************************************************************//
        function drawFlowchart() {


            if (flowchartData==null){return;};

            document.getElementById("flowChartName").value=flowchartData.title;

            let newCanvasWidth=600;
            let newCanvasHeight=800;
            if (flowchartData.hasOwnProperty('steps')) {
            flowchartData.steps.forEach(function (step) {
              if (step.x > newCanvasWidth-250) {
                newCanvasWidth=step.x+250;
             }
             if (step.y > newCanvasHeight-250) {
              newCanvasHeight=step.y+250;
             }
            });
            canvas.width= newCanvasWidth;
            canvas.height= newCanvasHeight;
          }

          if(flowchartData.hasOwnProperty("estadoProyecto")&&(flowchartData.estadoProyecto==="cerrado")){
              ctx.fillStyle = "lightgrey";
            }else{
              ctx.fillStyle = "white";
            }

            //ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillRect(0, 0, canvas.width, canvas.height);



			ctx.font = "11px Arial";

      if(flowchartData.hasOwnProperty("estadoProyecto")&&(flowchartData.estadoProyecto==="cerrado")){
            //ctx.strokeStyle = 'green';
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'black';
                // Configurar el estilo de texto
                ctx.font = '12px Arial';
                ctx.fillStyle = 'green';
                ctx.textAlign = 'left';
            ctx.fillText("PROYECTO CERRADO", 10, 20);
            //ctx.strokeStyle = '#000000';
            }

      if (flowchartData.hasOwnProperty('steps')) {

            //Calculamos las fechas:
            const stepsConFechas = asignarFechas(flowchartData);

            flowchartData.steps.forEach(function (step) {
                const stepId = step.id;
                //Separate text in different lines depending on text length:
                const anchoMaximo = 180;
                // Dividir el texto en palabras
                const palabras = step.label.split(' ');
                // Variable para almacenar las l√≠neas de texto
                let lineas = [''];
                // Iterar sobre las palabras
                for (const palabra of palabras) {
                const lineaActual = lineas[lineas.length - 1];
                const textoLineaActual = lineaActual + ' ' + palabra;
                // Obtener el ancho del texto actual
                const anchoTexto = ctx.measureText(textoLineaActual).width;
                if (anchoTexto <= anchoMaximo) {
                    // Agregar la palabra a la l√≠nea actual si no excede el ancho m√°ximo
                    lineas[lineas.length - 1] = textoLineaActual.trim();
                } else {
                    // Crear una nueva l√≠nea con la palabra actual
                    lineas.push(palabra);
                }
                }
                // Obtener el ancho y alto del rect√°ngulo que engloba todo el texto
                const rectanguloAncho = anchoMaximo + 10; // A√±ade un margen de 10 p√≠xeles
                var rectanguloAlto = lineas.length * 12 + 4; // A√±ade un margen de 10 p√≠xeles
                if(rectanguloAlto < 40){
                    rectanguloAlto=40;
                }
                stepsHeight.push([step.id,rectanguloAlto]);

                //Borramos espacio (colocamos fondo blanco o verde):
                if(step.hasOwnProperty("fechafin")){
                    ctx.fillStyle = '#cceedb';
                }else{
                  ctx.fillStyle = '#fff';
                }
                
                if((step.tipo==="step")||(!step.hasOwnProperty('tipo'))){
                  ctx.fillRect(step.x - 100, step.y - rectanguloAlto/2, 200, rectanguloAlto);
                }
                if(step.tipo==="milestone"){
                  ctx.fillRect(step.x - 100, step.y - rectanguloAlto/2, 195, rectanguloAlto);
                  ctx.beginPath()
                  ctx.moveTo(step.x +95, step.y - rectanguloAlto/2);
                  ctx.lineTo(step.x + 105, step.y);
                  ctx.lineTo(step.x + 95, step.y+ rectanguloAlto/2);
                  ctx.lineTo(step.x + 95, step.y+ rectanguloAlto/2);
                  ctx.fill();
                  ctx.stroke()
                  ctx.closePath()
                }



                // Set outline color based on selection
                if ((stepSelected==true)&&(selectedStep.includes(step.id))) {
                    ctx.strokeStyle = '#ff0000'; // Red outline for selected step
                } else {
                    ctx.strokeStyle = '#000000'; // Black outline for unselected steps
                }

                if((step.tipo==="step")||(!step.hasOwnProperty('tipo'))){
                  console.log(step); // Verifica el contenido completo
                  console.log('is_a_multiple_task:', step.is_a_multiple_task);
                  if((step.hasOwnProperty('is_a_multiple_task'))&&(step.is_a_multiple_task==="true")){

                      // Calcular progreso
                      const dataInstancias = step.infoElementsDataPorInstancia || {};
                      console.log('Barra - dataInstancias: ', dataInstancias);
                      const nombres = Object.keys(dataInstancias);
                      console.log('Barra - nombres: ', dataInstancias);
                      let total = nombres.length;
                      let finalizados = 0;

                      nombres.forEach(nombre => {
                          const estado = dataInstancias[nombre]?.finalState?.value;
                          if (estado === "completed" || estado === "cancelled") {
                              finalizados++;
                          }
                      });

                      const progreso = total > 0 ? finalizados / total : 0;
                      const porcentaje = Math.round(progreso * 100);

                      console.log('Barra - progreso: ', progreso);
                       console.log('Barra - porcentaje: ', progreso);

                      // Coordenadas de la barra
                      const barraX = step.x + 100;
                      const barraYInicio = step.y + rectanguloAlto / 2 - 2;
                      const barraYFin = step.y - rectanguloAlto / 2 + 2;
                      const alturaTotal = barraYInicio - barraYFin;
                      const alturaProgreso = alturaTotal * progreso;

                      // Fondo gris de la barra
                      ctx.beginPath();
                      ctx.fillStyle = "#e0e0e0";
                      ctx.rect(barraX, barraYFin, 8, alturaTotal);
                      ctx.fill();
                      ctx.closePath();

                      // Barra verde de progreso
                      ctx.beginPath();
                      ctx.fillStyle = color_OK_fondo; // Verde
                      ctx.rect(barraX, barraYInicio - alturaProgreso, 8, alturaProgreso);
                      ctx.fill();
                      ctx.closePath();

                      // Contorno de la barra
                      ctx.beginPath();
                      //ctx.strokeStyle = "#666";
                      ctx.rect(barraX, barraYFin, 8, alturaTotal);
                      ctx.stroke();
                      ctx.closePath();

                      // Mostrar porcentaje al lado derecho de la barra
                      if (total > 0) {
                        ctx.save(); // Guarda estado actual
                        ctx.font = "12px Arial";
                        ctx.fillStyle = color_OK_fondo;
                        ctx.textAlign = "left";
                        ctx.textBaseline = "middle";
                        ctx.fillText(`${porcentaje}%`, barraX + 10, step.y);
                        ctx.restore(); // Restaura estado previo (alineaciones, estilos, etc.)
                      }

                  }
                 ctx.strokeRect(step.x - 100, step.y - rectanguloAlto/2, 200, rectanguloAlto);

                }
                if(step.tipo==="milestone"){
                  ctx.beginPath();
                  ctx.moveTo(step.x - 100, step.y - rectanguloAlto/2);
                  ctx.lineTo(step.x + 95, step.y - rectanguloAlto/2);
                  ctx.lineTo(step.x + 105, step.y);
                  ctx.lineTo(step.x + 95, step.y+ rectanguloAlto/2);
                  ctx.lineTo(step.x - 100, step.y+ rectanguloAlto/2);
                  ctx.lineTo(step.x - 100, step.y - rectanguloAlto/2);
                  ctx.moveTo(step.x - 105, step.y+ rectanguloAlto/2+5);
                  ctx.lineTo(step.x - 105, step.y - rectanguloAlto/2-5);
                  ctx.stroke();
                  ctx.beginPath();
                  ctx.arc(step.x - 105, step.y - rectanguloAlto/2-10, 5, 0, 2 * Math.PI);
                  ctx.fill();
                  //ctx.closePath()
                  //ctx.strokeStyle = 'black';
                  ctx.lineWidth = 1;
                  ctx.stroke();
                  
                }

                
                ctx.beginPath();
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'black';
                ctx.stroke();
                // Configurar el estilo de texto
                ctx.font = '12px Arial';
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                // Dibujar el texto l√≠nea por l√≠nea
                lineas.forEach((linea, indice) => {
                ctx.fillText(linea, step.x, step.y-15-(lineas.length-1) * 6-(indice*8) + (indice + 1) * 20);
                });

                
                // Dibujamos las fechas inicial y final:
                const stepConFechas = stepsConFechas[stepId];
                    // Verificar si stepConFechas est√° definido (podr√≠a ser null si no tiene paths de entrada)
                if (stepConFechas) {
                  const startDate = stepConFechas.start_date ? formatearFecha(stepConFechas.start_date) : 'ND';
                  const endDate = stepConFechas.end_date ? formatearFecha(stepConFechas.end_date): 'ND';
                  const duracion = stepConFechas.duracion === 0 ? '0' : (stepConFechas.duracion ? stepConFechas.duracion.toString() : 'ND');
                  //const duracion = stepConFechas.duracion ? stepConFechas.duracion.toString() : '0';
                  const unidad = stepConFechas.unidad ? stepConFechas.unidad.toString() : 'ND';
                  if((!modoProcesosGenerales)&&(mostrar_fecha_inicio)){
                  ctx.fillText(startDate, step.x-70, step.y-22-(rectanguloAlto-40)/2);
                  }
                  var unidadPresentada="";
                  switch(unidad){
                    case "l":
                    if (duracion===1){
                      unidadPresentada="d√≠a lab.";
                    }else{
                      unidadPresentada="d√≠as lab.";
                    }
                    break;
                    case "h":
                    if (duracion===1){
                      unidadPresentada="d√≠a h√°b.";
                    }else{
                      unidadPresentada="d√≠as hab.";
                    }
                    break;
                    case "n":
                    if (duracion===1){
                      unidadPresentada="d√≠a nat.";
                    }else{
                      unidadPresentada="d√≠as nat.";
                    }

                    break;
                    case "m":
                    if (duracion===1){
                      unidadPresentada="mes";
                    }else{
                      unidadPresentada="meses";
                    }
                    break;
                    case "a":
                    if (duracion===1){
                      unidadPresentada="a√±o";
                    }else{
                      unidadPresentada="a√±os";
                    }
                    break;
                  }
                


                  if(step.tipo !=="milestone"){
                    if(mostrar_duracion){
                      ctx.fillText(duracion+' '+unidadPresentada, step.x+70, step.y-22-(rectanguloAlto-40)/2);
                    }
                    var rol = step.rol;
                    if(!modoProcesosGenerales){
                      if(mostrar_fecha_fin){
                        ctx.fillText(endDate, step.x-70, step.y+32 +(rectanguloAlto-40)/2);
                      }

                    // Comprobar si hay una asignaci√≥n de cargo en flowchartData.asignacionRoles para este rol
                    if (flowchartData.asignacionRoles && flowchartData.asignacionRoles[rol]) {
                       rol = flowchartData.asignacionRoles[rol]; // Usar el cargo asignado en lugar del rol
                    }
                  }
                    var xpos=95-6*rol.length;
                    if(xpos<3){
                       xpos=3;
                    }
                    ctx.textAlign = 'left';
                    if(mostrar_rol){
                    ctx.fillText(rol, step.x + xpos, step.y + 32 +(rectanguloAlto-40)/2);
                    }
                    
                  }
                  //ctx.fillText(step.id, step.x, step.y-22);
                  if(stepConFechas.hasOwnProperty("NOCumpleLig")){
                    ctx.fillStyle = "red";
                    ctx.fillText("NO CUMPLE", step.x+102, step.y-10);
                    ctx.fillText("LIGADURA", step.x+102, step.y+4);
                    ctx.fillText("TEMPORAL", step.x+102, step.y+18);

                    //ctx.fillStyle = '#000';
                  }
                  ctx.textAlign = 'center';
                }
              
            });
          }



          if (flowchartData.hasOwnProperty('paths')) {
            flowchartData.paths.forEach(function (path) {
                var startStep = getStepById(path.startStep);
                var endStep = getStepById(path.endStep);
                var startHeight = (getStepHeightById(path.startStep)/2);
                var endHeight = (getStepHeightById(path.endStep)/2);
                var condicion = path.condicion;
                var duracion = path.duracion;
                var maxmin = path.maxmin;
                var tipoduracion = path.tipoduracion;
                var unidadduracion = path.unidadduracion;

                                // Set outline color based on selection
                if ((pathSelected==true)&&(selectedPath === path.id)) {
                    ctx.strokeStyle = '#ff0000'; // Red outline for selected step
                    ctx.fillStyle = '#ff0000';
                } else {
                    ctx.strokeStyle = '#000000'; // Black outline for unselected steps
                    ctx.fillStyle = '#000000';
                }

                if((endStep.hasOwnProperty('multiple_task_following_previous'))&&(endStep.multiple_task_following_previous.startsWith("step"))&&(startStep.id===endStep.multiple_task_following_previous)){
                  ctx.lineWidth = 3;
                }else{
                  ctx.lineWidth = 1;
                }

                ctx.beginPath();

                if((!(path.hasOwnProperty('type')))||((path.hasOwnProperty('type'))&& (path.type === 'path'))){

                var radio=Math.abs((endStep.x-startStep.x)/2); //radio de las esquinas del path
                if(radio>10){radio=10}; // radio m√°ximo
                var radio2=radio;
                if(((endStep.y-endHeight-16)<(startStep.y+startHeight+16))&&(((startStep.y+startHeight+16)-(endStep.y-endHeight-16)))<(2*radio2)){
                  radio2=((startStep.y+startHeight+16)-(endStep.y-endHeight-16))/2;
                }

                ctx.moveTo(startStep.x, startStep.y+startHeight);

                 //Primer segmento corto hacia abajo
                if(endStep.y<(startStep.y+32+((startHeight+endHeight)/2))){ //el segundo step est√° por encima de el primero (no habitual)
                    if(endStep.x>(startStep.x+220)){ //Segundo a la derecha
                      ctx.lineTo(startStep.x, startStep.y+startHeight+16-radio);
                      ctx.arc (startStep.x+radio, startStep.y+startHeight+16-radio, radio, Math.PI, 0.5*Math.PI, true);
                        ctx.lineTo(endStep.x-110-radio, startStep.y+startHeight+16);
                        ctx.arc (endStep.x-110-radio2, startStep.y+startHeight+16-radio2, radio2, 0.5*Math.PI, 0, true);
                        ctx.lineTo(endStep.x-110, endStep.y-endHeight-16+radio2);
                        ctx.arc (endStep.x-110+radio2, endStep.y-endHeight-16+radio2, radio2, Math.PI, 1.5*Math.PI, false);
                        ctx.lineTo(endStep.x-radio, endStep.y-endHeight-16);
                        ctx.arc (endStep.x-radio, endStep.y-endHeight-16+radio, radio, 1.5*Math.PI, 0, false );
                    }else{
                      if(endStep.x>(startStep.x-220)){ //Uno Encima del otro
                        radio1=10;
                        radio2=10;
                        if (endStep.x>(startStep.x)){ //encima pero a la redercha
                            ctx.lineTo(startStep.x, startStep.y+startHeight+16-radio1);
                            ctx.arc (startStep.x+radio1, startStep.y+endHeight+16-radio1, radio1, Math.PI, 0.5*Math.PI, true );
                            ctx.lineTo(endStep.x+110-radio2, startStep.y+startHeight+16);
                            ctx.arc (endStep.x+110-radio2, startStep.y+startHeight+16-radio2, radio2, 0.5*Math.PI, 0, true);
                            ctx.lineTo(endStep.x+110, endStep.y-endHeight-16+radio2);
                            ctx.arc (endStep.x+110-radio2, endStep.y-endHeight-16+radio2, radio2, 0, 1.5*Math.PI, true);
                            ctx.lineTo(endStep.x+radio, endStep.y-endHeight-16);
                            ctx.arc (endStep.x+radio, endStep.y-endHeight-16+radio, radio, 1.5*Math.PI, Math.PI, true );
                        }else{ //encima pero a la izquierda
                          ctx.lineTo(startStep.x, startStep.y+startHeight+16-radio1);
                          ctx.arc (startStep.x-radio1, startStep.y+startHeight+16-radio1, radio1, 0, 0.5*Math.PI, false);
                            ctx.lineTo(endStep.x-110+radio2, startStep.y+startHeight+16);
                            ctx.arc (endStep.x-110+radio2, startStep.y+startHeight+16-radio2, radio2, 0.5*Math.PI, Math.PI, false);
                            ctx.lineTo(endStep.x-110, endStep.y-endHeight-16+radio2);
                            ctx.arc (endStep.x-110+radio2, endStep.y-endHeight-16+radio2, radio2, Math.PI, 1.5*Math.PI, false);
                            ctx.lineTo(endStep.x-radio, endStep.y-endHeight-16);
                            ctx.arc (endStep.x-radio, endStep.y-endHeight-16+radio, radio, 1.5*Math.PI, 0, false );
                        }
                      }else{ //Segundo a la izquierda
                        ctx.lineTo(startStep.x, startStep.y+startHeight+16-radio);
                        ctx.arc (startStep.x-radio, startStep.y+startHeight+16-radio, radio, 0, 0.5*Math.PI, false);
                        ctx.lineTo(endStep.x+110+radio2, startStep.y+startHeight+16);
                        ctx.arc (endStep.x+110+radio2, startStep.y+startHeight+16-radio2, radio2, 0.5*Math.PI, Math.PI, false);
                        ctx.lineTo(endStep.x+110, endStep.y-endHeight-16+radio2);
                        ctx.arc (endStep.x+110-radio2, endStep.y-endHeight-16+radio2, radio2, 0, 1.5*Math.PI, true);
                        ctx.lineTo(endStep.x+radio, endStep.y-endHeight-16);
                        ctx.arc (endStep.x+radio, endStep.y-endHeight-16+radio, radio, 1.5*Math.PI, Math.PI, true );
                      }
                        //ctx.arc (startStep.x-radio, startStep.y+startHeight+16, radio, 0, 0.5*Math.PI);
                        //ctx.arc (startStep.x-radio, startStep.y+startHeight+16-radio, radio, 0, 0.5*Math.PI, false);

                    }
                }else{ //el segundo step est√° por debajo del primero (lo habitual)
                  if((endStep.y<(startStep.y+32+((startHeight+endHeight))))&&(endStep.y>=(startStep.y+32+((startHeight+endHeight)/2)))){
                    radio=1;
                  }else{
                    
                  }
                  ctx.lineTo(startStep.x, endStep.y-endHeight-16-radio);
                  if(endStep.x>startStep.x){
                    ctx.arc (startStep.x+radio, endStep.y-endHeight-16-radio, radio, Math.PI, 0.5*Math.PI, true );
                    ctx.lineTo(endStep.x-radio, endStep.y-endHeight-16);
                    ctx.arc (endStep.x-radio, endStep.y-endHeight-16+radio, radio, 1.5*Math.PI, 0, false );
                  }else{
                    ctx.arc (startStep.x-radio, endStep.y-endHeight-16-radio, radio, 0, 0.5*Math.PI, false);
                    ctx.lineTo(endStep.x+radio, endStep.y-endHeight-16);
                    ctx.arc (endStep.x+radio, endStep.y-endHeight-16+radio, radio, 1.5*Math.PI, Math.PI, true );
                  }
                }
                ctx.lineTo(endStep.x, endStep.y-endHeight);
                //Texto:
                
                if(typeof condicion == "undefined"){}else{
                  ctx.font = '12px Arial';
                  //ctx.fillStyle = '#000';
                  ctx.textAlign = 'center';
                  var xpos= startStep.x+6+(ctx.measureText(condicion).width/2); //texto junto a l√≠nea 
                 // var xpos= startStep.x-(startStep.x-endStep.x)/2+15; // texto en el centro
                  var ypos=endStep.y-endHeight-20;
                  

                  if(endStep.y<(startStep.y+32+startHeight+endHeight)){
                  ypos=startStep.y+startHeight+12;
                  }else{
                  ypos=endStep.y-endHeight-20;
                  }

                  var ytext =ypos-2;
                  var xtext = xpos;
                  //var xtext = xpos-(ctx.measureText(condicion).width/6);//texto al centro
              //    if((endStep.x>=startStep.x)&&(endStep.x<(startStep.x+12+(ctx.measureText(condicion).width)))){xtext=startStep.x+6+(ctx.measureText(condicion).width/2)}; //texto al centro
               //   if((endStep.x<startStep.x)&&(endStep.x>(startStep.x-12-(ctx.measureText(condicion).width)))){xtext=startStep.x-6-(ctx.measureText(condicion).width/2)};  // texto al centro
                if(endStep.x<startStep.x){xtext=startStep.x-6-(ctx.measureText(condicion).width/2)};


                 //   if((endStep.y<(startStep.y+32+startHeight+endHeight))&&(xpos>endStep.x-102)){ //texto al centro
                  if(endStep.y<(startStep.y+32+startHeight+endHeight)){
                        xpos=endStep.x-102;
                       // if(endStep.x < (250+startStep.x)){
                          ytext=ypos+20;
                      //  }
                        
                    }

                  ctx.fillText(condicion, xtext, ytext);
                  //ctx.fillText(path.id, xtext, ytext+14);
                }
                  ctx.stroke();
                  //flecha:
                ctx.beginPath();
                ctx.lineTo(endStep.x-3, endStep.y-endHeight-5);
                ctx.lineTo(endStep.x+3, endStep.y-endHeight-5);
                ctx.lineTo(endStep.x, endStep.y-endHeight);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#000000';

                //ctx.fillText(path.id, endStep.x+15, endStep.y-endHeight-20);

                // Dibuja la aspa si path cerrado:
                if ((path.type === 'path')&&(path.hasOwnProperty('closed'))) {
                  const crossSize = 10; // Tama√±o de la aspa

                  ctx.strokeStyle = 'black';
                  ctx.lineWidth = 2;
                  // Dibuja la primera l√≠nea de la aspa
                  ctx.beginPath();
                  ctx.moveTo(xpos - crossSize * 2, ypos);
                  ctx.lineTo(xpos - crossSize, ypos + crossSize);
                  ctx.stroke();
                  // Dibuja la segunda l√≠nea de la aspa
                  ctx.beginPath();
                  ctx.moveTo(xpos - crossSize, ypos);
                  ctx.lineTo(xpos - crossSize * 2, ypos + crossSize);
                  ctx.stroke();
                  }
                }
                //Si es ligadura temporal
              if((path.hasOwnProperty('type'))&& (path.type === 'ligtime')){
                ctx.setLineDash([5, 8]);
                if((tipoduracion==="IF")||(tipoduracion==="II")){
                  ctx.moveTo(startStep.x+100, startStep.y-startHeight);
                  ctx.lineTo(Math.max(startStep.x, endStep.x)+125, startStep.y-startHeight);
                }else{
                  ctx.moveTo(startStep.x+100, startStep.y+startHeight);
                  ctx.lineTo(Math.max(startStep.x, endStep.x)+125, startStep.y+startHeight);
                }

                if((tipoduracion==="II")||(tipoduracion==="FI")){
                  ctx.lineTo(Math.max(startStep.x, endStep.x)+125, endStep.y-startHeight);
                  ctx.lineTo(endStep.x+100, endStep.y-startHeight);
                }else{
                  ctx.lineTo(Math.max(startStep.x, endStep.x)+125, endStep.y+endHeight);
                  ctx.lineTo(endStep.x+100, endStep.y+endHeight);
                }
                ctx.stroke();
                ctx.setLineDash([]);
                if(typeof duracion == "undefined"){}else{
                  ctx.font = '12px Arial';
                  ctx.textAlign = 'left';
                  var ligtimetext="";
                  if(maxmin==="MX") ligtimetext="M√°x: ";
                  if(maxmin==="MN") ligtimetext="Min: ";
                  ligtimetext=ligtimetext+duracion;
                  if(unidadduracion==="n") ligtimetext=ligtimetext+" d√≠as naturales";
                  if(unidadduracion==="h") ligtimetext=ligtimetext+" d√≠as h√°biles";
                  if(unidadduracion==="l") ligtimetext=ligtimetext+" d√≠as laborables";
                  if(unidadduracion==="m") ligtimetext=ligtimetext+" meses";
                  if(unidadduracion==="a") ligtimetext=ligtimetext+" a√±os";
                  
                  ctx.fillText(ligtimetext, Math.max(startStep.x, endStep.x)+130, startStep.y+(endStep.y-startStep.y)/2);
                }
              }


            });
          }

          // Dibujamosel rect√°ngulo de selecci√≥n si `isSelecting` es true
          if ((!stepCanMove)&&isSelecting) {
              //var ctx = canvas.getContext('2d');
              ctx.strokeStyle = 'black'; // Color negro
              ctx.lineWidth = 1; // L√≠nea fina
              ctx.setLineDash([5, 3]); // L√≠nea de puntos (5 p√≠xeles pintados, 3 p√≠xeles de espacio)

              var startX = Math.min(selectionStart.x, selectionEnd.x);
              var endX = Math.max(selectionStart.x, selectionEnd.x);
              var startY = Math.min(selectionStart.y, selectionEnd.y);
              var endY = Math.max(selectionStart.y, selectionEnd.y);

              ctx.strokeRect(startX, startY, endX - startX, endY - startY);
          }
            //Set flowchart title:
			//ctx.font = "14px Arial";
			//ctx.fillText(flowchartData.title, 60, 30);
        }
        function getStepById(id) {
            return flowchartData.steps.find(function (step) {
                return step.id === id;
            });
        }
        function getStepHeightById(id) {
            var result;
            for( var i = 0, len = stepsHeight.length; i < len; i++ ) {
                if( stepsHeight[i][0] === id ) {
                    result = stepsHeight[i][1];
                   break;
                 }
            }
            return result;
        }

        let ctrlPressed = false;

// Detectar cu√°ndo se presiona la tecla CTRL
document.addEventListener('keydown', function (event) {
    if (event.key === 'Control') {
        ctrlPressed = true;
    }
});

// Detectar cu√°ndo se libera la tecla CTRL
document.addEventListener('keyup', function (event) {
    if (event.key === 'Control') {
        ctrlPressed = false;
    }
});


        // Handle click events on the canvas
        canvas.addEventListener('mousedown', function (event) {
    stepCanMove = false;

    var rect = canvas.getBoundingClientRect();
    var clickX = event.clientX - rect.left;
    var clickY = event.clientY - rect.top;

    // Iniciar selecci√≥n m√∫ltiple (por si el usuario arrastra)
    selectionStart = { x: clickX, y: clickY };
    selectionEnd = { x: clickX, y: clickY };
    isSelecting = true;

    if (expiredTime) {
        expiredTime = false;

        var stepselection = stepClicked(clickX, clickY);

        // Verificar si se hizo clic en una tarea
        if (stepselection === null) {
            // Si se clic√≥ fuera de cualquier tarea, deseleccionar todo
            stepSelected = false;
            selectedStep = [];
            stepCanMove = false;
        } else {
          
            // Si la tarea clicada ya est√° en la selecci√≥n, no cambiar selectedStep
            if (!selectedStep.includes(stepselection)) {
              if (ctrlPressed) {
                  // Si CTRL est√° presionado, agregar o quitar tarea de la selecci√≥n
                  if (selectedStep.includes(stepselection)) {
                      // Si la tarea ya est√° seleccionada, quitarla de la selecci√≥n
                      selectedStep = selectedStep.filter(step => step !== stepselection);
                  } else {
                      // Si no est√° seleccionada, agregarla
                      selectedStep.push(stepselection);
                  }
              } else {
                  // Si CTRL no est√° presionado, seleccionar solo la tarea clicada
                  selectedStep = [stepselection];
              }
            }

            stepSelected = true;
            pathSelected = false;

                // Determinar si se ha hecho clic en una tarea seleccionada
            var stepselection = stepClicked(clickX, clickY);

            if (selectedStep.includes(stepselection)) {
                // Si el clic est√° sobre una tarea seleccionada, habilitar movimiento
                stepCanMove = true;
                dragStart = { x: event.clientX - rect.left, y: event.clientY - rect.top };

                // Guardar posiciones iniciales de las tareas seleccionadas
                initialPositions = flowchartData.steps
                    .filter(step => selectedStep.includes(step.id))
                    .map(step => ({ id: step.id, x: step.x, y: step.y }));
            } else {
                // Si no est√°s moviendo tareas, activa la selecci√≥n m√∫ltiple
                stepCanMove = false;
                isSelecting = true;
                selectionStart = { x: clickX, y: clickY };
                selectionEnd = { x: clickX, y: clickY };
            }


        }

        var pathselection=pathClicked(clickX, clickY);
                if ( pathselection=== null) {
                  pathSelected=false;
                  selectedPath = null;

                  var boton = document.getElementById("doneButton");
                  // Cambiar el √≠cono
                  boton.innerHTML = '<img src="media/okStep.png" title="Cerrar"/>';

                }else{
                    pathSelected=true;
                    stepSelected=false;
                    selectedPath = pathselection; // Set the selected step
                    expiredTime = true;

                    var boton = document.getElementById("doneButton");
                    // Cambiar el √≠cono
                    boton.innerHTML = '<img src="media/closePath.png" title="Cerrar"/>';


                   drawFlowchart(); 
                }

        setTimeout(() => {
            expiredTime = true;
        }, 300);

        drawFlowchart(); // Redibujar el diagrama con los pasos seleccionados
    }
});


        canvas.addEventListener('dblclick', function (event) {

stepCanMove=false;
var rect = canvas.getBoundingClientRect();
var clickX = event.clientX - rect.left;
var clickY = event.clientY - rect.top;

// Check if the click intersects with any step
flowchartData.steps.forEach(function (step) {
    if (
        clickX >= step.x - 100 &&
        clickX <= step.x + 100 &&
        clickY >= step.y - 20 &&
        clickY <= step.y + 20
    ) {
      selectedStep = [step.id];
      //showStepOptionsDialog();
      showNameAndInstructions();

      // Do something with the selectedOption, if needed
      //break;
     }
});
stepSelected=false;
drawFlowchart();
});


        canvas.addEventListener('contextmenu', function (event) { //Bot√≥n derecho /right click
    event.preventDefault(); // Evitar que aparezca el men√∫ contextual del navegador

    stepCanMove = false;
    var rect = canvas.getBoundingClientRect();
    var clickX = event.clientX - rect.left;
    var clickY = event.clientY - rect.top;

    // Check if the click intersects with any step
    flowchartData.steps.forEach(function (step) {
        if (
            clickX >= step.x - 100 &&
            clickX <= step.x + 100 &&
            clickY >= step.y - 20 &&
            clickY <= step.y + 20
        ) {
            selectedStep = [step.id];

            showStepDialog(false, step.tipo, step.id, step.label, step.rol, step.Duracion, step.instrucciones, step.unidadduracion, step.fechafin, step.notas, step.is_a_multiple_task, step.multiple_task_following_previous); // isNew se establece en false para actualizar el step seleccionado
          
        }
    });


    var pathselection=pathClicked(clickX, clickY);
    if(pathselection === null){

    }else{
      selectedPath = pathselection;

                  // Actualizar el step seleccionado en flowchartData.steps
      var selectedPathData = flowchartData.paths.find(function (path) {
                return path.id === pathselection;
            });
      showPathDialog(false, selectedPathData.startStep, selectedPathData.endStep, selectedPathData.id, selectedPathData.type, selectedPathData.condicion, selectedPathData.maxmin, selectedPathData.duracion, selectedPathData.unidadduracion, selectedPathData.tipoduracion);

    }


    stepSelected = false;
    drawFlowchart();
});


          function showStepOptionsDialog() {
                //Poner aqu√≠ el men√∫ de selecci√≥n de elementos
                alert("Seleccionar entre Texto o P√°gina html");
           }

function stepClicked(clickX, clickY){
  var respuesta=null;
  if (flowchartData.hasOwnProperty('steps')) {
  flowchartData.steps.forEach(function (step) {
                if (
                    clickX >= step.x - 100 &&
                    clickX <= step.x + 100 &&
                    clickY >= step.y - 20 &&
                    clickY <= step.y + 20
                ) {
                    respuesta = step.id; // Set the selected step
                }

              });
  }
  return respuesta;
}

function pathClicked(clickX, clickY){
  var respuesta=null;

  if (flowchartData.hasOwnProperty('paths')) {
            flowchartData.paths.forEach(function (path) {
              var startStep = getStepById(path.startStep);
              var endStep = getStepById(path.endStep);
             var startHeight = (getStepHeightById(path.startStep)/2);
             var endHeight = (getStepHeightById(path.endStep)/2);


                if ( //Primer tramo - descendente
                  ((!(path.hasOwnProperty('type')))||((path.hasOwnProperty('type'))&& (path.type === 'path')))&&(
                    (clickX >= startStep.x - 10 && 
                    clickX <= startStep.x + 10 &&
                    clickY >= startStep.y+startHeight &&
                    clickY <= endStep.y- endHeight-16) ||
                      (clickX >= Math.min(startStep.x, endStep.x) && //segundo tramo - horizontal
                    clickX <= Math.max(startStep.x, endStep.x-110)  &&
                    clickY >= Math.max(endStep.y- endHeight-16,startStep.y+ endHeight+20)-10 &&
                    clickY <= Math.max(endStep.y- endHeight-16,startStep.y+ endHeight+20)+10) ||
                    (clickX >= endStep.x+Math.sign(startStep.x-endStep.x)*100 -10  && //tercer tramo - vertical (si est√° m√°s alto el segundo step)
                    clickX <= endStep.x+Math.sign(startStep.x-endStep.x)*100 +10 &&
                    clickY >= endStep.y-startHeight-16 &&
                    clickY <= startStep.y+ endHeight+20) ||
                    (clickX >= Math.min(endStep.x,endStep.x+Math.sign(startStep.x-endStep.x)*100) && //cuarto tramo - horizontal
                    clickX <= Math.max(endStep.x+Math.sign(startStep.x-endStep.x)*100,endStep.x)  &&
                    clickY >= endStep.y- endHeight-16-10 &&
                    clickY <= endStep.y- endHeight-16+10) ||
                    (clickX >= endStep.x - 10 && // √∫ltimo tramo - descendente
                    clickX <= endStep.x + 10 &&
                    clickY >= endStep.y- endHeight -16 + 1 &&
                    clickY <= endStep.y- endHeight) 
                  )||(((path.hasOwnProperty('type'))&&(path.type === 'ligtime'))&&(
                    (clickX >= startStep.x+100 && 
                    clickX <= Math.max(startStep.x, endStep.x)+125 &&
                    clickY >= startStep.y+startHeight-10 &&
                    clickY <= startStep.y+startHeight+10)||
                    (clickX >= Math.max(startStep.x, endStep.x)+125 - 10 && 
                    clickX <= Math.max(startStep.x, endStep.x)+125 + 10 &&
                    clickY >= Math.min(startStep.y+startHeight, endStep.y+endHeight) &&
                    clickY <= Math.max(startStep.y+startHeight, endStep.y+endHeight)) ||
                    (clickX >= endStep.x+100 && 
                    clickX <= Math.max(startStep.x, endStep.x)+125 &&
                    clickY >= endStep.y+endHeight-10 &&
                    clickY <= endStep.y+endHeight+10) 
                  ))
                ) {
                  respuesta=path.id;
                }
            

            }); // 0 milisegundos de retraso antes de permitir mover de nuevo
          }
          return respuesta;
}



function openRestrictedTableEditor(element, nombre, tempInfoElementsDataPorInstancia, tempTablasGenerales, labelsPorNombreYInstancia) {

    let tablaGuardada;
    const tablaOriginalBase = element.tabla || { rows: [] };

    let originalBaseData = Array.isArray(tablaOriginalBase?.rows)
        ? tablaOriginalBase.rows.map(row => {
            if (typeof row === "string") return row.split("|||");
            if (Array.isArray(row) && typeof row[0] === "string" && row.length === 1) return row[0].split("|||");
            return row;
        })
        : [];

        if (nombre) {
            // "Uno para cada √≠tem"
            tablaGuardada = tempInfoElementsDataPorInstancia?.[nombre]?.[element.name]?.value;

            if (!tablaGuardada) {
                // No hab√≠a tabla a√∫n editada ‚Üí usar la de definici√≥n
                tablaGuardada = element.tabla || { rows: [] };
            }
        } else {
            // "Uno para todos los √≠tems"
            tablaGuardada = tempTablasGenerales?.[element.name];

            if (!tablaGuardada) {
                // No hab√≠a tabla a√∫n editada ‚Üí usar la de definici√≥n
                tablaGuardada = element.tabla || { rows: [] };
            }
        }


        const baseRows = Array.isArray(element.tabla?.rows) ? element.tabla.rows : [];
        const editedRows = Array.isArray(tablaGuardada?.rows) ? tablaGuardada.rows : [];

        // Convertir cada fila a arrays usando separador |||
        const splitRow = r =>
        Array.isArray(r) && r.length === 1 && typeof r[0] === "string"
            ? r[0].split("|||")
            : typeof r === "string"
            ? r.split("|||")
            : Array.isArray(r)
            ? r
            : [];

        const baseData = baseRows.map(splitRow);
        let editedData = editedRows.map(splitRow);



        // Mezclar: usar valores editados si existen, si no dejar vac√≠o (pero mantener la estructura)
        const totalRows = Math.max(baseData.length, editedData.length);
        const totalCols = Math.max(
            ...[...baseData, ...editedData].map(row => row.length)
        );

        let tableData = [];

        for (let r = 0; r < totalRows; r++) {
            const row = [];
            for (let c = 0; c < totalCols; c++) {
                const valorEditado = editedData?.[r]?.[c];
                const valorBase = baseData?.[r]?.[c];
                const valor = (valorEditado !== undefined && valorEditado !== null)
                    ? valorEditado.trim()
                    : (valorBase !== undefined && valorBase !== null)
                        ? valorBase.trim()
                        : "";
                row.push(valor);
            }
            tableData.push(row);
        }



        // Esto se usa para bloquear las celdas del formato original
        originalBaseData = baseData;


    const editorDiv = document.createElement("div");
    editorDiv.style.position = "fixed";
    editorDiv.style.left = "50%";
    editorDiv.style.top = "50%";
    editorDiv.style.transform = "translate(-50%, -50%)";
    editorDiv.style.padding = "20px";
    editorDiv.style.backgroundColor = "#fff";
    editorDiv.style.border = "1px solid #ccc";
    editorDiv.style.borderRadius = "8px";
    editorDiv.style.zIndex = "1000";
    editorDiv.style.fontFamily = "Arial";

    const title = document.createElement("h3");
    title.textContent = "Editor de tabla";
    title.style.marginBottom = "10px";
    editorDiv.appendChild(title);

    const table = document.createElement("table");
    table.style.borderCollapse = "collapse";
    table.style.marginBottom = "10px";
    table.style.border = "1px solid #ccc"; // borde general

    const renderTable = () => {
        table.innerHTML = "";

        // Botones eliminar columna
        const headerRow = document.createElement("tr");
        const cornerCell = document.createElement("th");
        cornerCell.style.border = "none";
        headerRow.appendChild(cornerCell);

        for (let c = 0; c < (tableData[0]?.length || 0); c++) {
            const th = document.createElement("th");
            th.style.border = "none";
            th.style.textAlign = "center";
            const btn = document.createElement("button");
            btn.textContent = "üóëÔ∏è";
            btn.style.border = "0";
            btn.style.backgroundColor = "transparent"; //  sin fondo gris
            btn.style.padding = "0"; //  elimina espacio alrededor
            btn.style.cursor = "pointer"; // (opcional, da sensaci√≥n de interactividad)

            btn.onclick = () => {
                let canDelete = true;
                for (let r = 0; r < originalBaseData.length; r++) {
                    if (originalBaseData[r]?.[c]?.trim()) {
                        canDelete = false;
                        break;
                    }
                }
                if (!canDelete) {
                    alert("No se puede eliminar una columna con datos originales.");
                    return;
                }
                tableData.forEach(row => row.splice(c, 1));
                renderTable();
            };
            th.appendChild(btn);
            headerRow.appendChild(th);
        }
        table.appendChild(headerRow);

        tableData.forEach((row, rowIndex) => {
            const tr = document.createElement("tr");

            const deleteBtnCell = document.createElement("td");
            deleteBtnCell.style.textAlign = "center";
            const btn = document.createElement("button");
            btn.textContent = "üóëÔ∏è";
            btn.style.border = "0";
            btn.style.backgroundColor = "transparent"; //  sin fondo gris
            btn.style.padding = "0"; //  elimina espacio alrededor
            btn.style.cursor = "pointer"; // (opcional, da sensaci√≥n de interactividad)
            btn.onclick = () => {
                let canDelete = true;
                for (let c = 0; c < originalBaseData[0]?.length || 0; c++) {
                    if (originalBaseData[rowIndex]?.[c]?.trim()) {
                        canDelete = false;
                        break;
                    }
                }
                if (!canDelete) {
                    alert("No se puede eliminar una fila con datos originales.");
                    return;
                }
                tableData.splice(rowIndex, 1);
                renderTable();
            };
            deleteBtnCell.appendChild(btn);
            tr.appendChild(deleteBtnCell);

            row.forEach((cell, colIndex) => {
                const td = document.createElement("td");
                td.style.border = "1px solid #ccc"; //  l√≠nea gris
                const input = document.createElement("input");
                input.type = "text";
                input.value = cell;
                input.style.border = "none";
                input.style.margin = "0";
                input.style.padding = "0";
                input.style.width = "100px";
                input.style.fontFamily = "Arial";

                const isFromOriginal = originalBaseData?.[rowIndex]?.[colIndex]?.trim();
                input.disabled = !!isFromOriginal;

                if (input.disabled) {
                    input.style.backgroundColor = "#f0f0f0"; // üëà fondo gris claro m√°s oscuro
                }
                input.oninput = () => {
                    tableData[rowIndex][colIndex] = input.value;
                };

                td.appendChild(input);
                tr.appendChild(td);
            });

            table.appendChild(tr);
        });
    };

    const addRowBtn = document.createElement("button");
    addRowBtn.textContent = "A√±adir fila";
    addRowBtn.onclick = () => {
        const cols = tableData[0]?.length || 1;
        tableData.push(new Array(cols).fill(""));
        renderTable();
    };

    const addColBtn = document.createElement("button");
    addColBtn.textContent = "A√±adir columna";
    addColBtn.onclick = () => {
        tableData.forEach(row => row.push(""));
        renderTable();
    };

    const guardarBtn = document.createElement("button");
    guardarBtn.textContent = "Guardar tabla";
    guardarBtn.style.marginLeft = "20px";
    guardarBtn.onclick = () => {
        const nuevaTabla = {
            rows: tableData.map(row => row.map(cell => cell.trim()).join("|||"))
        };

        // üîç Verificar si hay al menos una celda no vac√≠a
        const tieneContenido = tableData.some(row =>
            row.some(cell => cell.trim() !== "")
        );

        if (nombre) {
            if (!tempInfoElementsDataPorInstancia[nombre]) {
                tempInfoElementsDataPorInstancia[nombre] = {};
            }
            tempInfoElementsDataPorInstancia[nombre][element.name] = {
                type: "Tabla",
                value: nuevaTabla
            };

            // üîÑ Eliminar clase de error si hay contenido v√°lido
            const clave = `${element.name}|||${nombre}`;
            const label = labelsPorNombreYInstancia?.[clave];
            if (label && tieneContenido) {
                label.classList.remove("label-error");
                console.log("üü¢ Se elimin√≥ error de:", clave);
            } else if (!label) {
                console.warn("‚ö†Ô∏è No se encontr√≥ label para limpiar error:", clave);
            }
        } else {
            // "Uno para todos"
            tempTablasGenerales[element.name] = nuevaTabla;

            const clave = element.name;
            const label = labelsPorNombreYInstancia?.[clave];
            if (label && tieneContenido) {
                label.classList.remove("label-error");
                console.log("üü¢ Se elimin√≥ error de:", clave);
            } else if (!label) {
                console.warn("‚ö†Ô∏è No se encontr√≥ label para limpiar error:", clave);
            }
        }

        document.body.removeChild(editorDiv);
    };




    const cancelarBtn = document.createElement("button");
    cancelarBtn.textContent = "Cancelar";
    cancelarBtn.onclick = () => {
        document.body.removeChild(editorDiv);
    };

    renderTable();
    editorDiv.appendChild(table);
    editorDiv.appendChild(addRowBtn);
    editorDiv.appendChild(addColBtn);
    editorDiv.appendChild(guardarBtn);
    editorDiv.appendChild(cancelarBtn);
    document.body.appendChild(editorDiv);
}


function showCustomDialog({ title, content, onAccept, onCancel }) {
    // Fondo semitransparente para bloquear el resto
    const overlay = document.createElement("div");
    overlay.style.position = "fixed";
    overlay.style.left = "0";
    overlay.style.top = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.backgroundColor = "rgba(0, 0, 0, 0.3)";
    overlay.style.zIndex = "99998";

    // Di√°logo flotante centrado
    const dialog = document.createElement("div");
    dialog.className = "custom-dialog";
    dialog.style.position = "fixed";
    dialog.style.left = "50%";
    dialog.style.top = "50%";
    dialog.style.transform = "translate(-50%, -50%)";
    dialog.style.backgroundColor = "#fff";
    dialog.style.border = "1px solid #ccc";
    dialog.style.padding = "20px";
    dialog.style.zIndex = "99999"; // M√°s alto que todo
    dialog.style.maxWidth = "600px";
    dialog.style.width = "90%";
    dialog.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.3)";
    dialog.style.borderRadius = "8px";

    const titleElem = document.createElement("h3");
    titleElem.textContent = title;
    dialog.appendChild(titleElem);

    dialog.appendChild(content);

    const buttonsDiv = document.createElement("div");
    buttonsDiv.style.marginTop = "15px";
    buttonsDiv.style.textAlign = "right";

    const btnAceptar = document.createElement("button");
    btnAceptar.textContent = "Aceptar";
    btnAceptar.onclick = () => {
        document.body.removeChild(dialog);
        document.body.removeChild(overlay);
        onAccept();
    };

    const btnCancelar = document.createElement("button");
    btnCancelar.textContent = "Cancelar";
    btnCancelar.style.marginLeft = "10px";
    btnCancelar.onclick = () => {
        document.body.removeChild(dialog);
        document.body.removeChild(overlay);
        if (onCancel) onCancel();
    };

    buttonsDiv.appendChild(btnAceptar);
    buttonsDiv.appendChild(btnCancelar);
    dialog.appendChild(buttonsDiv);

    document.body.appendChild(overlay);
    document.body.appendChild(dialog);
}




function crearSeparadorSeccion(texto) {
    const wrapper = document.createElement("div");
    wrapper.style.display = "flex";
    wrapper.style.alignItems = "center";
    wrapper.style.marginTop = "30px";
    wrapper.style.marginBottom = "10px";

    const lineaIzquierda = document.createElement("div");
    lineaIzquierda.style.flex = "1";
    lineaIzquierda.style.height = "6px";
    lineaIzquierda.style.backgroundColor = color_menu_titles;
    lineaIzquierda.style.marginRight = "10px";

    const titulo = document.createElement("span");
    titulo.textContent = texto;
    titulo.style.color = color_menu_titles;
    titulo.style.fontWeight = "bold";
    titulo.style.fontFamily = "Arial";

    const lineaDerecha = document.createElement("div");
    lineaDerecha.style.flex = "1";
    lineaDerecha.style.height = "6px";
    lineaDerecha.style.backgroundColor = color_menu_titles;
    lineaDerecha.style.marginLeft = "10px";

    wrapper.appendChild(lineaIzquierda);
    wrapper.appendChild(titulo);
    wrapper.appendChild(lineaDerecha);

    return wrapper;
}








function showNameAndInstructions() {

    
    // Buscar el elemento en flowchartData con el ID igual a selectedStep

    var selectedStepData = flowchartData.steps.find(function (step) {
        return step.id === selectedStep[0];
    });

    var tempInfoElementsDataPorInstancia = JSON.parse(JSON.stringify(selectedStepData.infoElementsDataPorInstancia || {}));
    var tempTablasGenerales = JSON.parse(JSON.stringify(selectedStepData.tabla || {}));


    var inputsContainer = null;
    var selector = null;
    const infoInputs = {};
    const labelsPorNombreYInstancia = {}; // Clave: nombre+instancia, Valor: label



    if (selectedStepData) {
        var name = selectedStepData.label;
        var instructions = selectedStepData.instrucciones || "";
        var notes = selectedStepData.notas || "";
        var rol = selectedStepData.rol || "";
        var duracion = selectedStepData.Duracion || "";
        var unidadduracion = selectedStepData.unidadduracion || "";
        var tipo = selectedStepData.tipo || "";
        var fechafin = selectedStepData.fechafin || "";
        var elementosRequeridos = selectedStepData.infoElements || [];
        if (!selectedStepData.infoElementsDataPorInstancia) {
            selectedStepData.infoElementsDataPorInstancia = {};
        }






        var unidadText=" d√≠as naturales";

            // Crear las opciones para el desplegable "Unidad de duraci√≥n"
    switch (unidadduracion){
      case "n":
      unidadText= " d√≠as naturales";
            break;
      case "h":
      unidadText= " d√≠as h√°biles";
            break;
      case "l":
      unidadText= " d√≠as laborables";
            break;
      case "m":
      unidadText= " meses";
            break;
      case "a":
      unidadText= " a√±os";
            break;
    }


        // Crear un div para el cuadro de di√°logo
        // Crear un div para el cuadro de di√°logo principal
        var dialogDiv = document.createElement("div");
        dialogDiv.style.display = "flex";
        dialogDiv.style.flexDirection = "column";
        dialogDiv.style.position = "fixed";
        dialogDiv.style.left = "50%";
        dialogDiv.style.top = "50%";
        dialogDiv.style.transform = "translate(-50%, -50%)";
        dialogDiv.style.backgroundColor = "white";
        dialogDiv.style.padding = "20px";
        dialogDiv.style.border = "1px solid #ccc";
        dialogDiv.style.borderRadius = "5px";
        dialogDiv.style.maxHeight = "80vh";
        dialogDiv.style.width = "800px"; // Puedes ajustar esto si lo necesitas
        dialogDiv.style.overflow = "hidden";
        dialogDiv.style.boxShadow = "0 4px 10px rgba(0,0,0,0.2)";
        document.body.appendChild(dialogDiv);

        if (tipo === "step") {
          var nameParagraph = document.createElement("p");
          nameParagraph.style.fontFamily = "Arial";
          nameParagraph.style.fontSize = "14px";
          nameParagraph.style.fontWeight = "bold";
          nameParagraph.style.color = "white";
          nameParagraph.style.backgroundColor = "black";
          nameParagraph.style.padding = "8px 0";
          nameParagraph.style.textAlign = "center";
          nameParagraph.style.margin = "0 0 10px 0"; // sin m√°rgenes laterales, separaci√≥n inferior
          nameParagraph.textContent = name;
        }else{
          // Mostrar el nombre anterior en negrita (bold)
          var nameParagraph = document.createElement("p");
          nameParagraph.style.fontFamily = "Arial";
          nameParagraph.style.fontSize = "14px";
          nameParagraph.style.fontWeight = "bold";
          nameParagraph.textContent = "" + name;
        }
        dialogDiv.appendChild(nameParagraph);

        // Contenedor desplazable para el contenido
        const contentContainer = document.createElement("div");
        contentContainer.style.overflowY = "auto";
        contentContainer.style.flex = "1";
        contentContainer.style.paddingRight = "10px";
        dialogDiv.appendChild(contentContainer);



        if (tipo === "step") {

            contentContainer.appendChild(crearSeparadorSeccion("INFORMACI√ìN DISPONIBLE"));

            var rolParagraphLabel = document.createElement("label");
            rolParagraphLabel.style.fontFamily = "Arial";
            rolParagraphLabel.style.fontSize = "14px";
            rolParagraphLabel.textContent = "Rol: ";
            rolParagraphLabel.style.fontWeight = "bold";
            contentContainer.appendChild(rolParagraphLabel);

            var rolParagraph = document.createElement("label");
            rolParagraph.style.fontFamily = "Arial";
            rolParagraph.style.fontSize = "14px";
            rolParagraph.textContent = rol;
            contentContainer.appendChild(rolParagraph);
            contentContainer.appendChild(document.createElement("br"));
            contentContainer.appendChild(document.createElement("br"));

            var duracionParagraphLabel = document.createElement("label");
            duracionParagraphLabel.style.fontFamily = "Arial";
            duracionParagraphLabel.style.fontSize = "14px";
            duracionParagraphLabel.style.fontWeight = "bold";
            duracionParagraphLabel.textContent = "Duraci√≥n estimada: ";
            contentContainer.appendChild(duracionParagraphLabel);

            var duracionParagraph = document.createElement("label");
            duracionParagraph.style.fontFamily = "Arial";
            duracionParagraph.style.fontSize = "14px";
            duracionParagraph.textContent = duracion+unidadText;
            contentContainer.appendChild(duracionParagraph);
            contentContainer.appendChild(document.createElement("br"));




 
            var instLabelParagraph = document.createElement("p");
        instLabelParagraph.style.fontFamily = "Arial";
        instLabelParagraph.style.fontSize = "14px";
        instLabelParagraph.style.fontWeight = "bold";
        instLabelParagraph.textContent = "Instrucciones:";
        contentContainer.appendChild(instLabelParagraph);

        var instructionsParagraph = document.createElement("p");
        instructionsParagraph.style.fontFamily = "Arial";
        instructionsParagraph.style.fontSize = "14px";
        instructionsParagraph.style.overflowY = "auto"; // A√±ade la barra de desplazamiento si es necesario
        instructionsParagraph.style.maxHeight = "200px"; // Altura m√°xima antes de mostrar la barra de desplazamiento



        // La variable 'Ruta' contiene la ruta base
        var instructionsWithLinks = convertLinks(instructions, Ruta);
        var instructionsFormatted = instructionsWithLinks.replace(/\n/g, "<br>");

          if (tipo === "step") {
            instructionsParagraph.innerHTML = instructionsFormatted;
          } else if (tipo === "milestone") {
            instructionsParagraph.innerHTML = instructionsFormatted;
          }
        

          contentContainer.appendChild(instructionsParagraph);
          contentContainer.appendChild(document.createElement("br"));


          // Mostrar elementos recibidos en modo solo lectura
if (selectedStepData.receivedElements && Array.isArray(selectedStepData.receivedElements)) {

    const receivedHeader = document.createElement("h4");
    receivedHeader.textContent = "Elementos de informaci√≥n recibidos:";
    receivedHeader.style.fontFamily = "Arial";
    receivedHeader.style.marginTop = "20px";
    receivedHeader.style.color = color_menu_titles;
    contentContainer.appendChild(receivedHeader);


    const elementosGenerales = [];
    const elementosPorInstancia = {};

    selectedStepData.receivedElements.forEach(received => {
        if (selectedStepData.receivedElements && Array.isArray(selectedStepData.receivedElements)) {


    if (received.type === "htmlBlock") {
        // üß© Mostrar directamente el bloque de HTML sin fondo ni borde
        const bloque = document.createElement("div");
        bloque.innerHTML = received.html || "";
        bloque.style.all = "unset"; // sin estilos visibles
        contentContainer.appendChild(bloque);
        return;
    }

    // üëá Resto de elementos normales
    const origen = flowchartData.steps.find(s => s.id === received.stepId);
    const elem = received.element;
    const nombre = elem.name;

    let valorGeneral = origen?.valor?.[nombre];
    if (valorGeneral && typeof valorGeneral === "object") {
        if (valorGeneral.hasOwnProperty("valor")) valorGeneral = valorGeneral.valor;
        else if (valorGeneral.hasOwnProperty("value")) valorGeneral = valorGeneral.value;
    }

    if (elem.scope !== "Uno para cada √≠tem") {
        const row = document.createElement("div");
        row.className = "container";

        const label = document.createElement("label");
        label.style.fontWeight = "bold";
        label.style.marginRight = "5px";
        label.textContent = `${nombre}:`;
        row.appendChild(label);

        const valueSpan = document.createElement("span");
        if (elem.type?.startsWith("Check")) {
            valueSpan.textContent = valorGeneral === true || valorGeneral === "on" ? "S√≠" : "No";
        } else if (elem.type === "Tabla" && origen.tabla?.[nombre]) {
            const tablaValor = origen.tabla[nombre].rows;
            const tablaOriginal = origen.infoElements.find(el => el.name === nombre)?.tabla?.rows;

            const tablaHTML = document.createElement("table");
            tablaHTML.style.borderCollapse = "collapse";
            tablaHTML.style.marginTop = "5px";
            tablaHTML.style.marginBottom = "5px";

            tablaValor.forEach((fila, i) => {
                const tr = document.createElement("tr");
                fila.split("|||").forEach((celda, j) => {
                    const td = document.createElement("td");
                    td.textContent = celda;
                    td.style.border = "1px solid #ccc";
                    td.style.padding = "4px 8px";
                    if (tablaOriginal && tablaOriginal[i]?.[j] && tablaOriginal[i][j] !== "") {
                        td.style.backgroundColor = "#eee"; // celda bloqueada
                    }
                    tr.appendChild(td);
                });
                tablaHTML.appendChild(tr);
            });

            valueSpan.appendChild(tablaHTML);
        } else {
            valueSpan.textContent = valorGeneral || "(sin valor)";
            if (!valorGeneral) {
                valueSpan.style.fontStyle = "italic";
                valueSpan.style.color = "gray";
            }
        }

        row.appendChild(valueSpan);
        contentContainer.appendChild(row);

    } else if (origen?.infoElementsDataPorInstancia) {
        const instancias = Object.entries(origen.infoElementsDataPorInstancia)
            .filter(([inst, datos]) => datos.hasOwnProperty(nombre))
            .map(([inst, datos]) => {
                let val = datos[nombre];
                if (val && typeof val === "object") {
                    if (val.hasOwnProperty("valor")) val = val.valor;
                    else if (val.hasOwnProperty("value")) val = val.value;
                }
                return { instancia: inst, valor: val };
            });

        if (instancias.length > 0) {
            const contenedorDesplegable = document.createElement("div");
            contenedorDesplegable.style.marginTop = "10px";

            const select = document.createElement("select");
            select.style.marginBottom = "5px";
            instancias.forEach(inst => {
                const opt = document.createElement("option");
                opt.value = inst.instancia;
                opt.textContent = inst.instancia;
                select.appendChild(opt);
            });

            const valorContenedor = document.createElement("div");
            valorContenedor.style.marginTop = "5px";

            const renderValor = (instancia) => {
                const encontrado = instancias.find(i => i.instancia === instancia);
                valorContenedor.innerHTML = "";

                const row = document.createElement("div");
                row.className = "container";

                const label = document.createElement("label");
                label.style.fontWeight = "bold";
                label.style.marginRight = "5px";
                label.textContent = `${nombre}:`;
                row.appendChild(label);

                const valor = encontrado?.valor;
                const valueSpan = document.createElement("span");
                if (elem.type?.startsWith("Check")) {
                    valueSpan.textContent = valor === true || valor === "on" ? "S√≠" : "No";
                } else if (elem.type === "Tabla" && valor?.rows) {
                    const tablaHTML = document.createElement("table");
                    tablaHTML.style.borderCollapse = "collapse";
                    tablaHTML.style.marginTop = "5px";
                    tablaHTML.style.marginBottom = "5px";

                    const tablaOriginal = origen.infoElements.find(el => el.name === nombre)?.tabla?.rows;

                    valor.rows.forEach((fila, i) => {
                        const tr = document.createElement("tr");
                        fila.split("|||").forEach((celda, j) => {
                            const td = document.createElement("td");
                            td.textContent = celda;
                            td.style.border = "1px solid #ccc";
                            td.style.padding = "4px 8px";
                            if (tablaOriginal && tablaOriginal[i]?.[j] && tablaOriginal[i][j] !== "") {
                                td.style.backgroundColor = "#eee";
                            }
                            tr.appendChild(td);
                        });
                        tablaHTML.appendChild(tr);
                    });

                    valueSpan.appendChild(tablaHTML);
                } else {
                    valueSpan.textContent = valor || "(sin valor)";
                    if (!valor) {
                        valueSpan.style.fontStyle = "italic";
                        valueSpan.style.color = "gray";
                    }
                }

                row.appendChild(valueSpan);
                valorContenedor.appendChild(row);
            };

            select.addEventListener("change", () => renderValor(select.value));
            renderValor(select.value);

            contenedorDesplegable.appendChild(select);
            contenedorDesplegable.appendChild(valorContenedor);
            contentContainer.appendChild(contenedorDesplegable);
        }
    }


        }

    });

    function crearTablaVisual(tablaEditable, tablaOriginal) {
        const tablaHTML = document.createElement("table");
        tablaHTML.style.borderCollapse = "collapse";
        tablaHTML.style.marginTop = "4px";
        tablaHTML.style.fontFamily = "Arial";

        const filas = (tablaEditable?.rows || []).map(linea =>
            linea.split("|||").map(c => c.trim())
        );

        const celdasBloqueadas = (tablaOriginal?.rows || []).map(linea =>
            linea.map(c => c.trim() !== "")
        );

        filas.forEach((fila, i) => {
            const tr = document.createElement("tr");

            fila.forEach((valor, j) => {
                const td = document.createElement("td");
                td.textContent = valor;
                td.style.border = "1px solid #ccc";
                td.style.padding = "4px 6px";

                if (celdasBloqueadas[i]?.[j]) {
                    td.style.backgroundColor = "#eee";
                }

                tr.appendChild(td);
            });

            tablaHTML.appendChild(tr);
        });

        return tablaHTML;
    }

    // üîπ Mostrar primero los elementos generales
    elementosGenerales.forEach(e => {
        const row = document.createElement("div");
        row.className = "container";

        const label = document.createElement("label");
        label.style.fontWeight = "bold";
        label.style.marginRight = "5px";
        label.textContent = `${e.nombre}:`;
        row.appendChild(label);

        if (e.tipo === "Tabla" && e.valor?.rows) {
            const tablaOriginal = e.stepOrigen?.infoElements?.find(el => el.name === e.nombre)?.tabla;
            const tablaHTML = crearTablaVisual(e.valor, tablaOriginal);
            row.appendChild(tablaHTML);
        } else {
            const valueSpan = document.createElement("span");

            if (e.valor === undefined || e.valor === null || e.valor === "") {
                valueSpan.textContent = "(sin valor)";
                valueSpan.style.fontStyle = "italic";
                valueSpan.style.color = "gray";
            } else if (e.tipo?.startsWith("Check")) {
                valueSpan.textContent = e.valor === true || e.valor === "on" ? "S√≠" : "No";
            } else {
                valueSpan.textContent = e.valor;
            }

            row.appendChild(valueSpan);
        }

        contentContainer.appendChild(row);
    });

    // üî∏ Desplegable para elegir instancia
    const nombresInstancia = Object.keys(elementosPorInstancia);
    if (nombresInstancia.length > 0) {
        contentContainer.appendChild(document.createElement("br"));
        const selectorLabel = document.createElement("label");
        selectorLabel.textContent = "Selecciona elemento:";
        selectorLabel.style.fontFamily = "Arial";
        selectorLabel.style.fontWeight = "bold";
        selectorLabel.style.marginTop = "10px";
        contentContainer.appendChild(selectorLabel);

        const selector = document.createElement("select");
        selector.style.marginLeft = "10px";
        selector.style.fontFamily = "Arial";
        nombresInstancia.forEach(inst => {
            const option = document.createElement("option");
            option.value = inst;
            option.textContent = inst;
            selector.appendChild(option);
        });
        contentContainer.appendChild(selector);

        const instanciaContainer = document.createElement("div");
        instanciaContainer.style.marginTop = "10px";
        contentContainer.appendChild(instanciaContainer);

        function mostrarInstancia(nombre) {
            instanciaContainer.innerHTML = "";
            const elementos = elementosPorInstancia[nombre] || [];

            const tarjeta = document.createElement("div");
            tarjeta.style.border = "1px solid #ccc";
            tarjeta.style.borderRadius = "6px";
            tarjeta.style.padding = "10px 15px";
            tarjeta.style.marginTop = "10px";
            tarjeta.style.marginBottom = "10px";
            tarjeta.style.backgroundColor = "#fdfdfd";

            elementos.forEach(e => {
                const row = document.createElement("div");
                row.className = "container";
                row.style.marginBottom = "6px";

                const label = document.createElement("label");
                label.style.fontWeight = "bold";
                label.style.marginRight = "5px";
                label.textContent = `${e.nombre}:`;
                row.appendChild(label);

                if (e.tipo === "Tabla" && e.valor?.rows) {
                    const tablaOriginal = e.stepOrigen?.infoElements?.find(el => el.name === e.nombre)?.tabla;
                    const tablaHTML = crearTablaVisual(e.valor, tablaOriginal);
                    row.appendChild(tablaHTML);
                } else {
                    const valueSpan = document.createElement("span");

                    if (e.valor === undefined || e.valor === null || e.valor === "") {
                        valueSpan.textContent = "(sin valor)";
                        valueSpan.style.fontStyle = "italic";
                        valueSpan.style.color = "gray";
                    } else if (e.tipo?.startsWith("Check")) {
                        valueSpan.textContent = e.valor === true || e.valor === "on" ? "S√≠" : "No";
                    } else {
                        valueSpan.textContent = e.valor;
                    }

                    row.appendChild(valueSpan);
                }

                tarjeta.appendChild(row);
            });

            instanciaContainer.appendChild(tarjeta);

        }

        // Mostrar la primera por defecto
        mostrarInstancia(nombresInstancia[0]);

        selector.addEventListener("change", () => {
            mostrarInstancia(selector.value);
        });
    }
}









          contentContainer.appendChild(crearSeparadorSeccion("INFORMACI√ìN A APORTAR"));


          contentContainer.appendChild(document.createElement("br"));


          // üîµ Construir jerarqu√≠a directamente desde los elementos
          const elementosGenerales = elementosRequeridos.filter(e => e.scope === "Uno para todos los √≠tems");
          const elementosPorInstancia = elementosRequeridos.filter(e => e.scope === "Uno para cada √≠tem");


          let apartadosEnOrden = new Set();

          // 1. Recoger todos los apartados definidos
          elementosGenerales.forEach(e => {
              const partes = (e.apartado || "(Seleccionar apartado)").split(">");
              for (let i = 1; i <= partes.length; i++) {
                  const ruta = partes.slice(0, i).join(">");
                  apartadosEnOrden.add(ruta);
              }
          });

          // 2. A√±adir "(Seleccionar apartado)" si hay elementos sin apartado definido
          const haySinAsignar = elementosGenerales.some(e => !e.apartado);
          if (haySinAsignar) apartadosEnOrden.add("(Seleccionar apartado)");

          apartadosEnOrden = [...apartadosEnOrden];
          console.log("üß≠ apartadosEnOrden construidos desde los elementos:", apartadosEnOrden);


          console.log("üß± apartadosEnOrden (despu√©s del parseo):", apartadosEnOrden);

          // A√±adir todos los niveles intermedios para asegurarse de que se pintan encabezados padres
          let jerarquiaCompleta = new Set();
          apartadosEnOrden.forEach(ruta => {
              const partes = ruta.split(">");
              for (let i = 1; i <= partes.length; i++) {
                  const subRuta = partes.slice(0, i).join(">");
                  jerarquiaCompleta.add(subRuta);
              }
          });
          apartadosEnOrden = [...jerarquiaCompleta];
          console.log("‚úÖ apartadosEnOrden con jerarqu√≠a expandida:", apartadosEnOrden);

          // A√±adir "(Seleccionar apartado)" si hay elementos no asignados correctamente
          if (haySinAsignar) apartadosEnOrden.push("(Seleccionar apartado)");

          console.log("üìå apartadosEnOrden con (Seleccionar apartado):", apartadosEnOrden);

          // Crear copia sin tocar los elementos originales
          const elementosGeneralesCopia = elementosGenerales.map(e => {
              const apartadoLimpio = (e.apartado || "").trim();
              return {
                  ...e,
                  apartado: apartadoLimpio || "(Seleccionar apartado)"
              };
          });

          // Mostrar encabezados y elementos agrupados
          apartadosEnOrden.forEach(function (apartadoRutaCompleta) {
              const partes = apartadoRutaCompleta.split(">");
              const nivel = partes.length - 1;
              const nombreVisible = partes[partes.length - 1];

              console.log("üîΩ Mostrando encabezado:", apartadoRutaCompleta);

              const header = document.createElement("h5");
              header.innerHTML = apartadoRutaCompleta === "(Seleccionar apartado)"
                  ? "Elementos sin asignar:"
                  : "&nbsp;".repeat(nivel * 4) + nombreVisible;

              header.style.fontFamily = "Arial";
              header.style.marginTop = nivel === 0 ? "32px" : "16px";
              header.style.marginBottom = "12px";
              header.style.color = apartadoRutaCompleta === "(Seleccionar apartado)" ? "red" : color_text_titles;
              header.style.fontSize = nivel === 0 ? "16px" : nivel === 1 ? "14px" : "13px";
              if (nivel > 1) header.style.fontStyle = "italic";
              if (apartadoRutaCompleta === "(Seleccionar apartado)") header.style.fontWeight = "bold";

              contentContainer.appendChild(header);

              // Mostrar elementos de este apartado
              const elementosEnEsteApartado = elementosGeneralesCopia.filter(e => e.apartado === apartadoRutaCompleta);
              console.log("üß© Elementos en", apartadoRutaCompleta, ":", elementosEnEsteApartado.map(e => e.name));

              elementosEnEsteApartado.forEach(function (element) {
                  const tipo = element.type;
                  const valor = element.valor || "";
                  const bloque = crearBloqueCampoInformacion(tipo, element, valor);
                  if (bloque) {
                      // Crear contenedor general para el campo + ayuda
                      const bloqueConAyuda = document.createElement("div");
                      bloqueConAyuda.style.display = "flex";
                      bloqueConAyuda.style.flexDirection = "column";
                      bloqueConAyuda.style.alignItems = "flex-start";
                      if (element.type !== "Texto o html (no editable)") {
                          bloqueConAyuda.style.marginBottom = "10px";
                      }

                      bloqueConAyuda.appendChild(bloque);

                      // A√±adir informaci√≥n adicional siempre debajo
                      if (element.informacion && element.informacion.trim() !== "") {
                          const infoDiv = document.createElement("div");
                          infoDiv.innerHTML = element.informacion;
                          infoDiv.style.fontFamily = "Arial";
                          if (tipo!=="Texto o html (no editable)"){
                            infoDiv.style.marginTop = "4px";
                            infoDiv.style.fontSize = "13px";
                            infoDiv.style.color = "#555";
                            infoDiv.style.maxWidth = "600px";
                          }
                          infoDiv.style.whiteSpace = "pre-wrap";
                          bloqueConAyuda.appendChild(infoDiv);
                      }

                      infoInputs[element.name] = bloque.querySelector("input, textarea, select, button");
                      contentContainer.appendChild(bloqueConAyuda);
                  }

              });
          });




        //const elementosPorInstancia = elementosRequeridos.filter(e => e.scope === "Uno para cada √≠tem");


        if (elementosPorInstancia.length > 0) {

          const tituloCada = document.createElement("div");
          tituloCada.style.fontFamily = "Arial";
          tituloCada.style.fontSize = "14px";
          tituloCada.style.fontWeight = "bold";
          tituloCada.style.color = color_menu_titles;
          tituloCada.style.padding = "8px";
          tituloCada.style.margin = "20px 0 10px 0";
          tituloCada.textContent = "PARA CADA √çTEM:";
          contentContainer.appendChild(tituloCada);

            const container = document.createElement("div");
            container.style.border = "1px solid #ccc";
            container.style.padding = "8px";
            container.style.margin = "1px 0";
            container.style.borderRadius = "5px";

            const labelSelector = document.createElement("label");
            labelSelector.textContent = "Selecciona √≠tem:";
            labelSelector.style.fontFamily = "Arial";
            labelSelector.style.fontWeight = "bold";
            container.appendChild(labelSelector);

            selector = document.createElement("select");
            selector.style.marginLeft = "10px";
            selector.style.fontFamily = "Arial";

            const defaultOption = document.createElement("option");
            defaultOption.value = "";
            defaultOption.textContent = selectedStepData.multiple_task_following_previous
                ? "-- Selecciona --"
                : "-- Selecciona o a√±ade --";
            selector.appendChild(defaultOption);


            container.appendChild(selector);

            const btnAdd = document.createElement("button");
            btnAdd.textContent = "A√±adir";
            btnAdd.style.marginLeft = "10px";

            const btnDel = document.createElement("button");
            btnDel.textContent = "Eliminar";
            btnDel.style.marginLeft = "5px";

            // Ocultar si la lista viene de otra tarea
            if (selectedStepData.multiple_task_following_previous) {
                btnAdd.style.display = "none";
                btnDel.style.display = "none";
            }

            container.appendChild(btnAdd);
            container.appendChild(btnDel);
            contentContainer.appendChild(container);

            // Input fields por cada tipo, dentro de este contenedor
            inputsContainer = document.createElement("div");
            inputsContainer.style.marginTop = "10px";
            container.appendChild(inputsContainer);




            // Si viene de otra tarea, copiar sus instancias
            const instanciasIgnoradasDeTareaAnterior = new Set();
            if (selectedStepData.multiple_task_following_previous) {
              const stepIdAnterior = selectedStepData.multiple_task_following_previous;
              const tareaAnterior = flowchartData.steps.find(s => s.id === stepIdAnterior);

              if (tareaAnterior && tareaAnterior.infoElementsDataPorInstancia) {
                const nombresInstanciasPrevias = Object.keys(tareaAnterior.infoElementsDataPorInstancia);

                nombresInstanciasPrevias.forEach(nombre => {
                    // Evitar duplicados en el selector
                    const yaExiste = [...selector.options].some(opt => opt.value === nombre);
                    if (yaExiste) return;

                    const datosPrevios = tareaAnterior.infoElementsDataPorInstancia[nombre];
                    const estadoFinalPrevio = datosPrevios?.finalState?.value;

                    // Mostrar solo los que estaban OK en el desplegable
                    if (estadoFinalPrevio === "completed") {
                        const option = document.createElement("option");
                        option.value = nombre;
                        option.text = `${nombre} (de ${tareaAnterior.label})`;
                        selector.appendChild(option);
                    }else{
                      instanciasIgnoradasDeTareaAnterior.add(nombre);
                    }

                    // En cualquier caso, a√±adir a la variable temporal
                    if (!tempInfoElementsDataPorInstancia[nombre]) {
                        tempInfoElementsDataPorInstancia[nombre] = {};
                    }

                    elementosPorInstancia.forEach(e => {
                        const valorPrevio = datosPrevios?.[e.name];
                        if (valorPrevio) {
                            tempInfoElementsDataPorInstancia[nombre][e.name] = JSON.parse(JSON.stringify(valorPrevio));
                        }
                    });

                    if (estadoFinalPrevio === "cancelled") {
                        tempInfoElementsDataPorInstancia[nombre]["finalState"] = JSON.parse(JSON.stringify(datosPrevios.finalState));
                    } else if (!estadoFinalPrevio) {
                        tempInfoElementsDataPorInstancia[nombre]["finalState"] = undefined;
                    }
                });
            }

          }

            // Cargar instancias existentes (solo las que NO provienen de la tarea anterior o ya estaban en el selector)
            const nombresYaCargados = new Set([...selector.options].map(opt => opt.value));
            const instancias = Object.keys(selectedStepData.infoElementsDataPorInstancia || {});

            instancias.forEach(nombre => {
                if (nombresYaCargados.has(nombre)) return;
                if (instanciasIgnoradasDeTareaAnterior.has(nombre)) return; // üëà NO a√±adir si fue ignorada

                const option = document.createElement("option");
                option.value = nombre;
                option.text = nombre;
                selector.appendChild(option);
            });


            actualizarOpcionesSelectorEstado();

            // Redibujar campos al seleccionar instancia
            function renderInputsForItem(nombre) {
                console.log("üü° renderInputsForItem - nombre:", nombre);
                inputsContainer.innerHTML = "";

                if (!nombre) return;

                const estructuraTexto = selectedStepData.estructuraApartados || "";
                console.log("üìÑ Estructura original:\n", estructuraTexto);
                const lineas = estructuraTexto.split("\n").map(l => l.trim()).filter(Boolean);
                console.log("üìö L√≠neas interpretadas:", lineas);

                let rutaActual = [];
                const rutasMostradas = new Set();

                lineas.forEach((linea, i) => {
                    console.log(`üîπ Procesando l√≠nea ${i + 1}: "${linea}"`);
                    let nivel = 0;
                    if (linea.startsWith(">>")) {
                        nivel = 2;
                    } else if (linea.startsWith(">")) {
                        nivel = 1;
                    }

                    const texto = linea.replace(/^>+/, "").trim();

                    // Actualizar ruta actual seg√∫n el nivel
                    rutaActual = rutaActual.slice(0, nivel); // recorta a nivel anterior
                    rutaActual[nivel] = texto;

                    console.log("üìç Ruta actual:", rutaActual);
                    const rutaCompleta = rutaActual.join(">");
                    console.log("üìç Ruta completa:", rutaCompleta);

                    // Buscar elementos en esta ruta
                    const elementos = elementosPorInstancia.filter(e =>
                        (e.scope === "Uno para cada √≠tem") &&
                        e.apartado === rutaCompleta
                    );

                    console.log(`üß© Elementos en ${rutaCompleta} :`, elementos.map(e => e.name));

                    if (elementos.length > 0) {
                        // Mostrar encabezados para todos los niveles previos
                        for (let j = 0; j <= nivel; j++) {
                            const subRuta = rutaActual.slice(0, j + 1).join(">");
                            if (!rutasMostradas.has(subRuta) && rutaActual[j] !== "Sin t√≠tulo") {
                                const header = document.createElement("h5");
                                header.innerHTML = "&nbsp;".repeat(j * 4) + rutaActual[j];
                                header.style.fontFamily = "Arial";
                                header.style.marginTop = j === 0 ? "32px" : "16px";
                                header.style.marginBottom = "12px";
                                header.style.color = color_text_titles;

                                if (j === 0) {
                                    header.style.fontSize = "16px";
                                    header.style.fontWeight = "bold";
                                } else if (j === 1) {
                                    header.style.fontSize = "14px";
                                } else {
                                    header.style.fontSize = "13px";
                                    header.style.fontStyle = "italic";
                                }

                                inputsContainer.appendChild(header);
                                rutasMostradas.add(subRuta);
                                console.log("üì¢ Mostrado encabezado:", subRuta);
                            }
                        }

                        // Mostrar los inputs del apartado
                        elementos.forEach(element => {
                            console.log("üîç Informaci√≥n para", element.name, ":", element.informacion);

                            const valor = tempInfoElementsDataPorInstancia?.[nombre]?.[element.name]?.value || "";
                            const bloque = crearBloqueCampoInformacion(element.type, element, valor, nombre);

                            if (bloque) {
                                // üîÅ Contenedor vertical que envuelve el campo + texto de ayuda
                                const bloqueConAyuda = document.createElement("div");
                                bloqueConAyuda.style.display = "flex";
                                bloqueConAyuda.style.flexDirection = "column";
                                bloqueConAyuda.style.alignItems = "flex-start";
                                if (element.type !== "Texto o html (no editable)") {
                                    bloqueConAyuda.style.marginBottom = "10px";
                                }


                                bloqueConAyuda.appendChild(bloque);

                                if (element.informacion && element.informacion.trim() !== "") {
                                    const infoDiv = document.createElement("div");
                                    infoDiv.innerHTML = element.informacion;
                                    infoDiv.style.fontFamily = "Arial";
                                    if (element.type!=="Texto o html (no editable)"){
                                      infoDiv.style.marginTop = "4px";
                                      infoDiv.style.fontSize = "13px";
                                      infoDiv.style.color = "#555";
                                      infoDiv.style.maxWidth = "600px";
                                    }
                                    infoDiv.style.whiteSpace = "pre-wrap";
                                    bloqueConAyuda.appendChild(infoDiv);
                                }

                                inputsContainer.appendChild(bloqueConAyuda);
                            }
                        });




                    }
                });

                // Botones finales
                const estadoDiv = document.createElement("div");
                estadoDiv.style.marginTop = "10px";
                estadoDiv.style.marginBottom = "10px";

                const btnOK = document.createElement("button");
                btnOK.innerHTML = "‚úÖ √çtem finalizado";
                btnOK.style.marginRight = "10px";
                btnOK.style.padding = "6px 12px";
                btnOK.style.borderRadius = "4px";
                btnOK.style.fontWeight = "bold";

                btnOK.addEventListener("click", function () {
                    // Guardar los datos antes de validar
                    guardarDatosDeInputs(nombre);

                    const faltan = getElementosObligatoriosNoRellenadosPorInstancia(selectedStepData, nombre);

                    if (faltan.length > 0) {
                        remarcarObligatoriosFaltantesDeInstancia(selectedStepData, nombre); // Para que lo pinte en rojo

                       // const mensaje = faltan.map(f => f.nombre).join("\n");
                       // alert("Faltan campos obligatorios:\n\n" + mensaje);
                        return;
                    }

                    // Si todo bien, marcar como finalizado
                    if (confirm("¬øDeseas marcar esta tarea como completada?")) {
                        if (!tempInfoElementsDataPorInstancia[nombre]) {
                            tempInfoElementsDataPorInstancia[nombre] = {};
                        }
                        tempInfoElementsDataPorInstancia[nombre]["finalState"] = {
                            type: "Estate",
                            value: "completed"
                        };
                        actualizarOpcionesSelectorEstado();
                    }
                });




                const btnCancel = document.createElement("button");
                btnCancel.innerHTML = "‚ùå √çtem cancelado";
                btnCancel.style.padding = "6px 12px";
                btnCancel.style.borderRadius = "4px";
                btnCancel.style.fontWeight = "bold";

                btnCancel.addEventListener("click", function () {
                  if (confirm("¬øDeseas cancelar esta tarea?")) {
                    if (!tempInfoElementsDataPorInstancia[nombre]) {
                        tempInfoElementsDataPorInstancia[nombre] = {};
                    }
                    tempInfoElementsDataPorInstancia[nombre]["finalState"] = {
                        type: "Estate",
                        value: "cancelled"
                    };
                    actualizarOpcionesSelectorEstado();
                }
                });

                estadoDiv.appendChild(btnOK);
                estadoDiv.appendChild(btnCancel);
                inputsContainer.appendChild(estadoDiv);
            }




            function actualizarOpcionesSelectorEstado() {
                [...selector.options].forEach(option => {
                    const nombre = option.value;
                    if (!nombre || nombre === "") return;

                    const datos = tempInfoElementsDataPorInstancia[nombre];
                    const estado = datos?.["finalState"]?.value || "";
                    const explicacion = datos?.["finalState"]?.explicacion || "";

                    let sufijo = "";
                    if (estado === "completed") sufijo = " ‚úÖ";
                    else if (estado === "cancelled") sufijo = " ‚ùå";

                    option.textContent = nombre + sufijo;

                    // Tooltip solo si hay explicaci√≥n
                    if (estado === "cancelled" && explicacion) {
                        option.title = `Motivo de cancelaci√≥n: ${explicacion}`;
                    } else {
                        option.removeAttribute("title");
                    }
                });
            }



            function guardarDatosDeInputs(nombre) {
                if (!nombre) {
                    console.warn("‚õî Nombre no v√°lido en guardarDatosDeInputs");
                    return;
                }

                console.log(`üîÑ Guardando datos de inputs para la instancia: ${nombre}`);

                // Forzar que todos los campos pierdan el foco para aplicar posibles cambios pendientes
                inputsContainer.querySelectorAll("input, textarea, select").forEach(el => el.blur());

                // Asegurar la estructura de datos temporal
                if (!tempInfoElementsDataPorInstancia[nombre]) {
                    tempInfoElementsDataPorInstancia[nombre] = {};
                    console.log(`üì¶ Se ha creado una nueva entrada vac√≠a para ${nombre}`);
                }

                // Recorremos todos los elementos con data-elementName
                const campos = [...inputsContainer.getElementsByTagName("*")].filter(el => el.dataset?.elementName);
                console.log(`üîç Se han encontrado ${campos.length} campos con data-elementName`);

                console.log("üîç Campos detectados:", campos.map(c => c.dataset.elementName));


                campos.forEach(input => {
                    const elementName = input.dataset.elementName;
                    if (!elementName) {
                        console.warn("‚ùó Campo sin elementName detectado");
                        return;
                    }

                    const elemento = elementosPorInstancia.find(e => e.name === elementName);
                    if (!elemento) {
                        console.warn(`‚ùó No se encontr√≥ el elemento en elementosPorInstancia con name=${elementName}`);
                        return;
                    }

                    const tipo = elemento.type;
                    let valor;

                    if (tipo === "Archivo") {
                        console.log(`üìÅ Procesando archivo para ${elementName}`);
                        if (input?.type === "file" && input.files?.length > 0) {
                            valor = input.files[0].name;
                            console.log(`‚úÖ Archivo desde input: ${valor}`);
                        } else {
                            const contenedor = input?.parentNode || inputsContainer;
                            const spans = contenedor?.querySelectorAll("span");
                            spans?.forEach(s => console.log("üîç span detectado:", s.textContent));

                            // Buscar el span que contenga un texto que parezca un nombre de archivo
                            const labelArchivo = [...spans || []].find(s =>
                                s.textContent?.trim() &&
                                !s.textContent.includes("‚Ä¢") &&
                                !s.textContent.endsWith(":")
                            );

                            valor = labelArchivo?.textContent?.trim() || "";
                            if (valor) {
                                console.log(`‚úÖ Archivo desde label: ${valor}`);
                            } else {
                                console.warn(`‚ö†Ô∏è No se detect√≥ archivo visible para ${elementName}`);
                            }
                        }
                    } else if (tipo === "Check independiente" || tipo === "Check ligado a grupo") {
                        valor = input.checked;
                    } else if (tipo === "Desplegable selecci√≥n m√∫ltiple") {
                        valor = [...input.selectedOptions].map(o => o.value);
                    } else {
                        valor = input.value;
                    }

                    // Guardamos en la estructura temporal
                    tempInfoElementsDataPorInstancia[nombre][elementName] = {
                        type: tipo,
                        value: valor
                    };

                    console.log(`‚úÖ Guardado: ${elementName} =`, valor);
                });

                console.log("üì• Estado final tempInfoElementsDataPorInstancia[nombre]:", tempInfoElementsDataPorInstancia[nombre]);
            }








            selector.addEventListener("change", function () {
                const previousNombre = selector.dataset.previousNombre;
                if (previousNombre) {
                    guardarDatosDeInputs(previousNombre); //  guardar todo lo editado
                }

                selector.dataset.previousNombre = selector.value; // actualizar el nombre actual

                renderInputsForItem(selector.value); // dibujar los inputs del nuevo
                //remarcarObligatoriosFaltantesParaStepCompleto(selectedStepData, selector.value);

            });

            function remarcarObligatoriosFaltantesParaStepCompleto(stepData, nombreInstancia = null) {
                const faltan = getElementosObligatoriosNoRellenadosParaStepCompleto(stepData)
                    .filter(f => !nombreInstancia || !f.instancia || f.instancia === nombreInstancia);

                console.log(`üß™ Validando campos obligatorios para instancia: ${nombreInstancia || "(global y activa)"}`);
                console.log("‚ùó Elementos no rellenados:", faltan);

                if (faltan.length > 0) {
                    const fechaInput = document.getElementById("fechaFin");
                    if (fechaInput) {
                        fechaInput.value = "";
                        console.log("üóë Fecha eliminada por campos obligatorios sin rellenar");
                    }

                    marcarLabelsEnRojo(faltan);
                    alert("Faltan campos obligatorios:\n\n" + generarMensajeFaltantes(faltan));
                    return false;
                }

                return true;
            }

            function remarcarObligatoriosFaltantesDeInstancia(stepData, nombreInstancia) {
                const faltan = getElementosObligatoriosNoRellenadosPorInstancia(stepData, nombreInstancia);

                console.log(`üß™ Validando solo instancia: ${nombreInstancia}`);
                console.log("‚ùó Elementos no rellenados:", faltan);

                if (faltan.length > 0) {
                    marcarLabelsEnRojo(faltan);
                    alert("Faltan campos obligatorios:\n\n" + generarMensajeFaltantes(faltan));
                    return false;
                }

                return true;
            }

            function marcarLabelsEnRojo(faltan) {
                faltan.forEach(({ nombre, instancia }) => {
                    const clave = instancia ? `${nombre}|||${instancia}` : nombre;
                    const label = labelsPorNombreYInstancia[clave];

                    if (label) {
                        label.classList.add("label-error");
                        console.log(`üî¥ Label marcado en rojo: ${clave}`);
                    } else {
                        console.warn(`‚ö†Ô∏è No se encontr√≥ label para: ${clave}`);
                    }

                    const input = instancia
                        ? document.querySelector(`[data-elementname="${nombre}"][data-instancia="${instancia}"]`)
                        : infoInputs[nombre];

                   if (input) {
                    const limpiarError = () => {
                        const claveLimpieza = instancia ? `${nombre}|||${instancia}` : nombre;
                        const labelLimpieza = labelsPorNombreYInstancia[claveLimpieza];
                        if (labelLimpieza) {
                            labelLimpieza.classList.remove("label-error");
                            console.log(`‚úÖ Eliminado error visual de: ${claveLimpieza}`);
                        }
                    };

                    input.addEventListener("input", limpiarError, { once: true });
                    input.addEventListener("change", limpiarError, { once: true });
                }

                });
            }

            function generarMensajeFaltantes(faltan) {
                return faltan.map(({ nombre, instancia }) =>
                    instancia ? `${nombre} (instancia: ${instancia})` : nombre
                ).join("\n");
            }








            btnAdd.addEventListener("click", function () {
              const selectedNombre = selector.value;
              if (selectedNombre) {
                  guardarDatosDeInputs(selectedNombre);
              }

              const miniDialog = document.createElement("div");
              miniDialog.style.position = "fixed";
              miniDialog.style.left = "50%";
              miniDialog.style.top = "50%";
              miniDialog.style.transform = "translate(-50%, -50%)";
              miniDialog.style.backgroundColor = "white";
              miniDialog.style.border = "1px solid #ccc";
              miniDialog.style.borderRadius = "6px";
              miniDialog.style.padding = "20px";
              miniDialog.style.fontFamily = "Arial";
              miniDialog.style.zIndex = "1000";
              miniDialog.style.boxShadow = "0px 4px 10px rgba(0,0,0,0.2)";

              const title = document.createElement("p");
              title.textContent = "Nombre del nuevo √≠tem";
              title.style.fontSize = "14px";
              title.style.fontWeight = "bold";
              title.style.marginBottom = "10px";
              miniDialog.appendChild(title);

              const inputNombre = document.createElement("input");
              inputNombre.type = "text";
              inputNombre.placeholder = "Escribe un nombre";
              inputNombre.style.fontFamily = "Arial";
              inputNombre.style.fontSize = "14px";
              inputNombre.style.padding = "6px";
              inputNombre.style.width = "260px";
              inputNombre.style.marginBottom = "10px";
              inputNombre.style.border = "1px solid #ccc";
              inputNombre.style.borderRadius = "4px";
              miniDialog.appendChild(inputNombre);
              miniDialog.appendChild(document.createElement("br"));

              const btnAceptarNuevo = document.createElement("button");
              btnAceptarNuevo.textContent = "Aceptar";
              btnAceptarNuevo.style.fontFamily = "Arial";
              btnAceptarNuevo.style.fontSize = "14px";
              btnAceptarNuevo.style.marginRight = "10px";
              btnAceptarNuevo.style.padding = "6px 12px";
              btnAceptarNuevo.style.borderRadius = "4px";

              const btnCancelarNuevo = document.createElement("button");
              btnCancelarNuevo.textContent = "Cancelar";
              btnCancelarNuevo.style.fontFamily = "Arial";
              btnCancelarNuevo.style.fontSize = "14px";
              btnCancelarNuevo.style.padding = "6px 12px";
              btnCancelarNuevo.style.borderRadius = "4px";

              miniDialog.appendChild(btnCancelarNuevo);
              miniDialog.appendChild(btnAceptarNuevo);

              document.body.appendChild(miniDialog);

              btnAceptarNuevo.addEventListener("click", function () {
                  const nuevo = inputNombre.value.trim();
                  if (!nuevo) {
                      alert("El nombre no puede estar vac√≠o.");
                      return;
                  }
                  if ([...selector.options].some(o => o.value === nuevo)) {
                      alert("Ese nombre ya existe.");
                      return;
                  }

                  // A√±adir al selector y preseleccionar
                  const option = document.createElement("option");
                  option.value = nuevo;
                  option.textContent = nuevo;
                  selector.appendChild(option);
                  selector.value = nuevo;

                  // A√ëADIR VAC√çO a la variable temporal aunque no se rellenen los campos
                  if (!tempInfoElementsDataPorInstancia[nuevo]) {
                      tempInfoElementsDataPorInstancia[nuevo] = {};
                  }

                  // Disparar el cambio para renderizar los inputs
                  setTimeout(() => {
                        selector.dispatchEvent(new Event("change"));
                    }, 0);


                  document.body.removeChild(miniDialog);
              });

              btnCancelarNuevo.addEventListener("click", function () {
                  document.body.removeChild(miniDialog);
              });
          });




          btnDel.addEventListener("click", function () {
            const val = selector.value;
            if (!val) return;

            if (confirm(`¬øEliminar '${val}'?`)) {
                // Eliminar la opci√≥n del selector
                [...selector.options].forEach(opt => {
                    if (opt.value === val) selector.removeChild(opt);
                });

                // Eliminar de la copia temporal
                delete tempInfoElementsDataPorInstancia[val];

                // Tambi√©n, si hay tablas por instancia, eliminarlas si existen
                if (tempTablasGenerales) {
                    elementosPorInstancia.forEach(e => {
                        if (tempTablasGenerales[e.name] &&
                            tempTablasGenerales[e.name][val]) {
                            delete tempTablasGenerales[e.name][val];
                        }
                    });
                }

                // Limpiar los inputs
                selector.value = "";
                selector.dataset.previousNombre = "";
                inputsContainer.innerHTML = "";
            }

        });


          }

          contentContainer.appendChild(document.createElement("br"));
          contentContainer.appendChild(crearSeparadorSeccion("ESTADO DE LA TAREA"));
          // Mostrar "Notas:" en una l√≠nea nueva
          var notesLabel = document.createElement("label");
      notesLabel.for = "notas";
      notesLabel.style.verticalAlign = "top";
      notesLabel.style.fontFamily = "Arial";
      notesLabel.style.fontSize = "14px";
      notesLabel.textContent = "Notas: ";
      notesLabel.style.fontWeight = "bold";
      contentContainer.appendChild(notesLabel);

      var notesExpLabel = document.createElement("label");
      notesExpLabel.for = "explicaci√≥n notas";
      notesExpLabel.style.verticalAlign = "top";
      notesExpLabel.style.fontFamily = "Arial";
      notesExpLabel.style.fontSize = "14px";
      notesExpLabel.textContent = "Poner informaci√≥n √∫til del estado actual, p.ej. si se encuentra pendiente de otra acci√≥n. Dejar vac√≠o si est√° en proceso normalmente. Para v√≠nculo a archivo cargado poner /*nombrearchivo*/. Esta nota se borrar√° autom√°ticamente al finalizar la tarea.";
      contentContainer.appendChild(notesExpLabel);
      contentContainer.appendChild(document.createElement("br"));

        // Mostrar el campo de notas en una l√≠nea nueva
        var notesTextarea = document.createElement("textarea");
      notesTextarea.id = "notas";
      notesTextarea.rows = "10";
      notesTextarea.cols = "65";
      notesTextarea.style.fontFamily = "Arial";
      notesTextarea.style.overflowY = "auto"; // A√±ade la barra de desplazamiento si es necesario
      notesTextarea.style.maxHeight = "50px"; // Altura m√°xima antes de mostrar la barra de desplazamiento
      notesTextarea.textContent = notes;
      contentContainer.appendChild(notesTextarea);
      contentContainer.appendChild(document.createElement("br"));
    
      
        }




        if ((tipo==='step')&&(!modoProcesosGenerales)){
      

      // Agregar un retorno de carro
      contentContainer.appendChild(document.createElement("br"));

const fechaWrapper = document.createElement("div");
fechaWrapper.style.display = "flex";
fechaWrapper.style.alignItems = "center";
fechaWrapper.style.marginBottom = "8px";

const validacionOK = document.createElement("span");
validacionOK.id = "iconoValidacionFecha";
validacionOK.textContent = "‚úÖ";
validacionOK.style.color = "green";
validacionOK.style.fontWeight = "bold";
validacionOK.style.marginRight = "6px";

const fechafinLabel = document.createElement("label");
fechafinLabel.textContent = "Fecha en que la tarea ha finalizado:";
fechafinLabel.setAttribute("for", "fechaFin");
fechafinLabel.style.fontFamily = "Arial";
fechafinLabel.style.fontSize = "14px";
fechafinLabel.style.fontWeight = "bold";
fechafinLabel.style.marginRight = "8px";

fechafinSelect = document.createElement("input");
fechafinSelect.type = "date";
fechafinSelect.id = "fechaFin";
fechafinSelect.value = fechafin;
fechafinSelect.style.fontSize = "14px";

fechaWrapper.appendChild(validacionOK);
fechaWrapper.appendChild(fechafinLabel);
fechaWrapper.appendChild(fechafinSelect);
contentContainer.appendChild(fechaWrapper);



fechafinSelect.addEventListener("change", () => {
    const valor = fechafinSelect.value;
    if (esFechaValida(valor) && valor !== "") {
        console.log("üìÖ Fecha v√°lida introducida, activando validaci√≥n visual");

        const instanciaActiva = selector?.value;
        if (instanciaActiva) {
            guardarDatosDeInputs(instanciaActiva);
        }

        remarcarObligatoriosFaltantesParaStepCompleto(selectedStepData);
    }
});

/* //El selector de fechas ya tiene dentro un Borrar fecha.
var borrarFechaButton = document.createElement("button");
borrarFechaButton.textContent = "Borrar fecha";
borrarFechaButton.addEventListener("click", function() {
  // Borra la selecci√≥n de fecha
  fechafinSelect.value = "";
});

contentContainer.appendChild(borrarFechaButton);
*/
contentContainer.appendChild(document.createElement("br"));
contentContainer.appendChild(document.createElement("br"));

  }

        var btnAceptar = document.createElement("button");
        btnAceptar.textContent = "Aceptar";
        btnAceptar.style.position = "absolute";
        btnAceptar.style.bottom = "10px";
        btnAceptar.style.right = "90px";
        const originalAceptar = btnAceptar.onclick || (() => {});
        btnAceptar.addEventListener("click", function () {
            var selectedStepData = flowchartData.steps.find(function (step) {
                return step.id === selectedStep[0];
            });

            if (selectedStepData) {
                if (tipo === "step") {
                    var notas = document.getElementById("notas").value;
                    if (!modoProcesosGenerales) {
                        selectedStepData.notas = notas;
                        selectedStepData.fechafin = fechaFin.value;

                        if (!esFechaValida(fechafinSelect.value)) {
                            delete selectedStepData.fechafin;
                        }
                    }

                    if (!selectedStepData.infoElements) {
                        selectedStepData.infoElements = [];
                    }

                    // Volcar los datos temporales de tablas generales a selectedStepData.tabla
                    if (!selectedStepData.tabla) selectedStepData.tabla = {};
                    Object.keys(tempTablasGenerales).forEach(nombre => {
                        selectedStepData.tabla[nombre] = JSON.parse(JSON.stringify(tempTablasGenerales[nombre]));
                    });

                    // Mapeamos cada elemento requerido, guardando adem√°s el valor obtenido de los inputs
                    selectedStepData.infoElements = elementosRequeridos.map(function (element) {
                        let obj = {
                            name: element.name,
                            type: element.type,
                            scope: element.scope,
                            apartado: element.apartado || "(Seleccionar apartado)"
                        };

                        const input = infoInputs[element.name];

                        if (element.type === "Archivo") {
                            if (input && input.type === "file" && input.files.length > 0) {
                                obj.valor = input.files[0].name;
                            } else {
                                obj.valor = element.valor || "";
                            }
                        } else if (element.type === "Tabla") {
                            if (element.opciones) obj.opciones = [...element.opciones];
                            if (element.tabla) obj.tabla = JSON.parse(JSON.stringify(element.tabla));
                        } else if (element.type === "Check independiente") {
                            obj.valor = !!input?.checked; // ‚úÖ guardamos true/false real
                        } else if (element.type === "Check ligado a grupo") {
                            if (input?.type === "checkbox") {
                            // caso de checkbox individual
                            obj.valor = !!input.checked;
                            } else {
                                // caso de contenedor con varios checkboxes
                                const checkboxes = input?.querySelectorAll("input[type='checkbox']");
                                const marcados = [];
                                checkboxes?.forEach(chk => {
                                    if (chk.checked) marcados.push(chk.value);
                                });
                                obj.valor = marcados;
                            }

                        } else if (element.type === "Desplegable selecci√≥n m√∫ltiple") {
                            const seleccionados = [...input?.selectedOptions || []].map(opt => opt.value);
                            obj.valor = seleccionados;
                            if (element.opciones) obj.opciones = [...element.opciones];
                        } else if (element.type === "Coordenadas WGS84") {
                            const lat = input?.querySelector("input[data-coord='lat']")?.value || "";
                            const lon = input?.querySelector("input[data-coord='lon']")?.value || "";
                            obj.valor = { lat, lon };
                        } else if (element.type === "Texto o html (no editable)") {
                            obj.valor = element.valor || "";
                        } else {
                            // Otros casos: texto, n√∫mero, ocultado, NIF, IBAN, localidad, etc.
                            obj.valor = input?.value || "";
                            if (element.type === "Desplegable selecci√≥n √∫nica" && Array.isArray(element.opciones)) {
                                obj.opciones = [...element.opciones];
                            }
                        }


                        return obj;
                    });

                    // NUEVO BLOQUE: Guardar en selectedStepData.valor los valores reales de cada elemento
                    if (!selectedStepData.valor) {
                        selectedStepData.valor = {};
                    }
                    selectedStepData.infoElements.forEach(function (element) {
                        selectedStepData.valor[element.name] = element.valor;
                    });

                    // ‚úÖ Guardar el contenido del √∫ltimo elemento seleccionado (incluso si no se cambi√≥ la selecci√≥n)
                    if (selector && selector.value && inputsContainer) {
                        guardarDatosDeInputs(selector.value);
                    }

                    // Si hay fecha de finalizaci√≥n, hacer comprobaci√≥n:
                    const inputFecha = document.getElementById("fechafinSelect");
                    if (esFechaValida(fechafinSelect.value) && fechafinSelect.value !== "") {
                        const todoOk = remarcarObligatoriosFaltantesParaStepCompleto(selectedStepData);
                        if (!todoOk) return; // ‚õî No continuar si hay errores
                    }

                    // ‚úÖ Volcar los datos por instancia actualizados
                    selectedStepData.infoElementsDataPorInstancia = JSON.parse(JSON.stringify(tempInfoElementsDataPorInstancia));
                }
            }

            if (tipo === "step" && esFechaValida(fechafinSelect.value) && fechafinSelect.value !== "") {
                const todoOk = remarcarObligatoriosFaltantesParaStepCompleto(selectedStepData);
                if (!todoOk) return;

                activarMilestones(selectedStepData.id, flowchartData);
            }

            document.body.removeChild(dialogDiv);
            drawFlowchart();
        });





        var btnCancelar = document.createElement("button");
  btnCancelar.textContent = "Cancelar";
  btnCancelar.style.position = "absolute";
  btnCancelar.style.bottom = "10px";
  btnCancelar.style.right = "10px"; // Mover a la esquina inferior derecha

  // Manejador de eventos para el bot√≥n "Cancelar"
  btnCancelar.addEventListener("click", function () {
      // Cerrar el cuadro de di√°logo sin guardar los datos
      document.body.removeChild(dialogDiv);
  });

        // Botones de aceptar y cancelar en la parte inferior
        var buttonsContainer = document.createElement("div");
        buttonsContainer.style.display = "flex";
        buttonsContainer.style.justifyContent = "flex-end";
        buttonsContainer.style.gap = "10px";
        buttonsContainer.style.borderTop = "1px solid #ccc";
        buttonsContainer.style.paddingTop = "10px";
        buttonsContainer.style.marginTop = "10px";

        // Estilo limpio para botones
        btnAceptar.style.position = "static";
        btnAceptar.style.margin = "0";
        btnCancelar.style.position = "static";
        btnCancelar.style.margin = "0";

        buttonsContainer.appendChild(btnCancelar);
        buttonsContainer.appendChild(btnAceptar);
        dialogDiv.appendChild(buttonsContainer);
    }


      function getElementosObligatoriosNoRellenadosParaStepCompleto(stepData) {
          if (!stepData || !stepData.infoElements) return [];

          const faltan = [];

          // 1. Comprobar campos "Uno para todos los √≠tems"
          stepData.infoElements.forEach(element => {
              let esObligatorio = element.optional !== true;
              if (element.type === "Texto o html (no editable)") esObligatorio = false;
              if (!esObligatorio || element.scope === "Uno para cada √≠tem") return;

              const valor = element.valor;
              const estaVacio =
                  valor === null || valor === undefined || valor === "" ||
                  (element.type === "Check independiente" && valor !== true) ||
                  (typeof valor === "object" && Object.keys(valor).length === 0);

              if (estaVacio) {
                  faltan.push({ nombre: element.name, instancia: null });
              }
          });

          // 2. Comprobar campos "Uno para cada √≠tem"
          const datosPorInstancia = tempInfoElementsDataPorInstancia || {};
          const nombresInstancias = Object.keys(datosPorInstancia);

          nombresInstancias.forEach(instancia => {
              const datos = datosPorInstancia[instancia];
              const finalState = datos?.finalState;
              const instanciaCancelada = finalState?.value === "cancelled";
              if (instanciaCancelada) return;

              const faltantesInstancia = getElementosObligatoriosNoRellenadosPorInstancia(stepData, instancia);
              faltan.push(...faltantesInstancia);
          });

          return faltan;
      }

            function getElementosObligatoriosNoRellenadosPorInstancia(stepData, nombreInstancia) {
                const faltantes = [];
                const datosInstancia = tempInfoElementsDataPorInstancia?.[nombreInstancia] || {};

                // Agrupar elementos por tipo y grupo
                const checksLigadosPorGrupo = {};

                (stepData.infoElements || []).forEach(element => {
                    if (element.scope !== "Uno para cada √≠tem") return;
                    if (element.optional === true) return;
                    if (element.type === "Texto o html (no editable)") return;

                    const tipo = element.type;
                    const nombre = element.name;
                    const valor = datosInstancia[nombre]?.value;

                    if (tipo === "Check ligado a grupo") {
                        const grupo = element.apartado || "__sinGrupo";
                        if (!checksLigadosPorGrupo[grupo]) {
                            checksLigadosPorGrupo[grupo] = [];
                        }
                        checksLigadosPorGrupo[grupo].push({ nombre, valor });
                        return;
                    }

                    const estaVacio =
                        valor === undefined ||
                        valor === null ||
                        valor === "" ||
                        (element.type === "Check independiente" && valor !== true) ||
                        (Array.isArray(valor) && valor.length === 0) ||
                        (typeof valor === "object" && valor.lat === "" && valor.lon === "");

                    if (estaVacio) {
                        faltantes.push({ nombre, instancia: nombreInstancia });
                    }
                });

                // Validar los grupos de checks ligados
                for (const grupo in checksLigadosPorGrupo) {
                    const items = checksLigadosPorGrupo[grupo];
                    const algunoMarcado = items.some(i => i.valor === true || i.valor === "true");

                    if (!algunoMarcado) {
                        items.forEach(i => {
                            faltantes.push({ nombre: i.nombre, instancia: nombreInstancia });
                        });
                    }
                }

                return faltantes;
            }



function registrarLimpiezaDeErrores(input, nombre, instancia = null) {
    const clave = instancia ? `${nombre}|||${instancia}` : nombre;
    const label = labelsPorNombreYInstancia[clave];

    if (!label) return;

    const limpiar = () => {
        // Si no es Check ligado a grupo, simplemente limpiar este
        const tipo = input.type;
        const isCheckbox = tipo === "checkbox";
        const esCheckLigado = input.dataset?.apartado && isCheckbox;

        if (esCheckLigado) {
            const grupo = input.dataset.apartado;

            const selector = instancia
                ? `input[type="checkbox"][data-apartado="${grupo}"][data-instancia="${instancia}"]`
                : `input[type="checkbox"][data-apartado="${grupo}"]`;

            const relacionados = document.querySelectorAll(selector);

            relacionados.forEach(relatedInput => {
                const nombreRelacionado = relatedInput.dataset.elementname;
                const instanciaRelacionada = relatedInput.dataset.instancia;
                const claveRelacionado = instanciaRelacionada
                    ? `${nombreRelacionado}|||${instanciaRelacionada}`
                    : nombreRelacionado;

                const labelRelacionado = labelsPorNombreYInstancia[claveRelacionado];
                if (labelRelacionado) {
                    labelRelacionado.classList.remove("label-error");
                }
            });
        } else {
            // Normal
            label.classList.remove("label-error");
        }
    };

    input.addEventListener("input", limpiar, { once: true });
    input.addEventListener("change", limpiar, { once: true });
}





function crearBloqueCampoInformacion(tipo, element, valorActual, nombreInstancia = null, todosSonRequeridosPorDefecto = false) {
    const container = document.createElement("div");
    container.style.display = "flex";
    container.style.alignItems = "center";
    container.style.marginBottom = "8px";

    const label = document.createElement("label");

    label.style.fontFamily = "Arial";
    label.style.fontSize = "14px";
    label.style.fontWeight = "bold";
    label.style.marginRight = "10px";

    // üü† Punto delante del t√≠tulo si es obligatorio (no es optional)
    const esRequerido = element.optional !== true;
    if (esRequerido&&(tipo!=="Archivo")) {
        const punto = document.createElement("span");
        punto.innerText = "‚Ä¢ ";
        punto.style.color = color_text_titles;
        label.appendChild(punto);
    }

    let input;




  switch (tipo) {
    case "Texto corto":
    case "Texto ocultado":
    case "Fecha":
    case "Hora":
    case "N√∫mero":
    case "Importe en ‚Ç¨":
    case "Coordenadas WGS84":
    case "NIF":
    case "Cuenta bancaria":
    case "C√≥digo postal":
        label.append(element.name + ":");
        input = document.createElement("input");
        input.type = tipo === "Texto ocultado" ? "password" :
                     tipo === "Fecha" ? "date" :
                     tipo === "Hora" ? "time" :
                     tipo === "N√∫mero" || tipo === "Importe en ‚Ç¨" ? "number" : "text";
        input.style.width = (tipo === "C√≥digo postal") ? "100px" :
                            (tipo === "Cuenta bancaria") ? "300px" :
                            (tipo === "NIF") ? "200px" :
                            (tipo === "Coordenadas WGS84") ? "300px" :
                            "400px";
        input.value = valorActual || "";
        break;

    case "Texto largo":
        label.append(element.name + ":");
        label.style.display = "block";
        input = document.createElement("textarea");
        input.rows = 3;
        input.cols = 60;
        input.value = valorActual || "";
        container.style.display = "block";
        break;

    case "Porcentaje":
        label.append(element.name + " (%):");
        input = document.createElement("input");
        input.type = "number";
        input.min = 0;
        input.max = 100;
        input.step = 0.01;
        input.style.width = "100px";
        input.value = valorActual || "";
        break;

    case "Check independiente":
    case "Check ligado a grupo":
        label.textContent = " " + element.name + ".";
        input = document.createElement("input");
        input.type = "checkbox";
        input.checked = valorActual === true || valorActual === "true";
        if (tipo === "Check ligado a grupo") {
            const apartado = element.apartado || "";
            input.dataset.apartado = apartado;

            input.addEventListener("change", () => {
                if (input.checked) {
                    const allInputs = document.querySelectorAll(`input[type="checkbox"][data-apartado="${apartado}"]`);

                    allInputs.forEach(chk => {
                        if (chk !== input) chk.checked = false;
                    });

                    // üîÑ Tambi√©n eliminar marcas de error en todos los labels del grupo
                    allInputs.forEach(chk => {
                        const nombre = chk.dataset.elementname;
                        const instancia = chk.dataset.instancia;
                        const clave = instancia ? `${nombre}|||${instancia}` : nombre;
                        const label = labelsPorNombreYInstancia?.[clave];
                        if (label) {
                            label.classList.remove("label-error");
                            console.log(`üü¢ Limpieza de error para check ligado: ${clave}`);
                        }
                    });
                }
            });
        }

        input.dataset.elementName = element.name;
        if (nombreInstancia) {
            input.dataset.instancia = nombreInstancia;
        }

        // üëâ Registrar label ANTES de registrar listeners
        const claveCheck = nombreInstancia ? `${element.name}|||${nombreInstancia}` : element.name;
        labelsPorNombreYInstancia[claveCheck] = label;
        console.log("üìå Registrado label para clave:", claveCheck);

        // üîÅ Si es 'Check ligado a grupo', registrar listeners para todos los del mismo grupo
        if (tipo === "Check ligado a grupo") {
            input.addEventListener("change", () => {
                const grupo = element.apartado || "";
                const relacionados = document.querySelectorAll(`input[type="checkbox"][data-apartado="${grupo}"]`);
                relacionados.forEach(chk => {
                    const nombre = chk.dataset.elementName;
                    const instancia = chk.dataset.instancia;
                    const clave = instancia ? `${nombre}|||${instancia}` : nombre;
                    const lbl = labelsPorNombreYInstancia[clave];
                    if (lbl) {
                        lbl.classList.remove("label-error");
                        console.log(`üü¢ Limpieza grupo ligado: ${clave}`);
                    }
                });
            });
        } else {
            // üëâ Registrar listener normal para eliminar error individual
            registrarLimpiezaDeErrores(input, element.name, nombreInstancia);
        }

        container.appendChild(input);
        container.appendChild(label);
        return container;


    case "Desplegable selecci√≥n √∫nica":
        label.append(element.name + ":");
        input = document.createElement("select");
        (element.opciones || []).forEach(op => {
            const opt = document.createElement("option");
            opt.value = op;
            opt.textContent = op;
            input.appendChild(opt);
        });
        input.value = valorActual || "";
        break;

    case "Desplegable selecci√≥n m√∫ltiple":
        label.append(element.name + " (se pueden seleccionar varios con ctrl+click):");
        input = document.createElement("select");
        input.multiple = true;
        input.style.width = "300px";
        input.style.height = "100px";
        (element.opciones || []).forEach(op => {
            const opt = document.createElement("option");
            opt.value = op;
            opt.textContent = op;
            if ((valorActual || []).includes(op)) opt.selected = true;
            input.appendChild(opt);
        });
        break;

    case "Archivo":
        const archivoPrevio = valorActual || "";

        label.style.fontFamily = "Arial";
        label.style.fontSize = "14px";
        label.style.fontWeight = "bold";
        label.style.marginRight = "10px";

        if (element.optional !== true) {
            const punto = document.createElement("span");
            punto.innerText = "‚Ä¢ ";
            punto.style.color = color_text_titles;
            label.appendChild(punto);
        }
        label.append(`${element.name}:`);

        const archivoLabel = document.createElement("span");
        archivoLabel.textContent = archivoPrevio ? ` ${archivoPrevio}` : "";
        archivoLabel.style.fontStyle = "italic";
        archivoLabel.style.fontSize = "13px";
        archivoLabel.style.color = "#333";
        archivoLabel.style.marginLeft = "6px";
        archivoLabel.dataset.elementName = element.name;
        if (nombreInstancia) {
            archivoLabel.dataset.instancia = nombreInstancia;
        }

        const btnBorrar = document.createElement("button");
        btnBorrar.textContent = "Borrar";
        btnBorrar.style.marginLeft = "8px";
        btnBorrar.style.fontSize = "12px";
        btnBorrar.style.padding = "2px 6px";

        function mostrarInputArchivo() {
            input = document.createElement("input");
            input.type = "file";
            input.dataset.elementName = element.name;
            if (nombreInstancia) {
                input.dataset.instancia = nombreInstancia;
            }

            input.addEventListener("change", () => {
                const archivo = input.files?.[0];
                if (archivo) {
                    archivoLabel.textContent = ` ${archivo.name}`;
                    input.remove();
                    container.appendChild(archivoLabel);
                    container.appendChild(btnBorrar);
                    registrarLimpiezaDeErrores(input, element.name, nombreInstancia);
                }
            });

            container.appendChild(input);
        }

        btnBorrar.addEventListener("click", () => {
            archivoLabel.textContent = "";
            if (btnBorrar.parentNode) btnBorrar.remove();
            if (archivoLabel.parentNode) archivoLabel.remove();
            mostrarInputArchivo();
            if (nombreInstancia) {
                delete tempInfoElementsDataPorInstancia?.[nombreInstancia]?.[element.name];
            } else {
                element.valor = "";
            }
        });

        const claveArchivo = nombreInstancia ? `${element.name}|||${nombreInstancia}` : element.name;
        labelsPorNombreYInstancia[claveArchivo] = label;

        container.appendChild(label);
        if (archivoPrevio) {
            container.appendChild(archivoLabel);
            container.appendChild(btnBorrar);
        } else {
            mostrarInputArchivo();
        }
        return container;

    case "Tabla":
        label.append(element.name + ":");
        input = document.createElement("button");
        input.textContent = "Editar tabla";
        input.addEventListener("click", function () {
            openRestrictedTableEditor(element, nombreInstancia, tempInfoElementsDataPorInstancia, tempTablasGenerales, labelsPorNombreYInstancia);
        });
        break;

    case "Localidad":
        label.append(element.name + ":");
        input = document.createElement("select");
        listaLocalidades.forEach(loc => {
            const opt = document.createElement("option");
            opt.value = loc;
            opt.textContent = loc;
            input.appendChild(opt);
        });
        input.value = valorActual || "";
        break;

    case "Texto o html (no editable)":
        const htmlPreview = document.createElement("div");
        htmlPreview.innerHTML = element.valor || "";
        htmlPreview.style.margin = "0";
        htmlPreview.style.padding = "0";
        htmlPreview.style.width = "100%";
        htmlPreview.style.maxWidth = "600px";
        htmlPreview.style.overflowX = "auto";
        htmlPreview.style.whiteSpace = "normal";
        htmlPreview.style.userSelect = "text";
        htmlPreview.style.fontFamily = "Arial";
        htmlPreview.style.fontSize = "14px";

        const reduceMarginsStyle = document.createElement("style");
        reduceMarginsStyle.textContent = `
            .previewHtmlReducido p,
            .previewHtmlReducido h1,
            .previewHtmlReducido h2,
            .previewHtmlReducido h3,
            .previewHtmlReducido h4,
            .previewHtmlReducido h5,
            .previewHtmlReducido h6,
            .previewHtmlReducido ul,
            .previewHtmlReducido ol,
            .previewHtmlReducido li,
            .previewHtmlReducido div {
                margin-top: 2px;
                margin-bottom: 2px;
            }
        `;
        document.head.appendChild(reduceMarginsStyle);
        htmlPreview.classList.add("previewHtmlReducido");

        const claveHTML = nombreInstancia ? `${element.name}|||${nombreInstancia}` : element.name;
        labelsPorNombreYInstancia[claveHTML] = label;

        container.appendChild(htmlPreview);
        container.style.display = "block";
        container.style.marginTop = "0px";
        container.style.marginBottom = "6px";
        return container;

    default:
        return null;
}


    container.appendChild(label);

    if (input) {
        container.appendChild(input);

        if (input.tagName === "INPUT" || input.tagName === "TEXTAREA" || input.tagName === "SELECT") {
            input.dataset.elementName = element.name;
            if (nombreInstancia) {
                input.dataset.instancia = nombreInstancia;
            }
        }

        // üëâ Registrar label ANTES de registrar listeners
        const clave = nombreInstancia ? `${element.name}|||${nombreInstancia}` : element.name;
        labelsPorNombreYInstancia[clave] = label;
        console.log("üìå Registrado label para clave:", clave);

        // Ahora s√≠ es seguro registrar el listener
        if (input.tagName === "INPUT" || input.tagName === "TEXTAREA" || input.tagName === "SELECT") {
            registrarLimpiezaDeErrores(input, element.name, nombreInstancia);
        }

    }
    


    return container;

}

}






function convertLinks(text, basePath) {
    // Expresi√≥n regular para identificar los marcadores
    var regex = /\/\*(.*?)\*\//g;
    // Reemplazar los marcadores por elementos <a>
    return text.replace(regex, function(match, fileName) {
        // Verifica si el texto capturado comienza con "https://"
        if (fileName.startsWith("https://")) {
            return '<a href="' + fileName + '" target="_blank" rel="noopener noreferrer">' + fileName + '</a>';
        } else {
            var url = basePath + "/tareas/" + fileName;
            return '<a href="' + url + '" target="_blank" rel="noopener noreferrer">' + fileName + '</a>';
        }
    });
}
function siguienteTareasPreparadas(idTarea, flowchartData) {
    console.log("üîç Buscando tareas siguientes para:", idTarea);

    const siguientes = [];
    const pathsDesdeTarea = flowchartData.paths.filter(p => p.startStep === idTarea);
    console.log("‚û°Ô∏è Paths desde la tarea:", pathsDesdeTarea);

    for (const path of pathsDesdeTarea) {
        const destino = path.endStep;
        const tareaDestino = flowchartData.steps.find(s => s.id === destino);
        console.log("üéØ Evaluando destino:", destino, "‚Üí", tareaDestino?.label);

        const tareasPrevias = flowchartData.paths
            .filter(p => p.endStep === destino)
            .map(p => p.startStep);

        console.log("üîó Tareas previas que llegan a", destino, ":", tareasPrevias);

        const todasCompletadas = tareasPrevias.every(idPrev => {
            const step = flowchartData.steps.find(s => s.id === idPrev);
            const completada = !!step?.fechafin;
            console.log(`  ‚úÖ ${idPrev} (${step?.label}): completada =`, completada);
            return completada;
        });

        if (todasCompletadas) {
            const fechas = tareasPrevias.map(idPrev => {
                const step = flowchartData.steps.find(s => s.id === idPrev);
                return step?.fechafin;
            }).filter(Boolean);

            const fechaMax = fechas.sort().reverse()[0];
            console.log(`üìÖ Todas completadas. Fecha m√°xima de entrada a ${destino}: ${fechaMax}`);
            siguientes.push({ id: destino, fechaMax });
        } else {
            console.log(`‚õî No se activa ${destino} porque no todas las tareas previas est√°n completadas.`);
        }
    }

    console.log("üìå Tareas siguientes preparadas:", siguientes);
    return siguientes;
}

function activarMilestones(idStep, flowchartData) {
    console.log("üöÄ Ejecutando activarMilestones para:", idStep);
    const siguientes = siguienteTareasPreparadas(idStep, flowchartData);

    siguientes.forEach(({ id, fechaMax }) => {
        const step = flowchartData.steps.find(s => s.id === id);
        if (step?.tipo === "milestone") {
            step.fechafin = fechaMax;
            console.log(`üèÅ Milestone '${step.label}' (${id}) marcado como completado en ${fechaMax}`);
        } else {
            console.log(`‚ÑπÔ∏è Tarea '${step?.label}' (${id}) no es milestone. No se modifica.`);
        }
    });
}





canvas.addEventListener('mousemove', function (event) {
    if (isSelecting) {
        var rect = canvas.getBoundingClientRect();
        var currentX = event.clientX - rect.left;
        var currentY = event.clientY - rect.top;

        // Actualizar las coordenadas del rect√°ngulo
        selectionEnd = { x: currentX, y: currentY };
        drawFlowchart(); // Redraw to show selection box
    }

    if (stepSelected && stepCanMove && dragStart && expiredTime) {
        var rect = canvas.getBoundingClientRect();
        var currentX = event.clientX - rect.left;
        var currentY = event.clientY - rect.top;

        // Calcular desplazamiento
        var dx = currentX - dragStart.x;
        var dy = currentY - dragStart.y;

        // Actualizar las posiciones de las tareas seleccionadas
        flowchartData.steps.forEach(function (step) {
            if (selectedStep.includes(step.id)) {
                var initialPosition = initialPositions.find(pos => pos.id === step.id);
                if (initialPosition) {
                    step.x = initialPosition.x + dx;
                    step.y = initialPosition.y + dy;
                }
            }
        });

        drawFlowchart(); // Redibujar el diagrama con las posiciones actualizadas
    }
});


canvas.addEventListener('mouseup', function () {




    dragStart = null; // Restablecer el punto inicial del movimiento
    initialPositions = []; // Limpiar las posiciones iniciales

    if (isSelecting) {
        isSelecting = false;

        // Obtener el √°rea de selecci√≥n
        var startX = Math.min(selectionStart.x, selectionEnd.x);
        var endX = Math.max(selectionStart.x, selectionEnd.x);
        var startY = Math.min(selectionStart.y, selectionEnd.y);
        var endY = Math.max(selectionStart.y, selectionEnd.y);

        // Seleccionar los pasos dentro del rect√°ngulo
        var newSelection = flowchartData.steps.filter(function (step) {
            return (
                step.x >= startX &&
                step.x <= endX &&
                step.y >= startY &&
                step.y <= endY
            );
        }).map(step => step.id);

        // Si se seleccionaron elementos dentro del √°rea, actualizar la selecci√≥n
        if ((!stepCanMove)&&(newSelection.length > 0)) {
            selectedStep = newSelection;
            //stepSelected = true;
        } else {
            //stepSelected = false;
        }


    }
    if(selectedStep.length>0){
      stepSelected=true;
    }
    drawFlowchart(); // Redibujar el diagrama con los pasos seleccionados

    // L√≥gica para crear un nuevo path al dar dos clics consecutivos
    numClicksAfterCreatePathButton++;
    if(stepSelected&&selectedStep.length===1){              
            if (numClicksAfterCreatePathButton==1){
                NewStepIni=selectedStep[0];
                if(createPathOn){
                document.getElementById("messages").innerHTML = "Haga click en el segundo paso a relacionar";
                }

                //ctx.clearRect(500, 0, 1000, 24);
                //ctx.fillText("Haga click en el segundo proceso", 500, 12);
            }
            if (numClicksAfterCreatePathButton==2){
                NewStepEnd=selectedStep[0];
                if(createPathOn){
                  var PathText="Escriba condici√≥n si debe darse";
                  if(createligtimeOn) PathText="Escriba el plazo m√°ximo";
                  
                    if(createligtimeOn){
                      showPathDialog(true, NewStepIni, NewStepEnd, '', 'ligtime', '', '', '', '', '');
                      //insertarNuevoPath(NewStepIni, NewStepEnd, condicion, 'ligtime');
                      document.getElementById("createLigtimeButton").style.backgroundColor="#4c77af";
                    }else{
                      showPathDialog(true, NewStepIni, NewStepEnd, '', 'path', '', '', '', '', '');
                        //insertarNuevoPath(NewStepIni, NewStepEnd, condicion, 'path');
                        document.getElementById("createPathButton").style.backgroundColor="#4c77af";
                    }
                }
                document.getElementById("messages").innerHTML = "";
                //ctx.clearRect(500, 0, 1000, 24);
                createPathOn=false;
                createligtimeOn=false;
                NewStepIni=null;
                NewStepEnd=null;
            }
        
    }else{
        createPathOn=false;
        createligtimeOn=false;
        NewStepIni=null;
        NewStepEnd=null;
    }
    stepCanMove = false;

    guardarEstado();

    
    console.log("1 selectedPath: "+selectedPath);
    console.log("1 pathSelected: "+pathSelected);
    console.log("1 selectedStep: "+selectedStep);
    console.log("1 stepSelected: "+stepSelected);

});


// Obtener el elemento input.
const inputElement = document.querySelector("#flowChartName");

var valorInputTitulo=inputElement.value;
// Manejador de eventos para la tecla Enter.
inputElement.addEventListener("keyup", event => {
  valorInputTitulo=inputElement.value;
    if(event.key !== "Enter") return;
    doActions();
    inputElement.blur(); // Por ejemplo, hacer que el input pierda el foco.
    event.preventDefault();
});

// Manejador de eventos para el evento blur (perder foco).
inputElement.addEventListener("blur", event => {
  inputElement.value=valorInputTitulo;
    doActions();
});

// Funci√≥n para realizar las acciones deseadas.
function doActions() {
    // Aqu√≠ colocas las acciones que quieres realizar.
    inputElement.value=valorInputTitulo;
    setupFlowChartName();
   
}

        drawFlowchart(); // Initial drawing of the flowchart
    </script>
</body>
</html>