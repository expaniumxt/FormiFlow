<!DOCTYPE html>
<html>
<head>

<script type="text/javascript" src="JS/functions.js"></script>


    <style>
        /* Estilo para los botones */
        .button{

            border: none;
            background-color: #4c77af;
            color: white;
            text-align: center;
            font-size: 12px;
            cursor: pointer;
            padding: 4px 10px;
            margin: 2px;
            text-decoration: none;
            border-radius: 5px;
            height: 30px;
            margin-bottom: 0;
        }
        .button img{  
            height: 18px;
            vertical-align: middle;
            margin-bottom: 0;
        }
        .button-bar {
           /* Estilos para la barra de botones */
           display: flex;
           margin-bottom: 0; 
        }
        /* Estilo para el panel de dibujo de los diagramas de flujo */
        canvas {
            border: 1px solid #000;
        }

        .boton-redondo {
          width: 40px;
          height: 40px;
          border-radius: 50%;
          overflow: hidden;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          background-color: #6ebe92;
          color: white;
          text-align: center;
          text-decoration: none;
          font-weight: bold;
          font-family: Arial, sans-serif;
          cursor: pointer;
          transition: background-color 0.3s;
          position: relative;
          float: right; /* Mueve el botón a la derecha */
          border: none; /* Quita el borde */
          margin-left: 20px;
          margin-bottom: 0;
      }

      .boton-redondo img {
          width: 24px;
          height: 24px;
          object-fit: cover;
          margin-bottom: 0;
      }

      .boton-redondo:hover {
          background-color: #39803c;
          margin-bottom: 0;
      }

      .title-input {
    width: 700px; /* Establece el ancho deseado en píxeles u otra unidad de medida */
    /* Otros estilos que desees aplicar al campo de entrada */
}

/* Establecer el color de fondo para las opciones con cargo asignado */
#rol option.has-cargo {
    background-color: #d2e6da; /* Cambia el color de fondo a tu elección */
}

.fixed-top {
    position: fixed; /* Fija la posición de la barra */
    top: 0;          /* Alinea la barra en la parte superior de la ventana */
    width: 100%;     /* Opcional: Hace que la barra ocupe todo el ancho de la ventana */
    z-index: 1000;   /* Asegura que la barra se muestre sobre otros elementos */
}

  .label-error::after {
    content: " ⚠";
    color: red;
    font-weight: bold;
    margin-left: 4px;
}

.modal {
  position: fixed;
  z-index: 1000;
  left: 0; top: 0;
  width: 100%; height: 100%;
  background-color: rgba(0,0,0,0.5);
  display: flex; align-items: center; justify-content: center;
}

.modal-content {
  background-color: #fff;
  padding: 20px;
  border-radius: 8px;
  max-width: 80vw;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

.close {
  float: right;
  font-size: 1.5rem;
  cursor: pointer;
}





    </style>
</head>
<body>
    <!-- Imagen logo --> 
    <div>
      <img src="media/logo.png" />
    </div>
    <div id="dropdown-container"><!-- Aquí se insertará el menú desplegable de elección de modo --></div>
    <!-- Barra de botones --> 
    <div id="top-fixed-bar">
      <div class="button-bar"> 
        <button id="backButton" class="button" onclick="retroceder()"><img src="media/back.png"  title="Volver atrás"  /></button>
        <button id="forthButton" class="button" onclick="rehacer()"><img src="media/forth.png"  title="Volver adelante"  /></button>
        <button id="saveFlowChart" class="button" onclick="saveFlowChart()"><img src="media/saveFlowChart.png"  title="Guardar proceso"  /></button>
        <button id="loadFlowChart" class="button" onclick="loadFlowChart()"><img src="media/loadFlowChart.png"  title="Cargar/Editar proceso"  /></button>
        <button id="deleteStepOrPathButton" class="button" onclick="deleteStepOrPath()" button.width="20px"><img src="media/deleteStepOrPath.png"  title="Borrar paso o línea"  /></button>
        <button id="createStepButton" class="button" onclick="showStepDialog(true, 'step');"><img src="media/addStep.png"  title="Crear paso"  /></button>
        <button id="createMilestoneButton" class="button" onclick="showStepDialog(true, 'milestone');"><img src="media/addMilestone.png"  title="Crear hito"  /></button>
        <button id="createPathButton" class="button" onclick="createPath('path')"><img src="media/addPath.png"  title="Crear línea"  /></button>
        <button id="createLigtimeButton" class="button" onclick="createPath('ligtime')"><img src="media/addTime.png"  title="Establecer ligadura de tiempo (plazo máximo o mínimo entre tareas"  /></button>
        <button id="reorganizeFlowChartButton" class="button" onclick="reorganizarSteps()"><img src="media/reorganize.png"  title="Reorganizar automáticamente diagrama de flujo"  /></button>
        <button id="saveCanvasImageButton" class="button" oncontextmenu="descargarFlowChart(); return false;"><img src="media/saveImage.png" title="Guardar imagen de diagrama de flujo" />
        <button id="projectDataButton" class="button" onclick="projectDataMenu()"><img src="media/projectData.png"  title="Datos básicos del proyecto"  /></button>
        <button id="projectDataButton" class="button" onclick="mostrarOpcionesVisibilidad()"><img src="media/display.png"  title="Opciones de visibilidad de datos"  /></button>
        <button id="infoButton" class="button"><img src="media/info.png" title="Información sobre el software" /></button>
        <button id="doneButton" class="boton-redondo" onclick="tareaRealizada()"><img src="media/okStep.png"  title="Tarea realizada"  /></button>
        <!-- Modal oculto para información-->
        <div id="licenseModal" class="modal" style="display:none;">
            <div class="modal-content">
                <span id="closeModal" class="close">&times;</span>
                <div id="licenseText" style="max-height:70vh; overflow-y:auto;"></div>
            </div>
        </div>
    </div>
      <div id="messages-bar">
        <!-- barra de mensajes -->
        <p id="messages" style="font-family: Arial; font-size: 16px; color: rgb(50, 170, 158); font-weight: bold; background-color: white;"></p>
      </div>
    </div>
    <!-- Título del gráfico -->
    <div id="flowChartName-bar">
        <input id="flowChartName" type="text"  class="title-input" style="border: 0; font-weight: bold;" maxlength="150">
    </div>
    <!-- Panel de dibujo de los diagramas de flujo --> 
    <canvas id="flowchartCanvas" width="600" height="800"></canvas>

    <script>

        var Ruta = getAbsolutePath();
        console.log("Ruta: "+Ruta);
        var nombreArchivo = "ProyectosDGED.txt";
        var textoArchivo = "archivo de datos de proyectos";
        // Flowchart data

        var flowchartDataGen;

        // Definición de variables globales de visibilidad de elementos
        var mostrar_fecha_inicio = true;
        var mostrar_fecha_fin = true;
        var mostrar_duracion = true;
        var mostrar_rol = true;
        // ESto es para en el futuro poder realizar acciones según permisos:
        var permiso_administrador = true;
        var permiso_usuario = true;

        //Colores:
        const color_menu_titles = "#154360"; // Color títulos de menú // Gris claro:"#ABABAB";
        const color_text_titles = "#5499c7"; // Color títulos de texto
        const color_OK_fondo = "#00c853"; // Color de fondo de tareas OK

        //Municipios:
        const listaLocalidades = [
        "Acebeda, La", "Ajalvir", "Alameda del Valle", "Álamo, El", "Alcalá de Henares", "Alcobendas",
        "Alcorcón", "Aldea del Fresno", "Algete", "Alpedrete", "Ambite", "Anchuelo", "Aranjuez",
        "Arganda del Rey", "Arroyomolinos", "Batres", "Becerril de la Sierra", "Belmonte de Tajo",
        "Berzosa del Lozoya", "Berrueco, El", "Boalo, El", "Braojos", "Brea de Tajo", "Brunete",
        "Buitrago del Lozoya", "Bustarviejo", "Cabanillas de la Sierra", "Cabrera, La", "Cadalso de los Vidrios",
        "Camarma de Esteruelas", "Campo Real", "Canencia", "Carabaña", "Casarrubuelos", "Cenicientos",
        "Cercedilla", "Cervera de Buitrago", "Chapinería", "Chinchón", "Ciempozuelos", "Cobeña",
        "Collado Mediano", "Collado Villalba", "Colmenar de Oreja", "Colmenar del Arroyo", "Colmenar Viejo",
        "Colmenarejo", "Corpa", "Coslada", "Cubas de la Sagra", "Daganzo de Arriba", "Escorial, El",
        "Estremera", "Fresnedillas de la Oliva", "Fresno de Torote", "Fuenlabrada", "Fuente el Saz de Jarama",
        "Fuentidueña de Tajo", "Galapagar", "Garganta de los Montes", "Gargantilla del Lozoya y Pinilla de Buitrago",
        "Gascones", "Getafe", "Griñón", "Guadalix de la Sierra", "Guadarrama", "Hiruela, La", "Horcajo de la Sierra-Aoslos",
        "Horcajuelo de la Sierra", "Hoyo de Manzanares", "Humanes de Madrid", "Leganés", "Loeches", "Lozoya",
        "Lozoyuela-Navas-Sieteiglesias", "Madarcos", "Madrid", "Majadahonda", "Manzanares el Real", "Meco",
        "Mejorada del Campo", "Miraflores de la Sierra", "Molinos, Los", "Molar, El", "Molinos, Los", "Moralzarzal",
        "Moraleja de Enmedio", "Morata de Tajuña", "Móstoles", "Navacerrada", "Navalafuente", "Navalagamella",
        "Navalcarnero", "Navarredonda y San Mamés", "Navas del Rey", "Nuevo Baztán", "Olmeda de las Fuentes",
        "Orusco de Tajuña", "Paracuellos de Jarama", "Parla", "Patones", "Pedrezuela", "Pelayos de la Presa",
        "Perales de Tajuña", "Pezuela de las Torres", "Pinilla del Valle", "Piñuécar-Gandullas", "Pinto",
        "Pozuelo de Alarcón", "Pozuelo del Rey", "Prádena del Rincón", "Puebla de la Sierra", "Puentes Viejas",
        "Quijorna", "Rascafría", "Redueña", "Ribatejada", "Rivas-Vaciamadrid", "Robledillo de la Jara",
        "Robledo de Chavela", "Robregordo", "Rozas de Madrid, Las", "Rozas de Puerto Real", "San Agustín del Guadalix",
        "San Fernando de Henares", "San Lorenzo de El Escorial", "San Martín de la Vega", "San Martín de Valdeiglesias",
        "San Sebastián de los Reyes", "Santa María de la Alameda", "Santorcaz", "Santos de la Humosa, Los",
        "Serna del Monte, La", "Serranillos del Valle", "Sevilla la Nueva", "Somosierra", "Soto del Real",
        "Talamanca de Jarama", "Tielmes", "Titulcia", "Torrejón de Ardoz", "Torrejón de la Calzada",
        "Torrejón de Velasco", "Torrelaguna", "Torrelodones", "Torremocha de Jarama", "Torres de la Alameda",
        "Tres Cantos", "Valdaracete", "Valdeavero", "Valdelaguna", "Valdemanco", "Valdemaqueda", "Valdemorillo",
        "Valdemoro", "Valdeolmos-Alalpardo", "Valdepiélagos", "Valdetorres de Jarama", "Valdilecha", "Valverde de Alcalá",
        "Velilla de San Antonio", "Vellón, El", "Venturada", "Villa del Prado", "Villaconejos", "Villalbilla",
        "Villamanrique de Tajo", "Villamanta", "Villamantilla", "Villanueva de la Cañada", "Villanueva de Perales",
        "Villanueva del Pardillo", "Villar del Olmo", "Villarejo de Salvanés", "Villaviciosa de Odón",
        "Villavieja del Lozoya", "Zarzalejo"
    ];

    const tempElementTextos = {};

    //************ Licencia *********************************************************************************************

document.getElementById("infoButton").addEventListener("click", function () {
  const licenseText = `
  <h2>Formiflow 0.1</h2>
  <h3>Autor: José Antonio Rivero García-Saavedra</h3>
  <p>Esta licencia aplica al software Formiflow 0.1 :
  <h2>Licencia Pública Administrativa (LPA)</h2>
  <h3>Versión de la licencia 1.0</h3>

  <h4>1. Objeto y ámbito de aplicación</h4>
  <p>El presente software es licenciado bajo los términos de la Licencia Pública Administrativa (LPA), cuyo propósito es facilitar su uso, instalación, modificación y redistribución exclusivamente en el ámbito de las Administraciones Públicas, manteniéndose reservados todos los derechos en los demás supuestos.</p>
  <h4>2. Licencia para Administraciones Públicas</h4>
  <p>Se concede a las Administraciones Públicas una licencia gratuita, no exclusiva, mundial y perpetua para:</p>
<ul>
  <li>Usar el software con cualquier fin institucional o administrativo.</li>
  <li>Modificar el software, con obligación de reconocer al autor original y al software base.</li>
  <li>Redistribuir versiones originales o modificadas, exclusivamente dentro del ámbito de otras Administraciones Públicas, con los mismos términos de esta licencia.</li>
</ul>
<p>A efectos de esta licencia, se entiende por "Administración Pública" toda entidad perteneciente al sector público estatal, autonómico, local o institucional (organismos autónomos, entes públicos, etc.).</p>
  <h4>3. Acceso al código por terceros</h4>
  <p>Se permite el acceso público al código fuente del software. Sin embargo:</p>
<ul>
  <li>No se concede ningún derecho de uso, modificación o redistribución a entidades o personas distintas de las Administraciones Públicas, salvo lo dispuesto en los apartados siguientes.</li>
<li>Los terceros podrán instalar el software en nombre de una Administración Pública, o modificarlo para su uso exclusivo en dicha Administración, pero no adquieren por ello ningún derecho de uso, propiedad o explotación sobre el software ni sobre sus versiones modificadas.</li>
<li>Toda modificación deberá mantener el reconocimiento al autor original y no podrá presentarse como una obra completamente nueva o desvinculada.</li>
</ul>
<h4>4. Reconocimiento del autor</h4>
  <p>Cualquier copia, modificación o redistribución del software dentro del ámbito permitido por esta licencia deberá:</p>
<ul>
  <li>Mantener los avisos de autoría originales.</li>
<li>Incluir una mención clara al software base en cualquier documentación o presentación derivada.</li>
</ul>
  <h4>5. Revocación de la licencia</h4>
  <p>Esta licencia podrá considerarse automáticamente revocada en caso de:</p>
<ul>
  <li>Uso malicioso del software para causar daño a terceros.</li>
<li>Incumplimiento de los términos establecidos en esta licencia.</li>
<li>Suplantación de autoría o eliminación del reconocimiento al autor original.</li>
</ul>
<p>La revocación no impide que se exijan responsabilidades legales adicionales.</p>
  <h4>6. Ausencia de garantía</h4>
  <p>Este software se proporciona "tal cual", sin garantías de ningún tipo, expresas o implícitas. El autor no será responsable de daños directos o indirectos derivados del uso del software.</p>

  <h4>7. Ley aplicable y jurisdicción</h4>
  <p>Esta licencia se regirá por la legislación española. Cualquier disputa se someterá a los tribunales de Madrid (España).</p>
  `;

  document.getElementById("licenseText").innerHTML = licenseText;
  document.getElementById("licenseModal").style.display = "flex";
});

document.getElementById("closeModal").addEventListener("click", function () {
  document.getElementById("licenseModal").style.display = "none";
});


//**********************************************************************************************************************************//
// A COMPLETAR CUANDO SE TENGA BACKEND //
function subirArchivoAlBackend(file, proyectoId, tareaId, nombreTarea, nombreElemento) {
    // A completar cuando se tenga backend
    console.log("📤 Subiendo archivo:", file.name);
    console.log("🔗 Proyecto:", proyectoId);
    console.log("🔗 ID tarea:", tareaId);
    console.log("🔗 Nombre tarea:", nombreTarea);
    console.log("🔗 Nombre elemento:", nombreElemento);

    // Aquí iría la llamada fetch, XMLHttpRequest, etc.

    // Simular éxito
    return true;
}

//**********************************************************************************************************************************//



// Función para mostrar el cuadro de diálogo con checkboxes
function mostrarOpcionesVisibilidad() {

  // Verifica si el diálogo ya existe y lo elimina si es así
  var dialogoExistente = document.getElementById('dialogoConfiguracion');
  if (dialogoExistente) {
    document.body.removeChild(dialogoExistente);
  }

  // Crear el diálogo y sus elementos internos, estableciendo el atributo checked dinámicamente
  var dialogo = document.createElement("div");
  dialogo.id = 'dialogoConfiguracion';
  dialogo.innerHTML = `
    <h3>Selecciona las opciones que deseas mostrar</h3>
    <input type="checkbox" id="fecha_inicio" name="fecha_inicio" ${mostrar_fecha_inicio ? 'checked' : ''}>
    <label for="fecha_inicio">Mostrar fecha de inicio</label><br>
    <input type="checkbox" id="fecha_fin" name="fecha_fin" ${mostrar_fecha_fin ? 'checked' : ''}>
    <label for="fecha_fin">Mostrar fecha de fin</label><br>
    <input type="checkbox" id="duracion" name="duracion" ${mostrar_duracion ? 'checked' : ''}>
    <label for="duracion">Mostrar duración</label><br>
    <input type="checkbox" id="responsable" name="responsable" ${mostrar_rol ? 'checked' : ''}>
    <label for="responsable">Mostrar responsable</label><br>
    <div style="text-align: right;">
      <button onclick="actualizarConfiguracion()">Aceptar</button>
    </div>
  `;

  // Estilo básico para el diálogo
  dialogo.style.position = 'fixed';
  dialogo.style.left = '50%';
  dialogo.style.top = '50%';
  dialogo.style.transform = 'translate(-50%, -50%)';
  dialogo.style.backgroundColor = '#fff';
  dialogo.style.padding = '20px';
  dialogo.style.boxShadow = '0 0 10px rgba(0,0,0,0.5)';
  dialogo.style.fontFamily = 'Arial, sans-serif';
  dialogo.style.zIndex = '1000';
  document.body.appendChild(dialogo);
}

// Función para actualizar las variables globales basada en la selección del usuario y cerrar el diálogo
function actualizarConfiguracion() {
  mostrar_fecha_inicio = document.getElementById("fecha_inicio").checked;
  mostrar_fecha_fin = document.getElementById("fecha_fin").checked;
  mostrar_duracion = document.getElementById("duracion").checked;
  mostrar_rol = document.getElementById("responsable").checked;

  // Cerrar el diálogo
  var dialogo = document.getElementById('dialogoConfiguracion');
  if (dialogo) {
    document.body.removeChild(dialogo);
  }
  drawFlowchart();
}


        function getAbsolutePath() {
  
  var loc = window.location;
  console.log("window.location: "+loc);
  var pathName = loc.pathname.substring(0, loc.pathname.lastIndexOf('/'));
  console.log("pathName dentro: "+pathName);
  var pathfinal= loc.href.substring(0, loc.href.length - ((loc.pathname + loc.search + loc.hash).length - pathName.length));
  console.log(pathfinal);
  return pathfinal;

}

        let historial = [];
        let historialRehacer = [];
        function retroceder() {
          if (historial.length > 1) {
           // Mueve el último estado al historial de rehacer
            historialRehacer.push(historial.pop());

            // Restaura el penúltimo estado
            flowchartData = JSON.parse(JSON.stringify(historial[historial.length - 1]));
            drawFlowchart();
          }
        }

        function rehacer() {
          if (historialRehacer.length > 0) {
            // Mueve el último estado del historial de rehacer al historial principal
            let estado = historialRehacer.pop();
            historial.push(estado);

            // Aplica el estado re-hecho
            flowchartData = JSON.parse(JSON.stringify(estado));
            drawFlowchart();
          }
        }

        function guardarEstado() {
          console.log("longitud antes: "+historial.length);
          // Comprueba si la pila ya tiene elementos
          if (historial.length > 0) {
            // Compara el estado actual con el último estado guardado
            // Utiliza JSON.stringify para comparar los objetos como cadenas
            console.log(JSON.stringify(flowchartData));
            console.log(JSON.stringify(historial[historial.length - 1]));
            if (JSON.stringify(flowchartData) === JSON.stringify(historial[historial.length - 1])) {
              console.log("Es igual!!");
            return; 
            }
          }
          // Guarda el estado si la pila está vacía o si el estado ha cambiado
          if (historial.length >= 20) {
            historial.shift(); // Elimina el estado más antiguo si se excede el límite
          }
          console.log("PUSH: "+JSON.stringify(flowchartData));
          historial.push(JSON.parse(JSON.stringify(flowchartData))); // Guarda una copia profunda
          console.log("longitud despues: "+historial.length);
        }






        window.addEventListener('scroll', function() { // Si la barra de botones llega a la parte superior de la pantalla, la bloqueamos.
          var topBar = document.getElementById('top-fixed-bar');
          var offset = topBar.offsetTop;

          if (window.pageYOffset > offset) {
            topBar.classList.add('fixed-top');
          } else {
            topBar.classList.remove('fixed-top');
          }
        });
        var flowchartData={
			    title: "Nombre del proceso"
        };
        var selectedStep = []; // Ahora es un array para selección múltiple
        var isSelecting = false;
        var selectionStart = { x: 0, y: 0 };
        var selectionEnd = { x: 0, y: 0 };
        var selectedPath = null;
        var stepSelected=false;
        var pathSelected=false;
        var numClicksAfterCreatePathButton=0;
        var NewStepIni=null;
        var NewStepEnd=null;
        var createPathOn=false;
        var createligtimeOn=false;
        let expiredTime = true;
        let stepCanMove = true;
        var modoProcesosGenerales = false;

        var dragStart = null; // Guarda el punto inicial del movimiento
        var initialPositions = []; // Guarda las posiciones iniciales de las tareas seleccionadas



// Función para crear el desplegable de elección de Modo:
function crearDesplegable() {
  // Crear la etiqueta del desplegable
  var label = document.createElement('label');
  label.textContent = 'Modo: ';
  label.htmlFor = 'modo-select';
  label.style.fontSize = '12px';
  label.style.fontFamily = 'Arial, sans-serif';

  // Crear el desplegable
  var select = document.createElement('select');
  select.id = 'modo-select';
  select.style.fontSize = '12px';

  // Opción "Seguimiento de proyectos"
  var opcion1 = document.createElement('option');
  opcion1.value = 'seguimiento_proyectos';
  opcion1.textContent = 'Seguimiento de proyectos';
  opcion1.selected = true; // Esta opción estará seleccionada por defecto

  // Opción "Gestión de procesos generales"
  var opcion2 = document.createElement('option');
  opcion2.value = 'gestion_procesos_generales';
  opcion2.textContent = 'Gestión de procesos generales';

  // Agregar las opciones al desplegable
  select.appendChild(opcion1);
  select.appendChild(opcion2);

 // Asignar el evento de cambio al select 
 select.addEventListener('change', function() {
    // Actualizar la variable global según la selección
    modoProcesosGenerales = this.value === 'gestion_procesos_generales';
    // Mostrar u ocultar botón de datos del proyecto:
    var boton = document.getElementById('projectDataButton');
    if (modoProcesosGenerales) {
      boton.style.display = 'none'; // Oculta el botón
      textoArchivo = "archivo de procesos generales";
      nombreArchivo = "ProcesosGlobales.txt";
    } else {
      boton.style.display = 'block'; // Muestra el botón
      textoArchivo = "archivo de datos de proyectos";
      nombreArchivo = "ProyectosDGED.txt";
    }
    // Cambiar el color de fondo si es necesario
    this.style.backgroundColor = modoProcesosGenerales ? 'yellow' : '';
    drawFlowchart();
  });


  // Obtener el contenedor y agregar la etiqueta y el desplegable
  var container = document.getElementById('dropdown-container');
  container.appendChild(label);
  container.appendChild(select);
}

// Ejecutar la función para crear el desplegable
crearDesplegable();


        function descargarFlowChart(){ //Función temporal que deberá ser eliminada
  // Supongamos que flowchartData es la variable que contiene los datos del gráfico de flujo

    // Convertir el objeto flowchartData a una cadena JSON
    var dataString = JSON.stringify(historial, null, 2);

    // Crear un objeto Blob con los datos en formato JSON
    var blob = new Blob([dataString], { type: 'text/plain' });

    // Crear un elemento <a> para el enlace de descarga
    var a = document.createElement('a');
    a.href = window.URL.createObjectURL(blob);
    
    // Asignar un nombre de archivo para el archivo de texto
    a.download = 'flowchartData.txt';

    // Agregar el elemento <a> al DOM
    document.body.appendChild(a);

    // Simular un clic en el enlace para iniciar la descarga
    a.click();

    // Eliminar el elemento <a> del DOM después de la descarga
    window.URL.revokeObjectURL(a.href);
    document.body.removeChild(a);
        }



function interpretarApartado(linea) {
    return (linea === "") ? "(Sin título)" : linea;
}

function projectDataMenu() {
    var dialog = document.createElement("dialog");

    // Obtener roles únicos de flowchartData.steps
    var rolesUnicos = [...new Set(flowchartData.steps.map(step => step.rol))];

    var selectOptions = '';
    // Crear opciones para el desplegable de rol
    rolesUnicos.forEach(rol => {
        selectOptions += `<option value="${rol}">${rol}</option>`;
    });

    // Crear una lista de cargos y nombres
    var cargoNombreList = [
        { cargo: "DGED", nombre: "Ignacio Azorín" },
        { cargo: "SGTD", nombre: "Patricia Lázaro" },
        { cargo: "JATD", nombre: "José Antonio Rivero" },
        { cargo: "JSTD", nombre: "Jesús Iglesias" },
        { cargo: "TSTD", nombre: "Carmen Arenas" },
        // Agrega más cargos y nombres según sea necesario
    ];

       // Crear opciones para el desplegable de rol con una opción en blanco
       var selectOptions = '<option value="">Seleccione un rol</option>';
    rolesUnicos.forEach(rol => {
        selectOptions += `<option value="${rol}">${rol}</option>`;
    });

    // Crear opciones para el desplegable de cargos y nombres con una opción en blanco
    var cargoNombreOptions = '<option value="">Seleccione un cargo</option>';
    cargoNombreList.forEach(item => {
        cargoNombreOptions += `<option value="${item.cargo}">${item.cargo} - ${item.nombre}</option>`;
    });

    // Variable para almacenar las asignaciones de roles y cargos temporalmente
    var asignacionesTemporales = [];

    dialog.innerHTML = `
    <form method="dialog" style="width: 300px;">
        <label for="descripcionProyecto"><strong>Descripción del proyecto:</strong></label>
        <textarea id="descripcionProyecto" rows="4" style="width: 100%;">${flowchartData.descripcionProyecto || ''}</textarea>
        <br><br>
        <label for="fechaInicio"><strong>Fecha de inicio del proyecto:</strong></label>
        <input type="date" id="fechaInicio" value="${flowchartData.fechaInicioProyecto || ''}">
        <br><br>
        <label for="importeEstimado"><strong>Importe del proyecto:</strong></label>
        <input type="text" id="importeEstimado" value="${flowchartData.importeEstimado || ''}" style="text-align: right;" pattern="[0-9]{1,3}(\.[0-9]{3})*(,[0-9]+)?" title="Por favor, ingrese un número válido. Use coma como separador decimal. El separador de miles puede ser un punto o no existir.">€
        <span id="error-message" style="color: red;"></span>
        <br><br>
        <label for="asignaRoles"><strong>Asignación de personas (cargos) a roles:</strong></label>
        <br>
        <select id="rol">${selectOptions}</select>
        <br>
        <select id="cargoNombre">${cargoNombreOptions}<option value="Otro">Otro</option></select>
        <input type="text" id="cargoInput" style="display: none;" placeholder="Ingrese otro cargo">
        <menu style="margin-top: 10px;">
            <button type="button" style="float: right;" onclick="closeDialog();">Cancelar</button>
            <button type="submit" value="default" style="float: right;">Aceptar</button>
        </menu>
    </form>
`;

dialog.innerHTML = `
    <form method="dialog" style="width: 300px;">
      <label for="descripcionProyecto"><strong>Descripción del proyecto:</strong></label>
        <textarea id="descripcionProyecto" rows="4" style="width: 100%;">${flowchartData.descripcionProyecto || ''}</textarea>
        <br><br>
        <label for="fechaInicio"><strong>Fecha de inicio del proyecto:</strong></label>
        <input type="date" id="fechaInicio" value="${flowchartData.fechaInicioProyecto || ''}">
        <br><br>
        <label for="importeEstimado"><strong>Importe del proyecto:</strong></label>
        <input type="text" id="importeEstimado" value="${flowchartData.importeEstimado || ''}" style="text-align: right;" pattern="[0-9]{1,3}(\.[0-9]{3})*(,[0-9]+)?" title="Por favor, ingrese un número válido. Use coma como separador decimal. El separador de miles puede ser un punto o no existir.">€
        <span id="error-message" style="color: red;"></span>
        <br><br>
        <label for="asignaRoles"><strong>Asignación de personas (cargos) a roles:</strong></label>
        <br>
        <select id="rol">${selectOptions}</select>
        <br>
        <select id="cargoNombre">${cargoNombreOptions}<option value="Otro">Otro</option></select>
        <input type="text" id="cargoInput" style="display: none;" placeholder="Ingrese otro cargo">

        <br><br>
        <label for="estadoProyecto"><strong>Proyecto finalizado: </strong></label>
        <label class="switch">
            <input type="checkbox" id="estadoProyecto">
            <span class="slider round"></span>
        </label>
        <br><br>

        <menu style="margin-top: 10px;">
            <button type="button" style="float: right;" onclick="closeDialog();">Cancelar</button>
            <button type="submit" value="default" style="float: right;" onclick="guardarEstado();">Aceptar</button>
        </menu>
    </form>
    <style>
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        .switch input { 
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
        }
        input:checked + .slider {
            background-color: #2196F3;
        }
        input:focus + .slider {
            box-shadow: 0 0 1px #2196F3;
        }
        input:checked + .slider:before {
            -webkit-transform: translateX(26px);
            -ms-transform: translateX(26px);
            transform: translateX(26px);
        }
        /* Estilo redondeado */
        .slider.round {
            border-radius: 34px;
        }
        .slider.round:before {
            border-radius: 50%;
        }
    </style>
`;

    // Mostrar el cuadro de diálogo modal
    document.body.appendChild(dialog);
    establecerEstadoProyecto();
    dialog.showModal();

    function establecerEstadoProyecto() {
    let estadoProyecto = document.getElementById('estadoProyecto');
    estadoProyecto.checked = flowchartData.estadoProyecto === "cerrado";
    dialog.style.backgroundColor = estadoProyecto.checked ? "lightgrey" : "white";
}

    // Opcional: Agregar controlador de eventos para el interruptor
    document.getElementById('estadoProyecto').addEventListener('change', function() {
    if(this.checked) {
        dialog.style.backgroundColor = "lightgrey";
    } else {
        dialog.style.backgroundColor = "white";
    }
});

 
    var importeInput = document.getElementById("importeEstimado");
    var errorMessage = document.getElementById("error-message");
    var cargoNombreSelect = document.getElementById("cargoNombre");
    var cargoInput = document.getElementById("cargoInput");
    var rolSelect = document.getElementById("rol");

    // Crear una copia de los valores de flowchartData.asignacionRoles en asignacionesTemporales
    if (flowchartData.asignacionRoles) {
        asignacionesTemporales = Object.entries(flowchartData.asignacionRoles).map(([rol, cargo]) => ({ rol, cargo }));
    }

    // Función para preseleccionar el cargo en el desplegable de cargos
// Función para preseleccionar el cargo en el desplegable de cargos
function preselectCargo() {
    var selectedRol = rolSelect.value;
    var asignacionExistente = asignacionesTemporales.find(asignacion => asignacion.rol === selectedRol);
    
    // Obtener el elemento cargoNombreSelect
    var cargoNombreSelect = document.getElementById("cargoNombre");

    actualizaColorDesplegableRol();

    if (asignacionExistente) {
        var cargoOption = cargoNombreSelect.querySelector(`option[value="${asignacionExistente.cargo}"]`);
        if (cargoOption) {
            cargoOption.selected = true;
            cargoInput.style.display = "none";
        }else{ //Se ha asignado a "Otro".
        cargoNombreSelect.value = "Otro";
          cargoInput.style.display = "block";
          cargoInput.value = asignacionExistente.cargo;
        }
    } else {
        // Si no existe una asignación para el rol, seleccionar "Seleccione un cargo"
        cargoNombreSelect.value = "";
        cargoInput.style.display = "none";
    }
}

function actualizaColorDesplegableRol(){
          // Obtener todas las opciones del desplegable de roles
          var rolOptions = document.querySelectorAll("#rol option");
        rolOptions.forEach(option => {
        var rolValue = option.value;
        var hasCargo = asignacionesTemporales.some(asignacion => asignacion.rol === rolValue && asignacion.cargo !== "");
        if (hasCargo) {
            option.classList.add("has-cargo"); // Agregar clase "has-cargo" a las opciones con cargo asignado
        } else {
            option.classList.remove("has-cargo"); // Eliminar clase "has-cargo" de las opciones sin cargo asignado
        }
    });

}


        // Llamar a la función para preseleccionar el cargo al iniciar el cuadro de diálogo
        preselectCargo();

            // Evento de cambio de rol para preseleccionar el cargo
    rolSelect.addEventListener("change", preselectCargo);


    // Función para cerrar el cuadro de diálogo
    window.closeDialog = function() {
        dialog.close();
        // Eliminar el cuadro de diálogo del DOM después de cerrarlo
        dialog.remove();
    };

    // Función para mostrar u ocultar el campo de entrada de cargo según la selección
    function updateCargoInputVisibility() {
        if (cargoNombreSelect.value === "Otro") {
            cargoInput.style.display = "block";
        } else {
            cargoInput.style.display = "none";
        }
    }

    // Función para almacenar el valor seleccionado al cambiar el selector de rol o cargo
    function updateAsignacionesTemporales() {
        var seleccionRol = rolSelect.value;
        var seleccionCargoNombre = cargoNombreSelect.value === "Otro" ? cargoInput.value : cargoNombreSelect.value;

        // Buscar si ya existe una asignación para este rol
        var asignacionExistente = asignacionesTemporales.find(asignacion => asignacion.rol === seleccionRol);

        if (asignacionExistente) {
            // Si ya existe una asignación, actualizar el valor del cargo
            asignacionExistente.cargo = seleccionCargoNombre;
        } else {
            // Si no existe una asignación, agregar una nueva asignación
            asignacionesTemporales.push({ rol: seleccionRol, cargo: seleccionCargoNombre });
        }
        
    }

    cargoNombreSelect.addEventListener("change", function() {
        updateCargoInputVisibility();
        updateAsignacionesTemporales();
        actualizaColorDesplegableRol();
    });

    rolSelect.addEventListener("change", function() {
        updateAsignacionesTemporales();
    });

    cargoInput.addEventListener("change", function() {
        updateAsignacionesTemporales();
        actualizaColorDesplegableRol();
    });


    // Validar el input del importe antes de enviar el formulario
    dialog.querySelector("form").onsubmit = function(event) {


      var descripcionProyecto = document.getElementById("descripcionProyecto").value;
        if ((descripcionProyecto === null) || (descripcionProyecto === undefined) || (descripcionProyecto === "")) {
        } else {
            flowchartData.descripcionProyecto = descripcionProyecto;
        }

        var importeValue = importeInput.value.replace(/\./g, ""); // Eliminar puntos como separadores de miles
        if (isNaN(importeValue.replace(",", ".")) || importeValue === "") {
            errorMessage.textContent = "Por favor, ingrese un número válido.";
            event.preventDefault(); // Evitar que el formulario se envíe si el importe no es válido
        } else {
            errorMessage.textContent = ""; // Limpiar el mensaje de error si el importe es válido
            // Guardar el importe en flowchartData
            flowchartData.importeEstimado = importeValue.replace(",", ".");
        }
        var fechaInicioInput = document.getElementById("fechaInicio").value;
        if ((fechaInicioInput === null) || (fechaInicioInput === undefined) || (fechaInicioInput === "")) {
        } else {
            flowchartData.fechaInicioProyecto = fechaInicioInput;
        }

        
        // Al hacer clic en "Aceptar", almacenar los datos en flowchartData.asignacionRoles
        if (asignacionesTemporales.length > 0) {
            if (!flowchartData.asignacionRoles) {
                flowchartData.asignacionRoles = {};
            }

            asignacionesTemporales.forEach(asignacion => {
                flowchartData.asignacionRoles[asignacion.rol] = asignacion.cargo;
            });


    // Eliminar las asignaciones con cargos en blanco de flowchartData.asignacionRoles
    if (flowchartData.asignacionRoles) {
        Object.entries(flowchartData.asignacionRoles).forEach(([rol, cargo]) => {
            if (asignacionesTemporales.some(asignacion => asignacion.rol === rol && asignacion.cargo === "")) {
                delete flowchartData.asignacionRoles[rol];
            }
        });
    }

            

        }

        let estadoProyecto = document.getElementById('estadoProyecto').checked;
        flowchartData.estadoProyecto = estadoProyecto ? "cerrado" : "activo";
        console.log (estadoProyecto);
        console.log (flowchartData.estadoProyecto);
        guardarEstado();
        drawFlowchart();
    };

    // Manejar el evento de cierre del cuadro de diálogo
    dialog.addEventListener('close', function() {
        // Eliminar el cuadro de diálogo del DOM después de cerrarlo


        dialog.remove();
    });
}



function esFechaValida(fecha) {
  // Define una expresión regular para el formato "yyyy-mm-dd"
  var patron = /^\d{4}-\d{2}-\d{2}$/;

  // Usa el método test() de la expresión regular para verificar si la fecha coincide con el patrón
  if (patron.test(fecha)) {
    // La fecha tiene el formato correcto
    return true;
  } else {
    // La fecha no tiene el formato correcto
    return false;
  }
}

        function deleteStepOrPath() {
            finishPathProcess();
            //var selectedStep = 'step3'; // ID del elemento que deseas eliminar
            // Buscar y eliminar el elemento de la dimensión 'steps'
            if(pathSelected===true){
                          //var selectedStep = 'step3'; // ID del elemento que deseas eliminar
            // Buscar y eliminar el elemento de la dimensión 'steps'
            
            if (flowchartData.hasOwnProperty('paths')) {
              var paths = flowchartData.paths;
            for (var i = 0; i < paths.length; i++) {
             if (paths[i].id === selectedPath) {
                 paths.splice(i, 1);
             }
            }
          }
            }

            if(stepSelected===true){

              // Buscar y eliminar las referencias al elemento en la dimensión 'paths' (rutas vinculadas a las tareas seleccionadas)
              if (flowchartData.hasOwnProperty('paths')) {
                var paths = flowchartData.paths;
                for (var i = paths.length - 1; i >= 0; i--) {
                  if (selectedStep.includes(paths[i].startStep) || selectedStep.includes(paths[i].endStep)) {
                      paths.splice(i, 1);
                      }
                }
              }  
              //Eliminar las tareas
              if (flowchartData.hasOwnProperty('steps')) {
                var steps = flowchartData.steps;
                for (var i = steps.length - 1; i >= 0; i--) {
                  if (selectedStep.includes(steps[i].id)) {
                      var element=steps[i].id;
                      steps.splice(i, 1);
                      selectedStep = selectedStep.filter(step => step !== element);
                  }
                }

          }
        
        }

        selectedStep =[];
        stepSelected=false;
        selectedPath=null;







            guardarEstado();
            drawFlowchart();
            // Mostrar el array actualizado
        }
function normalizarStructureTextareaValue(textareaValue) {
    if (typeof textareaValue !== "string") return "";

    return textareaValue
        .split("\n")
        .map(linea => linea.trim() === "" ? "(Sin título)" : linea.trim())
        .join("\n");
}




function showStepDialog(isNew, tipo, stepId="", name = "", rol = "", duracion = "", instructions = "", unidadduracion = "", fechafin="",  notes="", multiple="", previous_multiple="") {

            if (!flowchartData.hasOwnProperty('steps')) {
          flowchartData.steps = [];
      }
    // Crear un div para el cuadro de diálogo
    // Crear un div para el cuadro de diálogo
    var dialogDiv = document.createElement("div");
    dialogDiv.style.display = "flex";
    dialogDiv.style.flexDirection = "column";
    dialogDiv.style.position = "fixed";
    dialogDiv.style.left = "50%";
    dialogDiv.style.top = "50%";
    dialogDiv.style.transform = "translate(-50%, -50%)";
    dialogDiv.style.backgroundColor = "white";
    dialogDiv.style.padding = "20px";
    dialogDiv.style.border = "1px solid #ccc";
    dialogDiv.style.borderRadius = "5px";
    dialogDiv.style.maxHeight = "90vh";
    dialogDiv.style.width = "800px";
    dialogDiv.style.overflow = "hidden";
    dialogDiv.style.boxShadow = "0 4px 10px rgba(0,0,0,0.2)";
    document.body.appendChild(dialogDiv);

    const tempElementDetalles = {};

    




    // Contenedor desplazable
    const contentContainer = document.createElement("div");
    contentContainer.style.overflowY = "auto";
    contentContainer.style.flex = "1";
    contentContainer.style.paddingRight = "10px";
    dialogDiv.appendChild(contentContainer);


      // Mostrar "Nombre de la tarea:" en una línea nueva
      var nameLabel = document.createElement("label");
      nameLabel.style.fontFamily = "Arial";
      nameLabel.style.fontSize = "14px";
      nameLabel.style.fontWeight = "bold"; // Establecer negrita
      if (tipo==='step'){
        nameLabel.textContent = "Nombre de la tarea:";
      }
      if (tipo==='milestone'){
        nameLabel.textContent = "Nombre del hito:";
      }
      contentContainer.appendChild(nameLabel);

      // Mostrar el campo de nombre en una línea nueva
      var nombreInput = document.createElement("input");
      nombreInput.type = "text";
      nombreInput.id = "nombre";
      nombreInput.value = name;
      nombreInput.autocomplete = "off";
      nombreInput.style.fontFamily = "Arial";
      nombreInput.setAttribute("size", "40");
      contentContainer.appendChild(nombreInput);

      // Agregar un retorno de carro
      contentContainer.appendChild(document.createElement("br"));
      contentContainer.appendChild(document.createElement("br"));


        if (tipo==='step'){
          // Mostrar "Rol:" en una línea nueva
          var rolLabel = document.createElement("label");
      rolLabel.for = "rol";
      rolLabel.style.fontFamily = "Arial";
      rolLabel.style.fontSize = "14px";
      rolLabel.textContent = "Rol:";
      rolLabel.style.fontWeight = "bold";
      contentContainer.appendChild(rolLabel);



        // Mostrar el campo de rol en una línea nueva
        var rolSelect = document.createElement("select");
      rolSelect.id = "rol";
      rolSelect.style.fontFamily = "Arial";

      var roles = ["Ejecutor", "Supervisor", "Administrador", "Intervención", "SGT", "Medios", "Director", "Otro"];
      roles.forEach(function (role) {
          var option = document.createElement("option");
          option.value = role;
          option.textContent = role;
          rolSelect.appendChild(option);
      });

      contentContainer.appendChild(rolSelect);

      // Crear el campo de texto adicional
      var otroRolInput = document.createElement("input");
      otroRolInput.type = "text";
      otroRolInput.id = "otroRol";
      otroRolInput.placeholder = "Especificar otro rol";
      otroRolInput.style.fontFamily = "Arial";

      // Configurar el campo de selección de "Rol"
      if (isNew) {
        rolSelect.value = roles[0];
        rol= roles[0];
      }else{
        rolSelect.value = rol;
      }
      

      // Verificar si el valor de "rol" coincide con "Otro" para mostrar u ocultar el campo de texto

      if (roles.includes(rol) && rol !== "Otro") {
        otroRolInput.style.display = "none"; // Ocultar campo de texto adicional
      }else{
        otroRolInput.style.display = "block"; // Mostrar campo de texto adicional
        otroRolInput.value=rol;
        rol="Otro";
        rolSelect.value = rol;
      }

      contentContainer.appendChild(otroRolInput); // Agregar el campo de texto adicional



      // Manejar el cambio en la selección de "Rol"
      rolSelect.addEventListener("change", function () {
          var selectedRol = rolSelect.value;
          otroRolInput.style.display = selectedRol === "Otro" ? "block" : "none"; // Mostrar u ocultar campo de texto adicional
      });

      // Agregar un retorno de carro
      contentContainer.appendChild(document.createElement("br"));
      contentContainer.appendChild(document.createElement("br"));


      // Mostrar "Duración estimada (días):" en una línea nueva
      var duracionLabel = document.createElement("label");
      duracionLabel.for = "duracion";
      duracionLabel.style.fontFamily = "Arial";
      duracionLabel.style.fontSize = "14px";
      duracionLabel.textContent = "Duración estimada: ";
      duracionLabel.style.fontWeight = "bold";
      contentContainer.appendChild(duracionLabel);

      // Crear un campo de entrada de tipo número para la duración
      var duracionInput = document.createElement("input");
      duracionInput.type = "number";
      duracionInput.id = "duracion";
      duracionInput.value = duracion || "";
      duracionInput.style.fontFamily = "Arial";
      duracionInput.setAttribute("maxlength", "5"); // Establecer la longitud máxima en 5 caracteres
      duracionInput.style.width = "50px"; // Establecer el ancho deseado en píxeles
      contentContainer.appendChild(duracionInput);


      // Crear un desplegable (select) para elegir entre "días", "meses" y "años"
      var unidadDuracionSelect = document.createElement("select");
      unidadDuracionSelect.id = "unidadDuracion";
      unidadDuracionSelect.style.fontFamily = "Arial";
      contentContainer.appendChild(unidadDuracionSelect);

      // Crear las opciones para el desplegable "Unidad de duración"
      var unidadDuracionOpcionDias = document.createElement("option");
      unidadDuracionOpcionDias.value = "n";
      unidadDuracionOpcionDias.text = "Días naturales";
      unidadDuracionSelect.appendChild(unidadDuracionOpcionDias);

      var unidadDuracionOpcionDias = document.createElement("option");
      unidadDuracionOpcionDias.value = "h";
      unidadDuracionOpcionDias.text = "Días hábiles";
      unidadDuracionSelect.appendChild(unidadDuracionOpcionDias);

      var unidadDuracionOpcionDias = document.createElement("option");
      unidadDuracionOpcionDias.value = "l";
      unidadDuracionOpcionDias.text = "Días laborables";
      unidadDuracionSelect.appendChild(unidadDuracionOpcionDias);

      var unidadDuracionOpcionMeses = document.createElement("option");
      unidadDuracionOpcionMeses.value = "m";
      unidadDuracionOpcionMeses.text = "Meses";
      unidadDuracionSelect.appendChild(unidadDuracionOpcionMeses);

      var unidadDuracionOpcionAnos = document.createElement("option");
      unidadDuracionOpcionAnos.value = "a";
      unidadDuracionOpcionAnos.text = "Años";
      unidadDuracionSelect.appendChild(unidadDuracionOpcionAnos);

      unidadDuracionSelect.value = unidadduracion || "n";


      // Agregar un retorno de carro
      contentContainer.appendChild(document.createElement("br"));


    

//Hasta aquí llegaba if tipo===step


    
      // Mostrar "Instrucciones:" en una línea nueva
      var instructionsLabel = document.createElement("label");
      instructionsLabel.for = "instrucciones";
      instructionsLabel.style.verticalAlign = "top";
      instructionsLabel.style.fontFamily = "Arial";
      instructionsLabel.style.fontSize = "14px";
      if (tipo==='step'){
      instructionsLabel.textContent = "Instrucciones: ";
      }
      if (tipo==='milestone'){
        instructionsLabel.textContent = "Descripción: ";
      }
      instructionsLabel.style.fontWeight = "bold";
      contentContainer.appendChild(document.createElement("br"));
      // Mostrar "Instrucciones:" en una línea nueva
      var instructionsExpLabel = document.createElement("label");
      instructionsExpLabel.for = "explicación instrucciones";
      instructionsExpLabel.style.verticalAlign = "top";
      instructionsExpLabel.style.fontFamily = "Arial";
      instructionsExpLabel.style.fontSize = "14px";


      if (tipo==='step'){
      instructionsExpLabel.textContent = "(para vínculo a archivo cargado poner /*nombrearchivo*/)";
      }
      if (tipo==='milestone'){
        instructionsExpLabel.textContent = "(para vínculo a archivo cargado poner /*nombrearchivo*/)";
      }

      contentContainer.appendChild(instructionsLabel);
      contentContainer.appendChild(document.createElement("br"));

      // Mostrar el campo de instrucciones en una línea nueva
      var instructionsTextarea = document.createElement("textarea");
      instructionsTextarea.id = "instrucciones";
      instructionsTextarea.rows = "10";
      instructionsTextarea.cols = "65";
      instructionsTextarea.style.fontFamily = "Arial";
      instructionsTextarea.style.overflowY = "auto"; // Añade la barra de desplazamiento si es necesario
      instructionsTextarea.style.maxHeight = "200px"; // Altura máxima antes de mostrar la barra de desplazamiento
      instructionsTextarea.textContent = instructions;
      contentContainer.appendChild(instructionsTextarea);

      contentContainer.appendChild(document.createElement("br"));
      contentContainer.appendChild(document.createElement("br"));


        // Desplegable para "Gestionar múltiples tareas en paralelo:"
    var gestionarLabel = document.createElement("label");
    gestionarLabel.textContent = "Hacer esta tarea múltiples veces en paralelo: ";
    gestionarLabel.style.fontFamily = "Arial";
    gestionarLabel.style.fontSize = "14px";
    gestionarLabel.style.fontWeight = "bold";
    contentContainer.appendChild(gestionarLabel);

    var gestionarSelect = document.createElement("select");
    gestionarSelect.id = "gestionarMultiplesTareas";
    gestionarSelect.style.fontFamily = "Arial";

    ["NO", "SI"].forEach(function (optionText) {
        var option = document.createElement("option");
        option.value = optionText;
        option.textContent = optionText;
        gestionarSelect.appendChild(option);
    });
    contentContainer.appendChild(gestionarSelect);

    // Agregar un retorno de carro
    //dialogDiv.appendChild(document.createElement("br"));
    //dialogDiv.appendChild(document.createElement("br"));

    // Desplegable condicional "Conectar cada tarea múltiple con las de la tarea anterior:"
    var conectarLabel = document.createElement("label");
    conectarLabel.innerHTML = "Conectar cada tarea múltiple con las de la tarea anterior: ";
    conectarLabel.style.fontFamily = "Arial";
    conectarLabel.style.fontSize = "14px";
    conectarLabel.style.fontWeight = "bold";
    conectarLabel.style.display = "none"; // Oculto inicialmente
    contentContainer.appendChild(document.createElement("br"));
    contentContainer.appendChild(conectarLabel);

   

    var conectarSelect = document.createElement("select");
    conectarSelect.id = "conectarTareasMultiples";
    conectarSelect.style.fontFamily = "Arial";
    conectarSelect.style.display = "none"; // Oculto inicialmente

    ["NO", "Tarea XX"].forEach(function (optionText) {
        var option = document.createElement("option");
        option.value = optionText;
        option.textContent = optionText;
        conectarSelect.appendChild(option);
    });
    contentContainer.appendChild(conectarSelect);
    contentContainer.appendChild(document.createElement("br"));


    // Inicializar "Gestionar múltiples tareas en paralelo:"
    gestionarSelect.value = multiple ? "SI" : "NO";

 // Inicializar "Conectar cada tarea múltiple con las de la tarea anterior:"
// Inicializar "Conectar cada tarea múltiple con las de la tarea anterior:"
if (multiple) {
    conectarLabel.style.display = "inline";
    conectarSelect.style.display = "inline";

    // Limpiar opciones existentes en el desplegable
    conectarSelect.innerHTML = "";

    // Agregar opción "NO" al inicio
    var noOption = document.createElement("option");
    noOption.value = "NO";
    noOption.textContent = "NO";
    conectarSelect.appendChild(noOption);

    // Agregar tareas previas con is_a_multiple_task === "true"
    if (flowchartData.hasOwnProperty("paths") && flowchartData.hasOwnProperty("steps")) {
        var previousSteps = [];

        // Buscar pasos previos
        flowchartData.paths.forEach(function (path) {
            if (path.endStep === stepId) {
                previousSteps.push(path.startStep); // Guardar el paso inicial
            }
        });

        // Filtrar pasos previos que tengan is_a_multiple_task === "true"
        previousSteps.forEach(function (prevStepId) {
            var step = flowchartData.steps.find(function (s) {
                return s.id === prevStepId && s.is_a_multiple_task === "true";
            });

            if (step) {
                var option = document.createElement("option");
                option.value = step.id; // Internamente se usa el id
                option.textContent = step.label; // Visualmente se muestra el label
                conectarSelect.appendChild(option);
            }
        });
    }

    console.log("1. previous_multiple: "+previous_multiple);
    // Seleccionar el valor de multiple_task_following_previous o "NO"
    if (typeof previous_multiple === "string" && previous_multiple.startsWith("step")) {
        var previousStep = flowchartData.steps.find(function (s) {
            return s.id === previous_multiple && s.is_a_multiple_task === "true";
        });
        console.log("previousStep: "+previousStep);
        console.log("previous_multiple: "+previous_multiple);


        if (previousStep) {
          conectarSelect.value = previous_multiple; // Seleccionar por id, visualmente mostrará el label
       } else {
            conectarSelect.value = "NO"; // Valor por defecto si el step no existe o no cumple el criterio
        }
    } else {
        conectarSelect.value = "NO"; // Valor por defecto si no hay previous_multiple válido
    }
} else {
    // Ocultar el desplegable si no es una tarea múltiple
    conectarLabel.style.display = "none";
    conectarSelect.style.display = "none";
}




    // Lógica para mostrar/ocultar el segundo desplegable
    if (gestionarSelect.value === "SI") {
        conectarLabel.style.display = "inline";
        conectarSelect.style.display = "inline";
    } else {
        conectarLabel.style.display = "none";
        conectarSelect.style.display = "none";
    }
    

    // Agregar lógica para mostrar/ocultar el segundo desplegable
gestionarSelect.addEventListener("change", function () {
    var gestionarValue = gestionarSelect.value;

    if (gestionarValue === "NO") {
        // Verificar si hay elementos "Uno para cada ítem"
        var elementosConflictivos = infoElements.filter(e => e.scope === "Uno para cada ítem");
        if (elementosConflictivos.length > 0) {
            var nombres = elementosConflictivos.map(e => `- ${e.name}`).join("\n");
            alert("No puedes cambiar a 'NO' porque tienes elementos definidos como 'Uno para cada ítem':\n\n" + nombres);
            
            // Volver a poner la selección en "SI"
            gestionarSelect.value = "SI";
            return; // Detener la ejecución
        }
    }


    if (gestionarValue === "SI") {
        conectarLabel.style.display = "inline";
        conectarSelect.style.display = "inline";

        // Limpiar opciones existentes en el desplegable
        conectarSelect.innerHTML = ""; 

        // Buscar tareas previas
        var previousSteps = [];
        if (flowchartData.hasOwnProperty("paths")) {
            var paths = flowchartData.paths;


            for (var i = 0; i < paths.length; i++) {
                if (paths[i].endStep === stepId) {
                    previousSteps.push(paths[i].startStep); // Obtener el paso inicial (previo)
                }
            }
        }

        // Agregar opción "NO" al inicio
        var noOption = document.createElement("option");
        noOption.value = "NO";
        noOption.textContent = "NO";
        conectarSelect.appendChild(noOption);

        // Agregar tareas previas al desplegable
        previousSteps.forEach(function (stepId) {
            var step = flowchartData.steps.find(function (s) {
                return s.id === stepId;
            });
            if (step) {
                var option = document.createElement("option");
                option.value = step.id;
                option.textContent = step.label || `Tarea ${step.id}`;
                conectarSelect.appendChild(option);
            }
        });

    } else {
        conectarLabel.style.display = "none";
        conectarSelect.style.display = "none";
        conectarSelect.value = "NO"; // Restablecer a "NO" si se desactiva
   
    }
    actualizarVisibilidadScope(); // Asegurarse de que se oculte/visualice el campo Aplicación
    updateInfoList(); // Actualizar la lista para ocultar/mostrar el scope
});



// Contenedor de elementos recibidos
var receivedContainer = document.createElement("div");
receivedContainer.style.marginTop = "20px";
contentContainer.appendChild(receivedContainer);

// Título
var receivedTitle = document.createElement("h4");
receivedTitle.style.fontFamily = "Arial";
receivedTitle.textContent = "Elementos de Información recibidos:";
receivedContainer.appendChild(receivedTitle);

// Desplegable de tareas conectadas anteriores por path.type === 'path'
var taskSelectLabel = document.createElement("label");
taskSelectLabel.textContent = "Añadir información de tarea previa o bloque de texto o html:";
taskSelectLabel.style.fontFamily = "Arial";
receivedContainer.appendChild(taskSelectLabel);

var taskSelect = document.createElement("select");
taskSelect.style.marginLeft = "10px";
taskSelect.style.fontFamily = "Arial";
receivedContainer.appendChild(taskSelect);

// Opción para bloque de HTML
var htmlOption = document.createElement("option");
htmlOption.value = "__html_block__";
htmlOption.textContent = "[Añadir bloque de texto o html]";
taskSelect.appendChild(htmlOption);

// Cargar tareas conectadas por path

// Cargar tareas conectadas por path
var connectedSteps = (flowchartData.paths || [])
  .filter(p => p.type === "path" && p.endStep === stepId)
  .map(p => p.startStep);

connectedSteps.forEach(stepId => {
  var step = flowchartData.steps.find(s => s.id === stepId);
  if (step) {
    var option = document.createElement("option");
    option.value = step.id;
    option.textContent = step.label || `Tarea ${step.id}`;
    taskSelect.appendChild(option);
  }
});

// Desplegable de elementos disponibles en esa tarea
var elementLabel = document.createElement("span");
elementLabel.textContent = "Selecciona un elemento: ";
var elementSelect = document.createElement("select");
elementSelect.style.fontFamily = "Arial";
elementSelect.style.marginTop = "10px";
elementSelect.style.marginLeft = "10px";
receivedContainer.appendChild(document.createElement("br"));
receivedContainer.appendChild(elementLabel);
receivedContainer.appendChild(elementSelect);

// Botón de añadir elemento recibido
var addReceivedBtn = document.createElement("button");
addReceivedBtn.textContent = "Añadir";
addReceivedBtn.style.marginLeft = "10px";
receivedContainer.appendChild(addReceivedBtn);

// Lista visual de elementos añadidos
var receivedList = document.createElement("ul");
receivedList.style.marginTop = "10px";
receivedContainer.appendChild(receivedList);

// Lista lógica para guardar los elementos seleccionados
var receivedElements = [];

// cargamos los datos si existían
if (!isNew) {
    const selectedStepData = flowchartData.steps.find(step => step.id === stepId);
    if (Array.isArray(selectedStepData.receivedElements)) {
        receivedElements = JSON.parse(JSON.stringify(selectedStepData.receivedElements));
        renderReceivedList(); 
    } else {
        receivedElements = [];
    }  
}

// Actualizar elementos disponibles al cambiar de tarea
function actualizarElementos() {
  const selectedValue = taskSelect.value;
  elementSelect.innerHTML = "";

  const esHTML = selectedValue === "__html_block__";
  elementLabel.style.display = esHTML ? "none" : "inline";
  elementSelect.style.display = esHTML ? "none" : "inline";

  if (!esHTML) {
    const selectedTask = flowchartData.steps.find(s => s.id === selectedValue);
    if (selectedTask?.infoElements) {
      selectedTask.infoElements.forEach(e => {
        var option = document.createElement("option");
        option.value = JSON.stringify({ stepId: selectedTask.id, element: e });
        var apartado = e.apartado ? ` | ${e.apartado}` : "";
        option.textContent = `${e.name}${apartado}`;
        elementSelect.appendChild(option);
      });
    }
  }
}

taskSelect.addEventListener("change", actualizarElementos);

// Añadir a la lista
addReceivedBtn.addEventListener("click", function () {
  const selectedValue = taskSelect.value;

  if (selectedValue === "__html_block__") {
    receivedElements.push({ type: "htmlBlock", content: "" });
  } else if (elementSelect.value) {
    var parsed = JSON.parse(elementSelect.value);
    receivedElements.push(parsed);
  } else {
    return;
  }

  renderReceivedList();
});

function renderReceivedList() {
  receivedList.innerHTML = "";
  receivedElements.forEach((e, idx) => {
    const item = document.createElement("li");
    item.style.fontFamily = "Arial";
    item.style.display = "flex";
    item.style.alignItems = "center";
    item.style.marginBottom = "4px";

    // Contenedor horizontal para botones ▲ ▼
    const btnContainer = document.createElement("div");
    btnContainer.style.display = "flex";
    btnContainer.style.gap = "2px"; // Espacio muy pequeño entre botones
    btnContainer.style.marginRight = "6px";

    const upBtn = document.createElement("span");
    upBtn.textContent = "▲";
    upBtn.style.cursor = "pointer";
    upBtn.style.userSelect = "none";
    upBtn.onclick = () => {
      if (idx > 0) {
        const temp = receivedElements[idx];
        receivedElements[idx] = receivedElements[idx - 1];
        receivedElements[idx - 1] = temp;
        renderReceivedList();
      }
    };

    const downBtn = document.createElement("span");
    downBtn.textContent = "▼";
    downBtn.style.cursor = "pointer";
    downBtn.style.userSelect = "none";
    downBtn.onclick = () => {
      if (idx < receivedElements.length - 1) {
        const temp = receivedElements[idx];
        receivedElements[idx] = receivedElements[idx + 1];
        receivedElements[idx + 1] = temp;
        renderReceivedList();
      }
    };

    btnContainer.appendChild(upBtn);
    btnContainer.appendChild(downBtn);

    // Texto del elemento
    const labelSpan = document.createElement("span");
    if (e.type === "htmlBlock") {
      labelSpan.textContent = "[Bloque de texto o html]";
    } else {
      const step = flowchartData.steps.find(s => s.id === e.stepId);
      const stepLabel = step?.label || e.stepId;
      labelSpan.textContent = `${e.element.name} (${e.element.type}) [${stepLabel}]`;
    }

    // Botón borrar
    const delBtn = document.createElement("button");
    delBtn.textContent = "Borrar";
    delBtn.style.marginLeft = "10px";
    delBtn.onclick = () => {
      receivedElements.splice(idx, 1);
      renderReceivedList();
    };

    item.appendChild(btnContainer);
    item.appendChild(labelSpan);
    item.appendChild(delBtn);

    // Si es bloque de HTML, añadir botón de desplegar
    if (e.type === "htmlBlock") {
      const toggleBtn = document.createElement("button");
      toggleBtn.textContent = "▼";
      toggleBtn.style.marginLeft = "10px";

      const textArea = document.createElement("textarea");
      textArea.value = e.html || "";
      textArea.style.display = "none";
      textArea.style.marginTop = "5px";
      textArea.style.width = "100%";
      textArea.rows = 4;
      textArea.addEventListener("input", () => {
        e.html = textArea.value;
      });

      toggleBtn.onclick = () => {
        const visible = textArea.style.display !== "none";
        textArea.style.display = visible ? "none" : "block";
      };

      item.appendChild(toggleBtn);
      item.appendChild(document.createElement("br"));
      item.appendChild(textArea);
    }

    receivedList.appendChild(item);
  });
}




// Preseleccionar primera tarea si hay alguna
taskSelect.selectedIndex = 0;
actualizarElementos();



// Contenedor para los elementos de información
var infoContainer = document.createElement("div");
infoContainer.style.marginTop = "20px";
contentContainer.appendChild(infoContainer);

// Título para los elementos de información
var infoTitle = document.createElement("h4");
infoTitle.style.fontFamily = "Arial";
infoTitle.fontSize = "12px";
infoTitle.textContent = "Elementos de Información a aportar:";
infoContainer.appendChild(infoTitle);

// Cuadro de texto para estructura de apartados
var structureLabel = document.createElement("label");
structureLabel.textContent = "Estructura de apartados (una línea por apartado, usar > y >> para subniveles):";
structureLabel.style.fontFamily = "Arial";
structureLabel.style.fontSize = "14px";
structureLabel.style.fontWeight = "bold";
infoContainer.appendChild(structureLabel);

var structureTextarea = document.createElement("textarea");
structureTextarea.id = "estructuraApartados";
structureTextarea.style.width = "100%";
structureTextarea.style.height = "100px";
structureTextarea.style.fontFamily = "Arial";
// Cargar estructura de apartados si existe
if (!isNew) {
    selectedStepData = flowchartData.steps.find(step => step.id === stepId);
    if (selectedStepData && selectedStepData.estructuraApartados) {
        let estructuraTexto = "";

        if (typeof selectedStepData.estructuraApartados === "string") {
            estructuraTexto = selectedStepData.estructuraApartados;
        } else if (Array.isArray(selectedStepData.estructuraApartados)) {
            estructuraTexto = selectedStepData.estructuraApartados.join("\n");
        } else {
            console.warn("⚠️ estructuraApartados tiene un formato inesperado:", selectedStepData.estructuraApartados);
            estructuraTexto = "";
        }

        structureTextarea.value = estructuraTexto
            .split("\n")
            .map(s => s === "(Sin título)" ? "" : s)
            .join("\n");

        infoElements = selectedStepData.infoElements || [];

        // Asignar "(Seleccionar apartado)" a elementos huérfanos
        if (structureTextarea.value.trim() !== "") {
            infoElements.forEach(e => {
                if (!e.apartado) {
                    e.apartado = "(Seleccionar apartado)";
                }
            });
        }
    }
}


structureTextarea.addEventListener("blur", function () {
    console.log("🔵 BLUR lanzado");

    // Normalizamos el texto
    const apartadosValidos = obtenerApartadosConRutaCompleta();
    const estructuraApartados = normalizarStructureTextareaValue(structureTextarea.value).trim();


    console.log("✅ Apartados válidos normalizados:", apartadosValidos);

    const items = infoList.querySelectorAll("li");
    console.log("infoList:", infoList);
    console.log("ítems:", items);

    items.forEach((item, index) => {
        const element = infoElements[index];
        // Eliminar select antiguo si existe
        let selectAntiguo = item.querySelector("select");
        if (selectAntiguo) {
            item.removeChild(selectAntiguo);
        }

        // Crear select nuevo siempre
        const select = document.createElement("select");
        select.style.marginLeft = "10px";
        select.style.fontFamily = "Arial";

        // Crear las opciones
        apartadosValidos.forEach(ap => {
            const option = document.createElement("option");
            option.value = ap;
            option.textContent = ap;
            select.appendChild(option);
        });

        // Asignar el valor actual
        select.value = element.apartado || "(Sin título)";

        // 🔥 Ahora sí, conectar el listener
        select.addEventListener("change", function () {
            console.log("✏️ EVENTO CHANGE ACTIVADO en este SELECT:", select);
            console.log("- Nuevo select.value:", select.value);
            console.log("- Antes element.apartado era:", element.apartado);

            element.apartado = select.value;

            console.log("- Ahora element.apartado es:", element.apartado);

            select.style.border = "";

            if (typeof infoElementsDataPorInstancia !== "undefined") {
                console.log("- Estado actual de infoElementsDataPorInstancia:", infoElementsDataPorInstancia);
            }

           // updateInfoList();
        });
        console.log("🛠️ SELECT construido y listener añadido:", select);



        // Insertar el nuevo select en el ítem
        item.appendChild(select);



        console.log(`🔸 Opciones creadas en SELECT del elemento ${index}:`, apartadosValidos);

        // Recuperar valor previo
        const valorPrevio = element.apartado || "(Sin título)";
        console.log(`🔸 Valor previo del elemento ${index}:`, valorPrevio);

        // Seleccionar automáticamente si existe
        if (apartadosValidos.includes(valorPrevio)) {
            select.value = valorPrevio;
            console.log(`✅ Valor seleccionado automáticamente en SELECT ${index}:`, valorPrevio);
            select.style.border = "";
        } else {
            console.warn(`⚠️ Valor previo NO encontrado en apartados válidos:`, valorPrevio);
            select.style.border = "2px solid red"; // 🔥
        }


          select.addEventListener("change", function () {
          console.log("✏️ Cambio detectado en select:");
          console.log("- Nuevo select.value:", select.value);
          console.log("- Antes element.apartado era:", element.apartado);

          element.apartado = select.value;

          console.log("- Ahora element.apartado es:", element.apartado);

          select.style.border = "";

          // Opcional: ¿Tienes infoElementsDataPorInstancia?
          if (typeof infoElementsDataPorInstancia !== "undefined") {
              console.log("- Estado actual de infoElementsDataPorInstancia:", infoElementsDataPorInstancia);
          }

         // updateInfoList();
      });


            select.dataset.listenerAttached = "true";
        
    });

    // 🔥 Después de recorrer todos los elementos...
    const algunElementoMalAsignado = infoElements.some(e => !apartadosValidos.includes(e.apartado || "(Seleccionar apartado)"));

    if (algunElementoMalAsignado) {
        console.error("🚨 Hay elementos cuyo apartado no coincide con el cuadro de texto actual.");
        alert("Hay elementos cuyo apartado no coincide con el cuadro de texto actual. Por favor, revísalos.");
    }

    updateInfoList();
});







infoContainer.appendChild(structureTextarea);
infoContainer.appendChild(document.createElement("br"));
infoContainer.appendChild(document.createElement("br"));


// Desplegable para seleccionar el tipo de elemento de información
var infoTypeLabel = document.createElement("label");
infoTypeLabel.textContent = "Tipo: ";
infoTypeLabel.style.fontFamily = "Arial";
infoTypeLabel.style.fontSize = "14px";
infoContainer.appendChild(infoTypeLabel);

var infoTypeSelect = document.createElement("select");
infoTypeSelect.style.fontFamily = "Arial";

[
    "Archivo",
    "Texto corto",
    "Texto largo",
    "Texto ocultado",
    "Texto o html (no editable)",
    "Fecha",
    "Hora",
    "Número",
    "Importe en €",
    "Porcentaje",
    "NIF",
    "Cuenta bancaria",
    "Código postal",
    "Localidad",
    "Coordenadas WGS84",
    "Desplegable selección única",
    "Desplegable selección múltiple",
    "Check independiente",
    "Check ligado a grupo",
    "Tabla"
].forEach(function (optionText) {
    const option = document.createElement("option");
    option.value = optionText;
    option.textContent = optionText;
    infoTypeSelect.appendChild(option);
});
infoContainer.appendChild(infoTypeSelect);

// Campo de texto para el nombre del elemento
var infoNameLabel = document.createElement("label");
infoNameLabel.textContent = " Nombre: ";
infoNameLabel.style.fontFamily = "Arial";
infoNameLabel.style.fontSize = "14px";
infoContainer.appendChild(infoNameLabel);

var infoNameInput = document.createElement("input");
infoNameInput.type = "text";
infoNameInput.style.fontFamily = "Arial";
infoContainer.appendChild(infoNameInput);



// Campo de selección de apartado (si existe estructura)
var apartadoSelectLabel = document.createElement("label");
apartadoSelectLabel.textContent = " Apartado: ";
apartadoSelectLabel.style.fontFamily = "Arial";
apartadoSelectLabel.style.fontSize = "14px";

var apartadoSelect = document.createElement("select");
apartadoSelect.style.fontFamily = "Arial";

// Solo mostrar si hay estructura
function actualizarApartadoSelect() {
    apartadoSelect.innerHTML = "";
    const estructuraTexto = normalizarStructureTextareaValue(structureTextarea.value).trim();
    const lineas = estructuraTexto.split("\n");

    if (estructuraTexto === "") {
        apartadoSelect.style.display = "none";
        apartadoSelectLabel.style.display = "none";
        return;
    }

    apartadoSelect.style.display = "inline";
    apartadoSelectLabel.style.display = "inline";

    let apartados = [];
    let rutaActual = [];

    lineas.forEach(function (linea) {
        const texto = linea.trim();
        if (texto.startsWith(">>")) {
            if (rutaActual.length > 1) rutaActual = rutaActual.slice(0, 2);
            rutaActual[2] = texto.substring(2).trim();
        } else if (texto.startsWith(">")) {
            if (rutaActual.length > 0) rutaActual = rutaActual.slice(0, 1);
            rutaActual[1] = texto.substring(1).trim();
        } else {
            rutaActual = [texto];
        }
        apartados.push(rutaActual.join(">"));
    });

    apartados.forEach(function (ruta) {
        const opcion = document.createElement("option");
        opcion.value = ruta;
        opcion.textContent = ruta;
        apartadoSelect.appendChild(opcion);
    });

    // Opción por defecto al final
    const opcionSinTitulo = document.createElement("option");
    opcionSinTitulo.value = "(Seleccionar apartado)";
    opcionSinTitulo.textContent = "(Seleccionar apartado)";
    apartadoSelect.appendChild(opcionSinTitulo);

    apartadoSelect.value = "(Seleccionar apartado)";
}
actualizarApartadoSelect();
structureTextarea.addEventListener("input", actualizarApartadoSelect);

// Añadir al contenedor
infoContainer.appendChild(apartadoSelectLabel);
infoContainer.appendChild(apartadoSelect);


// Desplegable para la opción de aplicación
var infoScopeLabel = document.createElement("label");
infoScopeLabel.textContent = " Aplicación en paralelo: ";
infoScopeLabel.style.fontFamily = "Arial";
infoScopeLabel.style.fontSize = "14px";
infoContainer.appendChild(infoScopeLabel);

var infoScopeSelect = document.createElement("select");
infoScopeSelect.style.fontFamily = "Arial";
["Uno para todos los ítems", "Uno para cada ítem"].forEach(function (optionText) {
    var option = document.createElement("option");
    option.value = optionText;
    option.textContent = optionText;
    infoScopeSelect.appendChild(option);
});
infoContainer.appendChild(infoScopeSelect);

// Contenedor para el campo de aplicación (para mostrar/ocultar fácilmente)
var scopeContainer = document.createElement("span");
scopeContainer.appendChild(infoScopeLabel);
scopeContainer.appendChild(infoScopeSelect);
infoContainer.appendChild(scopeContainer);

// Mostrar u ocultar el desplegable de aplicación según la selección de "gestionar múltiples"
function actualizarVisibilidadScope() {
    const esMultiple = gestionarSelect.value === "SI";
    scopeContainer.style.display = esMultiple ? "inline" : "none";
}
actualizarVisibilidadScope(); // Llamada inicial
gestionarSelect.addEventListener("change", actualizarVisibilidadScope);



// Botón para añadir el elemento a la lista
var addInfoButton = document.createElement("button");
addInfoButton.textContent = "Añadir";
addInfoButton.style.marginLeft = "10px";
infoContainer.appendChild(addInfoButton);

// Lista para mostrar los elementos añadidos
var infoList = document.createElement("ul");
infoList.style.marginTop = "20px";
infoContainer.appendChild(infoList);

// Lógica para añadir elementos a la lista
var infoElements = [];

addInfoButton.addEventListener("click", function () {
    var type = infoTypeSelect.value;
    var name = infoNameInput.value.trim();

    if (!name) {
        alert("Por favor, introduce un nombre para el elemento.");
        return;
    }

    var scope = gestionarSelect.value === "SI" ? infoScopeSelect.value : "Uno para todos los ítems";

    // Obtener valor del apartado seleccionado, si existe
    let apartadoElegido = "(Seleccionar apartado)";
    if (structureTextarea.value.trim() !== "" && typeof apartadoSelect !== "undefined") {
        apartadoElegido = apartadoSelect.value || "(Seleccionar apartado)";
    }

    var newElement = {
        type,
        name,
        scope,
        apartado: apartadoElegido
    };

    if (type === "Texto o html (no editable)") {
        newElement.obligatorio = false; // explícitamente no obligatorio
    }

    if (type === "Tabla") {
        newElement.tabla = {
            rows: []
        };
    }

    if (type === "Desplegable selección única") {
        newElement.opciones = [];
    }

    infoElements.push(newElement);

    // Actualizar la lista visual
    updateInfoList();
});



function obtenerApartadosConRutaCompleta() {
    const estructuraTexto = normalizarStructureTextareaValue(structureTextarea.value).trim();
    const lineas = estructuraTexto.split("\n");

    let apartados = [];
    let rutaActual = [];

    lineas.forEach(function (linea) {
        const texto = linea.trim();
        if (texto === "(Seleccionar apartado)") return;

        if (texto.startsWith(">>")) {
            // 🔥 Nivel 2: sobreescribimos el último nivel 2
            if (rutaActual.length > 1) {
                rutaActual = rutaActual.slice(0, 2); // Solo raíz y sub1
            }
            rutaActual[2] = texto.substring(2).trim(); // Nuevo subsub
        } else if (texto.startsWith(">")) {
            // 🔥 Nivel 1: sobreescribimos dejando solo raíz
            if (rutaActual.length > 0) {
                rutaActual = rutaActual.slice(0, 1);
            }
            rutaActual[1] = texto.substring(1).trim(); // Nuevo sub1
        } else {
            // 🔥 Nivel 0: raíz nueva
            rutaActual = [texto];
        }

        apartados.push(rutaActual.join(">"));
    });

    //apartados.push("(Sin título)");

    return apartados;
}

function moverElemento(elemento, direccion) {
    const indexActual = infoElements.indexOf(elemento);
    if (indexActual === -1) return;

    // Obtener el apartado actual del elemento
    const apartadoActual = elemento.apartado || "(Seleccionar apartado)";

    // Filtrar los elementos que están en el mismo apartado
    const indicesMismoApartado = infoElements
        .map((el, idx) => ({ el, idx }))
        .filter(({ el }) => (el.apartado || "(Seleccionar apartado)") === apartadoActual)
        .map(({ idx }) => idx);

    const posDentroDelApartado = indicesMismoApartado.indexOf(indexActual);
    const nuevaPos = posDentroDelApartado + direccion;

    if (nuevaPos < 0 || nuevaPos >= indicesMismoApartado.length) return; // fuera de rango

    // Intercambiar elementos en infoElements
    const idxDestino = indicesMismoApartado[nuevaPos];
    const temp = infoElements[indexActual];
    infoElements[indexActual] = infoElements[idxDestino];
    infoElements[idxDestino] = temp;
}


// Función para actualizar la lista visual de elementos
function updateInfoList() {
    infoList.innerHTML = "";

    const estructuraTexto = normalizarStructureTextareaValue(structureTextarea.value).trim();
    const lineas = estructuraTexto.split("\n");
    const campoEstaRealmenteVacio = structureTextarea.value.trim() === "";

    let apartadosEnOrden = [];
    let rutaActual = [];

    lineas.forEach(function (linea) {
        const texto = linea.trim();
        if (texto === "(Seleccionar apartado)") return;

        if (texto.startsWith(">>")) {
            if (rutaActual.length > 1) rutaActual = rutaActual.slice(0, 2);
            rutaActual[2] = texto.substring(2).trim();
        } else if (texto.startsWith(">")) {
            if (rutaActual.length > 0) rutaActual = rutaActual.slice(0, 1);
            rutaActual[1] = texto.substring(1).trim();
        } else {
            rutaActual = [texto];
        }

        apartadosEnOrden.push(rutaActual.join(">"));
    });

    const haySinAsignar = infoElements.some(e => e.apartado === "(Seleccionar apartado)");
    if (haySinAsignar) apartadosEnOrden.push("(Seleccionar apartado)");

    if (campoEstaRealmenteVacio) {
        infoElements.forEach(function (element) {
            crearItemElemento(element, false);
        });
        return;
    }

    // 🔁 Asegurar que todos los elementos tengan apartados válidos
    infoElements.forEach(e => {
        if (!e.apartado || !apartadosEnOrden.includes(e.apartado)) {
            e.apartado = "(Seleccionar apartado)";
        }
    });

    // 🔷 Separar por tipo de aplicación
    const elementosTodos = infoElements.filter(e => e.scope !== "Uno para cada ítem");
    const elementosCada = infoElements.filter(e => e.scope === "Uno para cada ítem");


    // 🔴 Mostrar elementos sin asignar
    const sinAsignarTodos = infoElements.filter(e => 
        (e.scope !== "Uno para cada ítem") && e.apartado === "(Seleccionar apartado)"
    );
    const sinAsignarCada = infoElements.filter(e => 
        e.scope === "Uno para cada ítem" && e.apartado === "(Seleccionar apartado)"
    );


    if (sinAsignarTodos.length + sinAsignarCada.length > 0) {
        const header = document.createElement("h5");
        header.innerHTML = "Elementos sin asignar:";
        header.style.fontFamily = "Arial";
        header.style.marginTop = "16px";
        header.style.marginBottom = "4px";
        header.style.color = "red";
        header.style.fontSize = "16px";
        header.style.fontWeight = "bold";
        infoList.appendChild(header);
    }

    sinAsignarTodos.forEach(e => crearItemElemento(e, true));
    sinAsignarCada.forEach(e => crearItemElemento(e, true));

    // 🔷 Recorrer estructura para elementos "uno para todos"
    apartadosEnOrden.forEach(function (apartadoRutaCompleta) {
        if (apartadoRutaCompleta === "(Seleccionar apartado)") return;
        const partes = apartadoRutaCompleta.split(">");
        const nivelActual = partes.length - 1;
        const nombreVisible = partes[partes.length - 1];

        const hayElementos = elementosTodos.some(e =>
            e.apartado === apartadoRutaCompleta || e.apartado.startsWith(apartadoRutaCompleta + ">")
        );

        if (hayElementos) {
            const header = document.createElement("h5");
            header.innerHTML = "&nbsp;".repeat(nivelActual * 4) + nombreVisible;
            header.style.fontFamily = "Arial";
            header.style.marginTop = nivelActual === 0 ? "16px" : "8px";
            header.style.marginBottom = "12px";
            header.style.color = color_text_titles;

            if (nivelActual === 0) {
                header.style.fontSize = "16px";
                header.style.fontWeight = "bold";
            } else if (nivelActual === 1) {
                header.style.fontSize = "14px";
            } else {
                header.style.fontSize = "13px";
                header.style.fontStyle = "italic";
            }

            infoList.appendChild(header);
        }

        const elementosEnEsteApartado = elementosTodos.filter(e => e.apartado === apartadoRutaCompleta);
        elementosEnEsteApartado.forEach(e => crearItemElemento(e, true));
    });

    // 🟨 TÍTULO PARA CADA ÍTEM
    if (elementosCada.length > 0) {
        const tituloCada = document.createElement("div");
        tituloCada.style.fontFamily = "Arial";
        tituloCada.style.fontSize = "14px";
        tituloCada.style.fontWeight = "bold";
        tituloCada.style.color = color_menu_titles;
        tituloCada.style.padding = "8px";
        tituloCada.style.margin = "20px 0 10px 0";
        tituloCada.textContent = "PARA CADA ÍTEM:";
        infoList.appendChild(tituloCada);
    }

    // 🔷 Recorrer estructura para elementos "uno para cada"
    apartadosEnOrden.forEach(function (apartadoRutaCompleta) {
        if (apartadoRutaCompleta === "(Seleccionar apartado)") return;
        const partes = apartadoRutaCompleta.split(">");
        const nivelActual = partes.length - 1;
        const nombreVisible = partes[partes.length - 1];

        const hayElementos = elementosCada.some(e =>
            e.apartado === apartadoRutaCompleta || e.apartado.startsWith(apartadoRutaCompleta + ">")
        );

        if (hayElementos) {
            const header = document.createElement("h5");
            header.innerHTML = "&nbsp;".repeat(nivelActual * 4) + nombreVisible;
            header.style.fontFamily = "Arial";
            header.style.marginTop = nivelActual === 0 ? "16px" : "8px";
            header.style.marginBottom = "12px";
            header.style.color = color_text_titles;

            if (nivelActual === 0) {
                header.style.fontSize = "16px";
                header.style.fontWeight = "bold";
            } else if (nivelActual === 1) {
                header.style.fontSize = "14px";
            } else {
                header.style.fontSize = "13px";
                header.style.fontStyle = "italic";
            }

            infoList.appendChild(header);
        }

        const elementosEnEsteApartado = elementosCada.filter(e => e.apartado === apartadoRutaCompleta);
        elementosEnEsteApartado.forEach(e => crearItemElemento(e, true));
    });
}




function crearItemElemento(element, mostrarApartados) {
    const listItem = document.createElement("div");
    listItem.style.display = "flex";
    listItem.style.alignItems = "center";
    listItem.style.marginBottom = "6px";

    listItem.style.marginBottom = "10px";
    listItem.style.fontFamily = "Arial";
    listItem.style.fontSize = "14px";

    const textoElemento = document.createElement("span");
    const mostrarScope = gestionarSelect?.value === "SI";
      textoElemento.textContent = mostrarScope
        ? `${element.name} (${element.type} | ${element.scope})`
        : `${element.name} (${element.type})`;

    // Botón subir
    const btnSubir = document.createElement("button");
    btnSubir.textContent = "▲"; 
    btnSubir.title = "Mover hacia arriba";
    btnSubir.style.border = "none";
    btnSubir.style.background = "none";
    btnSubir.style.color = "#666"; // gris
    btnSubir.style.fontSize = "14px";
    btnSubir.style.cursor = "pointer";
    btnSubir.style.marginRight = "1px";
    btnSubir.style.padding = "0";
    btnSubir.onclick = () => {
        moverElemento(element, -1);
        updateInfoList();
    };

    // Botón bajar
    const btnBajar = document.createElement("button");
    btnBajar.textContent = "▼"; 
    btnBajar.title = "Mover hacia abajo";
    btnBajar.style.border = "none";
    btnBajar.style.background = "none";
    btnBajar.style.color = "#666"; // gris
    btnBajar.style.fontSize = "14px";
    btnBajar.style.cursor = "pointer";
    btnBajar.style.marginRight = "8px";
    btnBajar.style.padding = "0";
    btnBajar.onclick = () => {
        moverElemento(element, +1);
        updateInfoList();
    };

    // Insertar flechas antes del texto
    listItem.appendChild(btnSubir);
    listItem.appendChild(btnBajar);
    listItem.appendChild(textoElemento);





    // Botón eliminar
    const deleteButton = document.createElement("button");
    deleteButton.textContent = "Eliminar";
    deleteButton.style.marginLeft = "10px";
    deleteButton.addEventListener("click", function () {
        infoElements.splice(infoElements.indexOf(element), 1);
        updateInfoList();
    });
    listItem.appendChild(deleteButton);

    // Botón editar (siempre presente)
    const editarBtnGeneral = document.createElement("button");
    editarBtnGeneral.textContent = "Editar";
    editarBtnGeneral.style.marginLeft = "10px";
    editarBtnGeneral.addEventListener("click", function () {
        openElementEditor(element);
    });
    listItem.appendChild(editarBtnGeneral);


    // Botón editar para desplegables
    if (element.type === "Desplegable selección única" || element.type === "Desplegable selección múltiple") {
        const editarBtn = document.createElement("button");
        editarBtn.textContent = "Editar";
        editarBtn.style.marginLeft = "10px";
        editarBtn.addEventListener("click", function () {
            openDesplegableEditor(element);
        });
        listItem.appendChild(editarBtn);
    }
/*
    // Botón editar para tablas
    if (element.type === "Tabla") {
        const editButton = document.createElement("button");
        editButton.textContent = "Editar";
        editButton.style.marginLeft = "10px";
        editButton.addEventListener("click", function () {
            openTableEditor(element);
        });
        listItem.appendChild(editButton);
    }

    if (element.type === "Texto o html (no editable)") {
        const editButton = document.createElement("button");
        editButton.textContent = "Editar";
        editButton.style.marginLeft = "10px";
        editButton.addEventListener("click", function () {
          openHtmlEditDialog(element.name);;
        });
        listItem.appendChild(editButton);
      }
*/

    // 🔥 Solo mostrar desplegable de apartados si corresponde
    if (mostrarApartados) {
        const apartadosValidos = obtenerApartadosConRutaCompleta();

        console.log("apartados válidos:", apartadosValidos);

        const selectApartado = document.createElement("select");
        selectApartado.style.marginLeft = "10px";
        selectApartado.style.fontFamily = "Arial";

        // 👉 Opción por defecto
        const opcionDefault = document.createElement("option");
        opcionDefault.value = "(Seleccionar apartado)";
        opcionDefault.textContent = "(Seleccionar apartado)";
        selectApartado.appendChild(opcionDefault);

        // 👉 Resto de apartados válidos
        apartadosValidos.forEach(function (linea) {
            const option = document.createElement("option");
            option.value = interpretarApartado(linea);
            option.textContent = interpretarApartado(linea);
            selectApartado.appendChild(option);
        });


        // 🔥 Asignar el valor actual
        selectApartado.value = element.apartado || "(Seleccionar apartado)";

        // 🔥 Marcar borde rojo si el apartado actual no existe
        if (!apartadosValidos.includes(element.apartado)) {
            selectApartado.style.border = "2px solid red";
        } else {
            selectApartado.style.border = "";
        }

        selectApartado.addEventListener("change", function () {
            element.apartado = selectApartado.value;
            selectApartado.style.border = "";

            updateInfoList();
        });

        listItem.appendChild(selectApartado);
    }

    infoList.appendChild(listItem);
}


function openHtmlEditDialog(elementName) {
  // Fondo semitransparente para bloquear clics
  const overlay = document.createElement("div");
  overlay.style.position = "fixed";
  overlay.style.top = "0";
  overlay.style.left = "0";
  overlay.style.width = "100%";
  overlay.style.height = "100%";
  overlay.style.backgroundColor = "rgba(0, 0, 0, 0.3)";
  overlay.style.zIndex = "100001";

  const dialog = document.createElement("div");
  dialog.className = "modal";
  dialog.style.position = "fixed";
  dialog.style.left = "50%";
  dialog.style.top = "50%";
  dialog.style.transform = "translate(-50%, -50%)";
  dialog.style.backgroundColor = "#fff";
  dialog.style.border = "1px solid #ccc";
  dialog.style.padding = "20px";
  dialog.style.zIndex = "100002"; // mayor que overlay y dialogDiv
  dialog.style.maxWidth = "700px";
  dialog.style.width = "90%";
  dialog.style.maxHeight = "80vh";
  dialog.style.overflow = "auto";
  dialog.style.boxShadow = "0 4px 10px rgba(0,0,0,0.3)";
  dialog.style.borderRadius = "8px";

  const title = document.createElement("h3");
  title.textContent = `Editar contenido de "${elementName}"`;
  dialog.appendChild(title);

  const textarea = document.createElement("textarea");
  textarea.style.width = "100%";
  textarea.style.height = "300px";
  textarea.value = tempElementTextos[elementName] || "";
  dialog.appendChild(textarea);

  const buttons = document.createElement("div");
  buttons.style.marginTop = "15px";
  buttons.style.textAlign = "right";

  const acceptButton = document.createElement("button");
  acceptButton.textContent = "Aceptar";
  acceptButton.onclick = () => {
    tempElementTextos[elementName] = textarea.value;
    document.body.removeChild(dialog);
    document.body.removeChild(overlay);
    //renderShowStepDialog(); // actualizar vista
  };
  buttons.appendChild(acceptButton);

  const cancelButton = document.createElement("button");
  cancelButton.textContent = "Cancelar";
  cancelButton.style.marginLeft = "10px";
  cancelButton.onclick = () => {
    document.body.removeChild(dialog);
    document.body.removeChild(overlay);
  };
  buttons.appendChild(cancelButton);

  dialog.appendChild(buttons);
  document.body.appendChild(overlay);
  document.body.appendChild(dialog);
}






function openDesplegableEditor(element) {
    const dialog = document.createElement("div");
    dialog.style.position = "fixed";
    dialog.style.left = "50%";
    dialog.style.top = "50%";
    dialog.style.transform = "translate(-50%, -50%)";
    dialog.style.background = "#fff";
    dialog.style.border = "1px solid #ccc";
    dialog.style.padding = "20px";
    dialog.style.zIndex = "1000";
    dialog.style.borderRadius = "8px";
    dialog.style.fontFamily = "Arial";
    dialog.style.width = "400px";

    const title = document.createElement("h3");
    title.textContent = "Editar opciones del desplegable";
    dialog.appendChild(title);

    const instruction = document.createElement("p");
    instruction.textContent = "Introduce una opción por línea. Puedes pegar una lista desde otro sitio.";
    instruction.style.fontSize = "14px";
    dialog.appendChild(instruction);

    const textarea = document.createElement("textarea");
    textarea.style.width = "100%";
    textarea.style.height = "200px";
    textarea.value = (element.opciones || []).join("\n");
    dialog.appendChild(textarea);

    dialog.appendChild(document.createElement("br"));
    dialog.appendChild(document.createElement("br"));

    const saveBtn = document.createElement("button");
    saveBtn.textContent = "Guardar";
    saveBtn.style.marginRight = "10px";
    saveBtn.onclick = () => {
        const values = textarea.value
            .split("\n")
            .map(line => line.trim())
            .filter(line => line !== "");
        element.opciones = values;
        document.body.removeChild(dialog);
    };
    dialog.appendChild(saveBtn);

    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = "Cancelar";
    cancelBtn.onclick = () => document.body.removeChild(dialog);
    dialog.appendChild(cancelBtn);

    document.body.appendChild(dialog);
}



function openTableEditor(element) {
  // Crear modal
  var overlay = document.createElement("div");
  overlay.style.position = "fixed";
  overlay.style.top = "0";
  overlay.style.left = "0";
  overlay.style.width = "100%";
  overlay.style.height = "100%";
  overlay.style.backgroundColor = "rgba(0, 0, 0, 0.4)";
  overlay.style.zIndex = "9999";

  var modal = document.createElement("div");
  modal.style.background = "white";
  modal.style.padding = "20px";
  modal.style.borderRadius = "8px";
  modal.style.width = "600px";
  modal.style.maxHeight = "80vh";
  modal.style.overflowY = "auto";
  modal.style.position = "absolute";
  modal.style.top = "50%";
  modal.style.left = "50%";
  modal.style.transform = "translate(-50%, -50%)";
  overlay.appendChild(modal);

  // Título
  var title = document.createElement("h3");
  title.textContent = `Editor de tabla - ${element.name}`;
  title.style.marginBottom = "10px";
  title.style.fontFamily = "Arial";
  modal.appendChild(title);
  console.log("Editor de tabla de openTableEditor");
  console.log(JSON.stringify(flowchartData));

  // Área para las filas
  var rowsLabel = document.createElement("label");
  rowsLabel.textContent = "Contenido de la tabla (una fila por línea, separa columnas por '|||'):";
  rowsLabel.style.fontFamily = "Arial";
  modal.appendChild(rowsLabel);
  modal.appendChild(document.createElement("br"));
  modal.appendChild(document.createElement("br"));

  var rowsTextarea = document.createElement("textarea");
  rowsTextarea.style.width = "100%";
  rowsTextarea.style.height = "150px";
  if (element.tabla && Array.isArray(element.tabla.rows)) {
    rowsTextarea.value = element.tabla.rows.map(row => row.join("\t")).join("\n");
  } else {
    rowsTextarea.value = ""; // vaciar si no hay tabla previa
  }

  modal.appendChild(rowsTextarea);
  modal.appendChild(document.createElement("br"));
  modal.appendChild(document.createElement("br"));

  var previewTable = document.createElement("table");
  previewTable.style.marginTop = "10px";
  previewTable.style.width = "100%";
  previewTable.style.borderCollapse = "collapse";
  previewTable.style.fontFamily = "Arial";
  previewTable.innerHTML = "";

  // Detectar si se pega una tabla de Excel/Word en la tabla de vista previa
  previewTable.addEventListener("paste", function (e) {
   
    e.preventDefault();

    var pastedText = (e.clipboardData || window.clipboardData).getData("text");

    if (!pastedText.includes("\t")) {
      alert("No se detecta contenido tabulado. ¿Has copiado una tabla de Excel o Word?");
      return;
    }

    var lines = pastedText.trim().split("\n");

    if (lines.length < 1) {
      alert("La tabla está vacía.");
      return;
    }

    var rawRows = lines.map(line => line.split("\t").map(cell => cell.trim()));


    rowsTextarea.value = rawRows.map(row => row.join("|||")).join("\n");


    renderPreviewTable();

    //pasteZone.textContent = "¡Tabla pegada! Puedes editarla arriba.";
  });


  function renderPreviewTable() {
    previewTable.innerHTML = "";

    const rows = rowsTextarea.value
      .split("\n")
      .map(line => line.split("|||").map(cell => cell.trim()))
      .filter(row => row.length > 0);

    const maxCols = Math.max(...rows.map(r => r.length));

    const tbody = document.createElement("tbody");
    rows.forEach(row => {
      const tr = document.createElement("tr");
      const completeRow = [...row];

      // Rellenar columnas vacías
      while (completeRow.length < maxCols) {
        completeRow.push("");
      }

      completeRow.forEach(cell => {
        const td = document.createElement("td");
        td.textContent = cell;
        td.style.border = "1px solid #ccc";
        td.style.padding = "5px";

        // Fondo gris para celdas con contenido
        if (cell.trim() !== "") {
          td.style.backgroundColor = "#f0f0f0";
        }

        tr.appendChild(td);
      });

      tbody.appendChild(tr);
    });

    previewTable.appendChild(tbody);
  }

  


  renderPreviewTable();

  rowsTextarea.addEventListener("input", renderPreviewTable);

  // Llamar una vez para mostrar la tabla inicial
  //renderPreviewTable();


  // Contenedor para previsualización
  var previewLabel = document.createElement("label");
  previewLabel.textContent = "Vista previa de la tabla (puedes pegar aquí una tabla de Word o Excel):";
  previewLabel.style.fontFamily = "Arial";
  modal.appendChild(previewLabel);
  modal.appendChild(previewTable);





  modal.appendChild(document.createElement("br"));


  var buttonContainer = document.createElement("div");
  buttonContainer.style.textAlign = "right"; // 👈 Alineación a la derecha
  modal.appendChild(buttonContainer);

  // Botón guardar
  var saveBtn = document.createElement("button");
  saveBtn.textContent = "Guardar tabla";
  saveBtn.addEventListener("click", function () {
    element.tabla.rows = rowsTextarea.value
      .split("\n")
      .map(line => line.split("\t").map(cell => cell.trim()))
      .filter(row => row.length > 0);

   //   if (element.tabla.headers.length === 0 && element.tabla.rows.length > 0) {
   //     element.tabla.rows = element.tabla.rows.slice(1); // Elimina la fila de encabezados de las filas normales
   //   }

    document.body.removeChild(overlay);
  });
  buttonContainer.appendChild(saveBtn);




  // Botón cancelar
  var cancelBtn = document.createElement("button");
  cancelBtn.textContent = "Cancelar";
  cancelBtn.style.marginLeft = "10px";
  cancelBtn.addEventListener("click", function () {
    document.body.removeChild(overlay);
  });
  buttonContainer.appendChild(cancelBtn);

  document.body.appendChild(overlay);
}
// Cargar elementos de información existentes al abrir el cuadro de diálogo
if (!isNew) {
    var selectedStepData = flowchartData.steps.find(function (step) {
        return step.id === stepId;
    });

    if (selectedStepData && Array.isArray(selectedStepData.infoElements)) {
      infoElements = JSON.parse(JSON.stringify(selectedStepData.infoElements || []));      // Cargar elementos de información

        // ⚠️ Copiar los valores del campo 'valor' al buffer temporal
        updateInfoList(); // Actualizar la lista visual
    }
}

      contentContainer.appendChild(document.createElement("br"));
      contentContainer.appendChild(document.createElement("br"));
} //Fin de if(tipo==='step')
      contentContainer.appendChild(document.createElement("br"));




      // Crear un botón de aceptar para guardar los valores
      var btnAceptar = document.createElement("button");
      btnAceptar.textContent = "Aceptar";
      btnAceptar.style.position = "absolute";
      btnAceptar.style.bottom = "10px";
      btnAceptar.style.right = "90px"; // Mover a la esquina inferior derecha
      btnAceptar.addEventListener("click", function () {
          // Obtener los valores de los campos
          var nombre = document.getElementById("nombre").value;

          var estructuraTexto;
          var estructuraApartados;
          var estructuraVacia;
          if (tipo === "step") {
              var gestionarValue = gestionarSelect.value;
              var conectarValue = conectarSelect.value;
              var instrucciones = document.getElementById("instrucciones").value;

              estructuraTexto = structureTextarea.value.trim();
              estructuraApartados = normalizarStructureTextareaValue(structureTextarea.value).trim();
              estructuraVacia = estructuraTexto === "";

              const apartadosValidos = estructuraVacia ? [] : obtenerApartadosConRutaCompleta();

              let hayErrores = false;

              if (!estructuraVacia) {
                  infoElements.forEach(e => {
                      if (!e.apartado ||
                          e.apartado === "(Seleccionar apartado)" ||
                          !apartadosValidos.includes(e.apartado)) {
                          hayErrores = true;
                      }
                  });
              }

              if (hayErrores) {
                  alert("Hay elementos sin apartado asignado o con apartado no válido. Por favor, corrígelos antes de continuar.");
                  return;
              }
            }

          if (isNew) {
              var canvas = document.getElementById('flowchartCanvas');
              var ctx = canvas.getContext('2d');
              var anchoCanvas = canvas.width;
              var altoCanvas = canvas.height;
              var scrollY = window.scrollY;
              var scrollX = window.scrollX;
              var anchoTarea = 100;
              var altoTarea = 50;
              var altoEncabezado = 350;
              var x = scrollX + 2*(anchoTarea + 100);
             // var y = altoCanvas - altoTarea + scrollY - altoEncabezado;
             var y = scrollY + altoTarea + 100;
              var notas = "";
              var fechaFin = "";

              if (x < 100) x = 100;
              if (x > (anchoCanvas - 100)) x = anchoCanvas - 100;
              if (y < 100) y = 100;
              if (y > (altoCanvas - 100)) y = altoCanvas - 100;

              var nuevoStepId = generarNuevoStepId();
              var nuevostep={};
              if (tipo === "step") {
                    nuevoStep = {
                        id: nuevoStepId,
                        label: nombre,
                        x: x,
                        y: y,
                        instrucciones: instrucciones,
                        infoElements: infoElements,
                        estructuraApartados: estructuraApartados,
                        receivedElements: receivedElements 
                    };
                }

              if (tipo === "milestone") {
                 nuevoStep = {
                      id: nuevoStepId,
                      label: nombre,
                      x: x,
                      y: y,
                  };
              }

              if (tipo === "step") {
                  var rol = rolSelect.value === "Otro" ? document.getElementById("otroRol").value : rolSelect.value;
                  nuevoStep.tipo = "step";
                  nuevoStep.rol = rol;
                  nuevoStep.Duracion = duracionInput.value;
                  nuevoStep.unidadduracion = unidadDuracionSelect.value;
                  if (!modoProcesosGenerales) {
                      if (notas.length > 0) nuevoStep.notas = notas;
                      if (esFechaValida(fechaFin.value)) {
                          nuevoStep.fechafin = fechaFin.value;
                      } else {
                          delete nuevoStep.fechafin;
                      }
                  }

                  if (gestionarValue === "SI") {
                      nuevoStep.is_a_multiple_task = "true";
                      if (conectarValue !== "NO") {
                          nuevoStep.multiple_task_following_previous = conectarValue;
                      }
                  }
              }

              if (tipo === "milestone") {
                  nuevoStep.tipo = "milestone";
              }

              flowchartData.steps.push(nuevoStep);
              selectedStep = [nuevoStepId];
              stepSelected = true;
              stepCanMove = true;
              expiredTime = true;

              
                // Recuperar referencia para que no sea undefined más abajo
                selectedStepData = flowchartData.steps.find(s => s.id === nuevoStepId);

          } else {
              var selectedStepData = flowchartData.steps.find(function (step) {
                  return step.id === selectedStep[0];
              });

              if (selectedStepData) {
                  if (tipo === "step") {
                      var rol = rolSelect.value === "Otro" ? document.getElementById("otroRol").value : rolSelect.value;
                      selectedStepData.label = nombre;
                      selectedStepData.rol = rol;
                      selectedStepData.Duracion = duracionInput.value;
                      selectedStepData.instrucciones = instrucciones;
                      selectedStepData.unidadduracion = unidadDuracionSelect.value;
                      infoElements.forEach(e => {
                          if (!e.apartado || estructuraVacia) {
                              delete e.apartado;
                          }
                      });
                      console.log("🔍 infoElements antes de guardar:", JSON.stringify(infoElements, null, 2));

                      selectedStepData.infoElements = infoElements;
                      selectedStepData.estructuraApartados = estructuraApartados;

                      if (gestionarValue === "SI") {
                          selectedStepData.is_a_multiple_task = "true";
                          if (conectarValue !== "NO") {
                              selectedStepData.multiple_task_following_previous = conectarValue;
                          } else {
                              delete selectedStepData.multiple_task_following_previous;
                          }
                      } else {
                          delete selectedStepData.is_a_multiple_task;
                          delete selectedStepData.multiple_task_following_previous;
                      }
                  }

                  if (tipo === "milestone") {
                      selectedStepData.label = nombre;
                      selectedStepData.instrucciones = instrucciones;
                  }
              }
          }

          if (tipo === "step") {
            selectedStepData.receivedElements = receivedElements;
        }




          document.body.removeChild(dialogDiv);
          drawFlowchart();
      });



  //   dialogDiv.appendChild(btnAceptar);

      var btnCancelar = document.createElement("button");
  btnCancelar.textContent = "Cancelar";
  btnCancelar.style.position = "absolute";
  btnCancelar.style.bottom = "10px";
  btnCancelar.style.right = "10px"; // Mover a la esquina inferior derecha

  // Manejador de eventos para el botón "Cancelar"
  btnCancelar.addEventListener("click", function () {
      // Cerrar el cuadro de diálogo sin guardar los datos
      document.body.removeChild(dialogDiv);
  });

  // Crear botones de pie fijos
  var buttonsContainer = document.createElement("div");
  buttonsContainer.style.display = "flex";
  buttonsContainer.style.justifyContent = "flex-end";
  buttonsContainer.style.gap = "10px";
  buttonsContainer.style.borderTop = "1px solid #ccc";
  buttonsContainer.style.paddingTop = "10px";
  buttonsContainer.style.marginTop = "10px";

  // Estilo limpio para los botones
  btnAceptar.style.position = "static";
  btnAceptar.style.margin = "0";

  btnCancelar.style.position = "static";
  btnCancelar.style.margin = "0";

  // Añadir botones al contenedor y al cuadro principal
  buttonsContainer.appendChild(btnCancelar);
  buttonsContainer.appendChild(btnAceptar);
  dialogDiv.appendChild(buttonsContainer);


}


function openElementEditor(element) {
  const overlay = document.createElement("div");
  overlay.style.position = "fixed";
  overlay.style.top = "0";
  overlay.style.left = "0";
  overlay.style.width = "100%";
  overlay.style.height = "100%";
  overlay.style.backgroundColor = "rgba(0, 0, 0, 0.3)";
  overlay.style.zIndex = "100001";

  const dialog = document.createElement("div");
  dialog.style.position = "fixed";
  dialog.style.left = "50%";
  dialog.style.top = "50%";
  dialog.style.transform = "translate(-50%, -50%)";
  dialog.style.background = "#fff";
  dialog.style.border = "1px solid #ccc";
  dialog.style.padding = "20px";
  dialog.style.zIndex = "100002";
  dialog.style.borderRadius = "8px";
  dialog.style.width = "500px";
  dialog.style.maxHeight = "80vh";
  dialog.style.overflowY = "auto";
  dialog.style.fontFamily = "Arial";

  const title = document.createElement("h3");
  title.textContent = `Editar "${element.name}"`;
  dialog.appendChild(title);


  const obligatorioCheckbox = document.createElement("input");
  if (element.type !== "Texto o html (no editable)") {
    const obligatorioLabel = document.createElement("label");
    obligatorioLabel.textContent = "¿Obligatorio?";
    obligatorioCheckbox.type = "checkbox";
    obligatorioCheckbox.checked = element.obligatorio !== false; // default true
    dialog.appendChild(obligatorioCheckbox);
    dialog.appendChild(obligatorioLabel);
    dialog.appendChild(document.createElement("br"));
    dialog.appendChild(document.createElement("br"));
  }


  const infoLabel = document.createElement("label");
  if (element.type === "Texto o html (no editable)") {
    infoLabel.textContent = "Texto o html:";
  }else{
    infoLabel.textContent = "Texto informativo (se mostrará junto al campo, puede ser html):";
    }
  dialog.appendChild(infoLabel);

  const infoTextarea = document.createElement("textarea");
  infoTextarea.style.width = "100%";
  infoTextarea.style.height = "150px";
  infoTextarea.value = element.informacion || "";
  dialog.appendChild(infoTextarea);
  dialog.appendChild(document.createElement("br"));
  dialog.appendChild(document.createElement("br"));


  if (element.type === "Desplegable selección única" || element.type === "Desplegable selección múltiple") {
    const opLabel = document.createElement("label");
    opLabel.textContent = "Opciones (una por línea):";
    dialog.appendChild(opLabel);
    const opTextarea = document.createElement("textarea");
    opTextarea.style.width = "100%";
    opTextarea.style.height = "150px";
    opTextarea.value = (element.opciones || []).join("\n");
    dialog.appendChild(opTextarea);
    dialog._opcionesTextarea = opTextarea;
  }

  if (element.type === "Tabla") {
  const tablaLabel = document.createElement("label");
  tablaLabel.textContent = "Estructura de tabla (una fila por línea, columnas separadas por '|||'):";
  dialog.appendChild(tablaLabel);

  const tablaTextarea = document.createElement("textarea");
  tablaTextarea.style.width = "100%";
  tablaTextarea.style.height = "150px";
  tablaTextarea.value = element.tabla?.rows?.map(r => r.join("|||")).join("\n") || "";
  dialog.appendChild(tablaTextarea);

  const tablaPreview = document.createElement("table");
  tablaPreview.style.marginTop = "10px";
  tablaPreview.style.width = "100%";
  tablaPreview.style.borderCollapse = "collapse";
  tablaPreview.style.fontFamily = "Arial";
  tablaPreview.style.border = "1px solid #ccc";
  dialog.appendChild(tablaPreview);

  function renderPreviewTableFromTextarea() {
    tablaPreview.innerHTML = "";
    const rows = tablaTextarea.value
      .split("\n")
      .map(line => line.split("|||").map(cell => cell.trim()))
      .filter(row => row.length > 0);

    const maxCols = Math.max(...rows.map(r => r.length), 1);

    rows.forEach(row => {
      const tr = document.createElement("tr");
      for (let i = 0; i < maxCols; i++) {
        const td = document.createElement("td");
        td.textContent = row[i] || "";
        td.style.border = "1px solid #ccc";
        td.style.padding = "4px";
        if ((row[i] || "").trim() !== "") {
          td.style.backgroundColor = "#f0f0f0";
        }
        tr.appendChild(td);
      }
      tablaPreview.appendChild(tr);
    });
  }

  tablaTextarea.addEventListener("input", renderPreviewTableFromTextarea);
  renderPreviewTableFromTextarea(); // Mostrar al cargar

  dialog._tablaTextarea = tablaTextarea;
}


  const btns = document.createElement("div");
  btns.style.textAlign = "right";
  btns.style.marginTop = "10px";

  const btnGuardar = document.createElement("button");
  btnGuardar.textContent = "Aceptar";
  btnGuardar.onclick = () => {
  if (element.type !== "Texto o html (no editable)") {
    if (!obligatorioCheckbox.checked) {
      element.optional = true; // Guardar solo si se desmarca
    } else {
      delete element.optional; // No guardar si está marcado
    }
  } else {
    element.optional = true; // No editables siempre opcionales
  }

  element.informacion = infoTextarea.value;



    if (dialog._opcionesTextarea) {
      element.opciones = dialog._opcionesTextarea.value
        .split("\n")
        .map(l => l.trim())
        .filter(l => l.length > 0);
    }

    if (dialog._tablaTextarea) {
      element.tabla = {
        rows: dialog._tablaTextarea.value
          .split("\n")
          .map(r => r.split("|||").map(c => c.trim()))
          .filter(r => r.length > 0)
      };
    }

    document.body.removeChild(dialog);
    document.body.removeChild(overlay);
  };

  const btnCancelar = document.createElement("button");
  btnCancelar.textContent = "Cancelar";
  btnCancelar.style.marginLeft = "10px";
  btnCancelar.onclick = () => {
    document.body.removeChild(dialog);
    document.body.removeChild(overlay);
  };

  btns.appendChild(btnGuardar);
  btns.appendChild(btnCancelar);
  dialog.appendChild(btns);
  document.body.appendChild(overlay);
  document.body.appendChild(dialog);
}

function showPathDialog(isNew, startStepId = "", endStepId = "", id = "", tipo="", condicion="", maxmin = "", duracion = "", unidadduracion = "", tipoduracion = "") {
// Crear un div para el cuadro de diálogo
var dialogDiv = document.createElement("div");
dialogDiv.style.display = "block";
dialogDiv.style.position = "fixed"; // Cambiar de "absolute" a "fixed"
dialogDiv.style.backgroundColor = "white";
dialogDiv.style.padding = "20px";
dialogDiv.style.border = "1px solid #ccc";
dialogDiv.style.borderRadius = "5px";
dialogDiv.style.left = "50%";
dialogDiv.style.top = "50%";
dialogDiv.style.transform = "translate(-50%, -50%)";
document.body.appendChild(dialogDiv);


    // Mostrar el campo de "nombre" en una línea nueva
    if (tipo === "path") {
    var condicionLabel = document.createElement("label");
    condicionLabel.for = "condicion";
    condicionLabel.textContent = "Condición (dejar vacío si no hay): ";
    condicionLabel.style.fontFamily = "Arial";
    condicionLabel.style.fontSize = "14px";
    dialogDiv.appendChild(condicionLabel);

    var condicionInput = document.createElement("input");
    condicionInput.type = "text";
    condicionInput.id = "nombre";
    condicionInput.value = condicion || "";
    condicionInput.style.fontFamily = "Arial";
    dialogDiv.appendChild(condicionInput);

        // Agregar un retorno de carro
        dialogDiv.appendChild(document.createElement("br"));
    dialogDiv.appendChild(document.createElement("br"));
    }
    // Mostrar el campo de "duración" en una línea nueva
    if (tipo === "ligtime") {
    // Crear un label para el tipo de limitación
    var maxminLabel = document.createElement("label");
    maxminLabel.for = "maxmin";
    maxminLabel.textContent = "Tipo de limitación: ";
    maxminLabel.style.fontFamily = "Arial";
    maxminLabel.style.fontSize = "14px";
    dialogDiv.appendChild(maxminLabel);

    // Crear un desplegable (select) para elegir entre "Máximo" y "Mínimo"
    var maxminSelect = document.createElement("select");
    maxminSelect.id = "maxmin";
    maxminSelect.style.fontFamily = "Arial";
    dialogDiv.appendChild(maxminSelect);

    // Crear las opciones para el desplegable "maxmin"
    var maxminOpcionMaximo = document.createElement("option");
    maxminOpcionMaximo.value = "MX";
    maxminOpcionMaximo.text = "Máximo";
    maxminSelect.appendChild(maxminOpcionMaximo);

    var maxminOpcionMinimo = document.createElement("option");
    maxminOpcionMinimo.value = "MN";
    maxminOpcionMinimo.text = "Mínimo";
    maxminSelect.appendChild(maxminOpcionMinimo);

    maxminSelect.value=maxmin || "MX";

    // Agregar un retorno de carro
    dialogDiv.appendChild(document.createElement("br"));
    dialogDiv.appendChild(document.createElement("br"));

    // Crear un label para la duración
    var duracionLabel = document.createElement("label");
    duracionLabel.for = "duracion";
    duracionLabel.textContent = "Duración: ";
    duracionLabel.style.fontFamily = "Arial";
    duracionLabel.style.fontSize = "14px";
    dialogDiv.appendChild(duracionLabel);

    // Crear un campo de entrada de tipo número para la duración
    var duracionInput = document.createElement("input");
    duracionInput.type = "number";
    duracionInput.id = "duracion";
    duracionInput.value = duracion || "";
    duracionInput.style.fontFamily = "Arial";
    duracionInput.setAttribute("maxlength", "5"); // Establecer la longitud máxima en 5 caracteres
    duracionInput.style.width = "50px"; // Establecer el ancho deseado en píxeles
    dialogDiv.appendChild(duracionInput);




    // Crear un desplegable (select) para elegir entre "días", "meses" y "años"
    var unidadDuracionSelect = document.createElement("select");
    unidadDuracionSelect.id = "unidadDuracion";
    unidadDuracionSelect.style.fontFamily = "Arial";
    dialogDiv.appendChild(unidadDuracionSelect);

    // Crear las opciones para el desplegable "Unidad de duración"
    var unidadDuracionOpcionDias = document.createElement("option");
    unidadDuracionOpcionDias.value = "n";
    unidadDuracionOpcionDias.text = "Días naturales";
    unidadDuracionSelect.appendChild(unidadDuracionOpcionDias);

    var unidadDuracionOpcionDias = document.createElement("option");
    unidadDuracionOpcionDias.value = "h";
    unidadDuracionOpcionDias.text = "Días hábiles";
    unidadDuracionSelect.appendChild(unidadDuracionOpcionDias);

    var unidadDuracionOpcionDias = document.createElement("option");
    unidadDuracionOpcionDias.value = "l";
    unidadDuracionOpcionDias.text = "Días laborables";
    unidadDuracionSelect.appendChild(unidadDuracionOpcionDias);

    var unidadDuracionOpcionMeses = document.createElement("option");
    unidadDuracionOpcionMeses.value = "m";
    unidadDuracionOpcionMeses.text = "Meses";
    unidadDuracionSelect.appendChild(unidadDuracionOpcionMeses);

    var unidadDuracionOpcionAnos = document.createElement("option");
    unidadDuracionOpcionAnos.value = "a";
    unidadDuracionOpcionAnos.text = "Años";
    unidadDuracionSelect.appendChild(unidadDuracionOpcionAnos);

    unidadDuracionSelect.value = unidadduracion || "n";

        // Agregar un retorno de carro
        dialogDiv.appendChild(document.createElement("br"));
    dialogDiv.appendChild(document.createElement("br"));

            // Crear un label para el inicio o fin
            var tipoDuracionLabel = document.createElement("label");
        tipoDuracionLabel.for = "tipoDuracion";
        tipoDuracionLabel.textContent = "Desde/hasta el inicio o fin de la tarea (1ª-2ª): ";
        tipoDuracionLabel.style.fontFamily = "Arial";
        tipoDuracionLabel.style.fontSize = "14px";
    dialogDiv.appendChild(tipoDuracionLabel);

    // Crear un desplegable (select) para elegir tipo de duración
    var tipoDuracionSelect = document.createElement("select");
    tipoDuracionSelect.id = "tipoDuracion";
    tipoDuracionSelect.style.fontFamily = "Arial";
    dialogDiv.appendChild(tipoDuracionSelect);


    // Crear las opciones para el desplegable de inicio o fin
    var tipoDuracionOpcionFF = document.createElement("option");
    tipoDuracionOpcionFF.value = "FF";
    tipoDuracionOpcionFF.text = "Fin-Fin";
    tipoDuracionSelect.appendChild(tipoDuracionOpcionFF);

    var tipoDuracionOpcionII = document.createElement("option");
    tipoDuracionOpcionII.value = "II";
    tipoDuracionOpcionII.text = "Inicio-Inicio";
    tipoDuracionSelect.appendChild(tipoDuracionOpcionII);

    var tipoDuracionOpcionFI = document.createElement("option");
    tipoDuracionOpcionFI.value = "FI";
    tipoDuracionOpcionFI.text = "Fin-Inicio";
    tipoDuracionSelect.appendChild(tipoDuracionOpcionFI);

    var tipoDuracionOpcionIF = document.createElement("option");
    tipoDuracionOpcionIF.value = "IF";
    tipoDuracionOpcionIF.text = "Inicio-Fin";
    tipoDuracionSelect.appendChild(tipoDuracionOpcionIF);

    tipoDuracionSelect.value = tipoduracion || "FF";


    // Agregar un retorno de carro
    dialogDiv.appendChild(document.createElement("br"));
    dialogDiv.appendChild(document.createElement("br"));
    dialogDiv.appendChild(document.createElement("br"));
}


    // Crear un botón de aceptar para guardar los valores
    var btnAceptar = document.createElement("button");
    btnAceptar.textContent = "Aceptar";
    btnAceptar.style.position = "absolute";
    btnAceptar.style.bottom = "10px";
    btnAceptar.style.right = "10px"; // Mover a la esquina inferior derechagenerarNuevoPathId
    btnAceptar.addEventListener("click", function () {
        // Obtener los valores de los campos
        var nuevaCondicion = condicion;
        if (tipo === "path") {
          nuevaCondicion =condicionInput.value;
        }
        
        var nuevaDuracion = duracion;
        if (tipo === "ligtime") {
          nuevaDuracion=duracionInput.value;
        }


        // Dependiendo de si es una operación nueva o de edición, realiza la acción correspondiente
        if (isNew) {
            // Realiza la acción para una operación nueva
            var nuevoPathId = generarNuevoPathId('path'); // Generar un ID único para el nuevo path

            var nuevoPath = {
                id: nuevoPathId,
                startStep: startStepId,
                endStep: endStepId,
            };

            if (tipo === "path") {
              nuevoPath.condicion=nuevaCondicion;
              nuevoPath.type="path";
            }
            if (tipo === "ligtime") {
              nuevoPath.type="ligtime";
              nuevoPath.duracion=nuevaDuracion;
              nuevoPath.unidadduracion=unidadDuracionSelect.value;
              nuevoPath.tipoduracion=tipoDuracionSelect.value;
              nuevoPath.maxmin=maxminSelect.value;
            }

            if (flowchartData.hasOwnProperty('paths')) {
                flowchartData.paths.push(nuevoPath);
            } else {
                flowchartData.paths = [nuevoPath];
            }

            // ... (resto del código de manejo de paths nuevos)
        } else {


            // Realiza la acción para la edición de una operación existente
            var selectedPathData = flowchartData.paths.find(function (path) {
                return path.id === selectedPath;
            });
            

            if (selectedPathData) {
              if ((tipo === "path")&&(nuevaCondicion !== "")) {
                selectedPathData.condicion = nuevaCondicion; // Actualiza la condición
              }
              if ((tipo === "ligtime")&&(nuevaDuracion !== "")) {
                selectedPathData.duracion = nuevaDuracion; // Actualiza la duración
                selectedPathData.unidadduracion = unidadDuracionSelect.value;
                selectedPathData.tipoduracion=tipoDuracionSelect.value;
                selectedPathData.maxmin=maxminSelect.value;
              }
            }
        }

        // Cerrar el cuadro de diálogo
        document.body.removeChild(dialogDiv);
        guardarEstado();
        drawFlowchart();
    });
    dialogDiv.appendChild(btnAceptar);
}












        function generarNuevoStepId() {
          var nuevoId = "step1"; // Valor inicial para el nuevo ID
          if (flowchartData.hasOwnProperty('steps')) {
            var steps = flowchartData.steps;
            // Buscar el siguiente número disponible para el ID
            for (var i = 0; i < steps.length; i++) {
              var stepId = steps[i].id;
              var stepNumber = parseInt(stepId.substring(4));

                if (!isNaN(stepNumber) && stepNumber >= parseInt(nuevoId.substring(4))) {
                 nuevoId = "step" + (stepNumber + 1);
                }
            }
          }else{
            nuevoId="step1";
          }
        return nuevoId;
        }

        function createPath(pathtype){
          if (flowchartData.hasOwnProperty('steps')) {
            document.getElementById("deleteStepOrPathButton").style.backgroundColor="#4c77af";
            numClicksAfterCreatePathButton=0;
            createPathOn=true;
            if(pathtype=='path') {
              document.getElementById("createPathButton").style.backgroundColor="#839192";
              document.getElementById("createLigtimeButton").style.backgroundColor="#4c77af";
            }
            if(pathtype=='ligtime'){
              createligtimeOn=true;
              document.getElementById("createLigtimeButton").style.backgroundColor="#839192";
              document.getElementById("createPathButton").style.backgroundColor="#4c77af";
            }
            document.getElementById("messages").innerHTML = "Haga click en el primer proceso a relacionar";
          }
        }




        function insertarNuevoPath(startStepId, endStepId, condicion, tipo) {
            eliminarPath(startStepId, endStepId, tipo);

            var nuevoPathId = generarNuevoPathId('path'); // Generar un ID único para el nuevo path

            var nuevoPath = {};
            var nuevoPath = {
            id: nuevoPathId,
            startStep: startStepId,
            endStep: endStepId,
            condicion: condicion,
            type: tipo
            };


            if (flowchartData.hasOwnProperty('paths')) {
              flowchartData.paths.push(nuevoPath);
            }else{
              flowchartData.paths=[{id: nuevoPathId, startStep: startStepId, endStep: endStepId, condicion: condicion, type: tipo}];
            }
            selectedPath = nuevoPathId;
            selectedStep=null;
            guardarEstado();
            drawFlowchart();
            // Mostrar el array actualizado
        }

        function generarNuevoPathId(prefix) {
          var nuevoId = prefix + '1'; // Valor inicial para el nuevo ID
          if (flowchartData.hasOwnProperty('paths')) {
            var paths = flowchartData.paths;


            // Buscar el siguiente número disponible para el ID
            for (var i = 0; i < paths.length; i++) {
                var pathId = paths[i].id;
                var pathNumber = parseInt(pathId.substring(4));

                if (!isNaN(pathNumber) && pathNumber >= parseInt(nuevoId.substring(4))) {
                    nuevoId = prefix + (pathNumber + 1);
                }
            }
          }
         return nuevoId;
        }

        function eliminarPath(startStep, endStep, tipo){
          if (flowchartData.hasOwnProperty('paths')) {
            var paths = flowchartData.paths;
            for (var i = 0; i < paths.length; i++) {
                var path = paths[i];
                if (path.startStep === startStep && path.endStep === endStep && path.type === tipo) {
                paths.splice(i, 1);
                break;
                }
            }
          }
            guardarEstado();
            drawFlowchart();
        }

        //Devolver los botones al estado original
        function finishPathProcess(){
            createPathOn=false;
            document.getElementById("createPathButton").style.backgroundColor="#4c77af";
            document.getElementById("deleteStepOrPathButton").style.backgroundColor="#4c77af";
        }

        function setupFlowChartName(){
            flowchartData.title= document.getElementById("flowChartName").value;
        }



// Definir una variable global para almacenar los datos cargados
var datosCargados = [];



function saveFlowChart() {
  var input = document.createElement('input');
  input.type = 'file';
  input.accept = '.txt';

  input.addEventListener('change', function (event) {
    var archivoCargado = event.target.files[0];

    // Verificar si el nombre del archivo es 'DatosGenerales.txt'
    if ((!modoProcesosGenerales)&&(archivoCargado.name === 'ProcesosGlobales.txt')) {
      showAlertOnCanvas("En modo de seguimiento de proyectos no se puede guardar datos en el archivo de procesos generales. Por favor, elija el archivo de proyectos para guardar sus datos.");
      //alert("En modo de seguimiento de proyectos no se puede guardar datos en el archivo de procesos generales. Por favor, elija el archivo de proyectos para guardar sus datos.");
      return; // No continuar con el procesamiento y salir de la función
    }

    // Leer el contenido del archivo cargado
    var lector = new FileReader();
    lector.onload = function (eventoLector) {
      var contenidoCargado = eventoLector.target.result;

      // Procesar el contenido cargado
      datosCargados = JSON.parse(contenidoCargado);

      // Procesar y modificar los datos según sea necesario


      var datos = flowchartData;

      if(modoProcesosGenerales){
      // Recorrer todos los steps y eliminar "fechafin" si existe
      datos.steps.forEach(step => {
        if (step.fechafin) {
            delete step.fechafin;
        }
      });

      // Eliminar "importeEstimado", "fechaInicioProyecto" y "asignacionRoles" del objeto principal si existen
      delete datos.importeEstimado;
      delete datos.fechaInicioProyecto;
      delete datos.asignacionRoles;
      delete datos.descripcionProyecto;
      }


      var tituloExistente = false;
      for (var i = 0; i < datosCargados.length; i++) {
        if (datosCargados[i].title === datos.title) {
          datosCargados[i] = datos;
          tituloExistente = true;
          break;
        }
      }

      if (!tituloExistente) {
        datosCargados.push(datos);
      }
      copiarAlPortapapeles(Ruta);
      // Guardar los datos actualizados en el mismo archivo
      guardarArchivoComo(JSON.stringify(datosCargados), archivoCargado.name);
    };

    lector.readAsText(archivoCargado);
  });

  input.style.display = 'none';

  // Agregar el input al DOM y simular un clic en él para cargar el archivo
  document.body.appendChild(input);
  input.click();
}

async function guardarArchivoComo(contenido, nombreArchivo) {
  try {
    const blob = new Blob([contenido], { type: 'text/plain;charset=utf-8' });
    const options = {
      types: [
        {
          description: 'Archivos de texto',
          accept: { 'text/plain': ['.txt'] },
        },
      ],
      suggestedName: nombreArchivo,
    };

    const fileHandle = await window.showSaveFilePicker(options);
    // Después de que el usuario haya elegido el nombre, verifica si es 'DatosGenerales.txt'
    if ((!modoProcesosGenerales)&&(fileHandle.name === 'ProcesosGlobales.txt')) {
      showAlertOnCanvas("En modo de seguimiento de proyectos no se puede guardar datos en el archivo de procesos generales. Por favor, elija el archivo de proyectos para guardar sus datos.");
      return; // Salir de la función sin guardar el archivo
    }
    const writable = await fileHandle.createWritable();
    await writable.write(blob);
    await writable.close();
  } catch (error) {
    console.error('Error al guardar el archivo:', error);
    showAlertOnCanvas("ERROR: El archivo NO se ha guardado correctamente. Por favor, vuelva a intentarlo (a veces el problema es el tiempo excesivo en la selección de archivos).");
  }
}

function showAlertOnCanvas(message) {
  // Configura el ancho y alto para el mensaje en el canvas
  const width = 600;
  const height = 120;
  const padding = 10;
  const lineHeight = 16; // Altura de línea para separar el texto
  const borderWidth = 5; // Ancho del borde

  // Dibuja el fondo blanco con borde rojo
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, width, height);
  ctx.strokeStyle = 'red';
  ctx.lineWidth = borderWidth;
  ctx.strokeRect(borderWidth / 2, borderWidth / 2, width - borderWidth, height - borderWidth);

  // Configura el texto
  ctx.font = '12px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = 'black';

  // Divide el texto en líneas
  const words = message.split(' ');
  const lines = [];
  let currentLine = words[0];

  for (let i = 1; i < words.length; i++) {
    const word = words[i];
    const measureWidth = ctx.measureText(currentLine + " " + word).width;
    if (measureWidth < width - padding * 2 - borderWidth) {
      currentLine += " " + word;
    } else {
      lines.push(currentLine);
      currentLine = word;
    }
  }
  lines.push(currentLine); // Agrega la última línea

  // Calcula la posición inicial del texto para centrarlo verticalmente
  const textHeight = lines.length * lineHeight;
  let y = (height - textHeight) / 2 + lineHeight / 2;

  // Dibuja el texto línea por línea
  lines.forEach((line) => {
    ctx.fillText(line, width / 2, y);
    y += lineHeight;
  });

  // Dibuja la aspa
  const crossSize = 10; // Tamaño de la aspa
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 3;
  // Dibuja la primera línea de la aspa
  ctx.beginPath();
  ctx.moveTo(width - padding - crossSize * 2, padding);
  ctx.lineTo(width - padding - crossSize, padding + crossSize);
  ctx.stroke();
  // Dibuja la segunda línea de la aspa
  ctx.beginPath();
  ctx.moveTo(width - padding - crossSize, padding);
  ctx.lineTo(width - padding - crossSize * 2, padding + crossSize);
  ctx.stroke();
}






function copiarAlPortapapeles(texto) {
      const elementoTemporal = document.createElement("textarea");
      elementoTemporal.value = texto;
      document.body.appendChild(elementoTemporal);
      elementoTemporal.select();
      document.execCommand("copy");
      document.body.removeChild(elementoTemporal);
    }

        

//drawFlowchart();


function loadFlowChart() {
  copiarAlPortapapeles(Ruta);
  var input = document.createElement('input');
  input.type = 'file';
  input.accept = '.txt';
  input.placeholder = 'Seleccionar archivo';

  input.addEventListener('change', function(event) {
    var archivoCargado = event.target.files[0];

    var lector = new FileReader();
    lector.onload = function(eventoLector) {
      var contenidoCargado = eventoLector.target.result;

      var datosCargados = JSON.parse(contenidoCargado);
      chooseFlowChart(datosCargados, archivoCargado.name);
    };

    lector.readAsText(archivoCargado);
  });

  input.style.display = 'none';

  document.body.appendChild(input);
  input.click();
}




function chooseFlowChart(datosCargados, archivoSeleccionado) {
  var titleList = [];

  for (var i = 0; i < datosCargados.length; i++) {
    titleList.push(datosCargados[i].title);
  }

  var dialog = document.createElement('dialog');
  dialog.style.display = 'block';

  var titleLabel = document.createElement('div');
  titleLabel.textContent = 'Procesos existentes:';
  titleLabel.style.fontWeight = 'bold';
  dialog.appendChild(titleLabel);
  dialog.appendChild(document.createElement("br"));

  var listContainer = document.createElement('div');
  listContainer.style.maxHeight = '300px';
  listContainer.style.overflowY = 'auto';

  var selectedItem = null;  // Variable para el elemento seleccionado actualmente

  for (var i = 0; i < titleList.length; i++) {
    var listItem = document.createElement('div');
    listItem.textContent = titleList[i];
    listItem.style.padding = '5px';
    listItem.style.cursor = 'pointer';

    listItem.addEventListener('click', function(event) {
      if (selectedItem) {
        selectedItem.classList.remove('selected');  // Desmarcar el elemento previamente seleccionado
      }
      selectedItem = event.currentTarget;
      selectedItem.classList.add('selected');  // Marcar el elemento seleccionado actualmente

      // Cambiar el estilo del elemento seleccionado
      selectedItem.style.color = 'white';
      selectedItem.style.background = 'black';

      // Cambiar el estilo de los elementos no seleccionados
      var allItems = listContainer.children;
      for (var j = 0; j < allItems.length; j++) {
        if (allItems[j] !== selectedItem) {
          allItems[j].style.color = 'black';
          allItems[j].style.background = 'white';
        }
      }
    });

    listContainer.appendChild(listItem);
  }
 

  var loadButton = document.createElement('button');
  loadButton.textContent = 'Cargar';
  loadButton.addEventListener('click', function() {
    loadSelectedItem();
  });
  loadButton.style.float = 'left';
  loadButton.style.marginTop = '10px';
  loadButton.style.marginLeft = '10px';

  var deleteButton = document.createElement('button');
  deleteButton.textContent = 'Eliminar';
  deleteButton.addEventListener('click', function() {
    confirmDelete();
  });
  deleteButton.style.float = 'left';
  deleteButton.style.marginTop = '10px';
  deleteButton.style.marginLeft = '10px';


  var cancelButton = document.createElement('button');
  cancelButton.textContent = 'Cancelar';
  cancelButton.addEventListener('click', function() {
    dialog.remove();
  });
  cancelButton.style.float = 'right';
  cancelButton.style.marginTop = '10px';
  cancelButton.style.marginLeft = '10px';
  cancelButton.style.marginRight = '10px';

  

  dialog.appendChild(listContainer);

  dialog.appendChild(document.createElement("br"));
  dialog.appendChild(loadButton);
  if (!((!modoProcesosGenerales)&&(archivoSeleccionado === 'ProcesosGlobales.txt'))) {
    dialog.appendChild(deleteButton);
  }
  dialog.appendChild(cancelButton);

  document.body.appendChild(dialog);
  dialog.showModal();

  function loadSelectedItem() {
    if (selectedItem) {
      var selectedTitle = selectedItem.textContent;
      var selectedFlowchart = datosCargados.find(function(item) {
        return item.title === selectedTitle;
      });

      if (selectedFlowchart) {
        // Cargar el elemento seleccionado
        flowchartData = selectedFlowchart;
        // Ejecutar la función externa drawFlowchart() pasando flowchartData como argumento
        //historial = [];
        //historialRehacer = [];
        historial.push(JSON.parse(JSON.stringify(flowchartData)));
        guardarEstado();
        drawFlowchart(flowchartData);
      }
    }
    dialog.remove();
  }

  function confirmDelete() {
    if (selectedItem) {
      var selectedTitle = selectedItem.textContent;
      var confirmation = confirm('¿Estás seguro de que deseas eliminar el proceso <'+selectedTitle+'>?');
      if (confirmation) {
        deleteSelectedItem();
      }
    }
  }

  function deleteSelectedItem() {
    if (selectedItem) {
      var selectedTitle = selectedItem.textContent;
      var selectedFlowchartIndex = datosCargados.findIndex(function(item) {
        return item.title === selectedTitle;
      });

      if (selectedFlowchartIndex !== -1) {
        datosCargados.splice(selectedFlowchartIndex, 1);
        var contenido = JSON.stringify(datosCargados);
        const textoRuta = Ruta;
        const mensaje = "Para guargar los resultados selecciona en la próxima pantalla el "+textoArchivo+"  "+textoRuta+nombreArchivo+". La ruta se copiará en el portapapeles para que puedas pegarla en la búsqueda.";
     const opcion = confirm(mensaje);
      if (opcion) {
        copiarAlPortapapeles(textoRuta);
         guardarArchivoComo(contenido, nombreArchivo);
      }

        selectedItem.remove();
        selectedItem = null;
      }
    }
  }
}


function canvasToImage(canvas, filename){
           // Crea una nueva imagen en formato PNG
           var ctx = canvas.getContext('2d');
          var image = new Image();
          image.src = canvas.toDataURL('image/png');
  
          // Crea un enlace para descargar la imagen
         var a = document.createElement('a');
         a.href = image.src;
          a.download = filename || 'canvas_image.png';
  
         // Haz clic en el enlace para iniciar la descarga
          a.click();
        }

            // Agrega un manejador de clic al botón
    var saveButton = document.getElementById('saveCanvasImageButton');
    var canvas = document.getElementById('ctx'); // Reemplaza 'tuCanvas' con el ID de tu canvas

    saveButton.addEventListener('click', function () {
        canvasToImage(canvas, 'DiagramaFlujo.png');
    });



    function reorganizarSteps() {
  // Definir las constantes de espaciado vertical y horizontal
  const verticalSpacing = 85;
  const horizontalSpacing = 235;
  const marginTop = 80;

  // Encontrar el primer paso
  const stepsFechados = asignarFechas(flowchartData);

  //const primerPaso = stepsFechados[0];

  const primerPaso = flowchartData.steps.find(step => step.id === Object.keys(stepsFechados)[0]);
  
  if (!primerPaso) {
    console.error('No se encontró el primer paso.');
    return flowchartData;
  }

  // Función para comprobar y ajustar la posición de un step
  function ajustarPosicionx(step) {

    // Verificar si hay otro step en la misma posición (x, y)
    while (flowchartData.steps.some(s => s !== step && s.x === step.x && s.y === step.y)) {
      step.x += horizontalSpacing;
    }
  }

  // Establecer las coordenadas del primer paso
  primerPaso.x = primerPaso.x || marginLeft;
  primerPaso.y = primerPaso.y || marginTop;

  // Recorrer los steps y ajustar sus posiciones
// Recorrer los paths y ajustar las coordenadas Y de los endSteps
for (const path of flowchartData.paths) {
    const startStep = flowchartData.steps.find(step => step.id === path.startStep);
    const endStep = flowchartData.steps.find(step => step.id === path.endStep);

    if (!startStep || !endStep) {
      continue; // Salta los paths con pasos no encontrados
    }

    // Establecer las coordenadas Y del endStep más abajo que el startStep
    endStep.y = startStep.y + verticalSpacing;
    endStep.x = primerPaso.x;
  }

  for (const step of flowchartData.steps) {
    if (step === primerPaso) {
      continue; // Saltar el primer paso
    }

    ajustarPosicionx(step);
  }
  guardarEstado();
  drawFlowchart();
}


function tareaRealizada() {
     if(stepSelected=true){
              if (flowchartData.hasOwnProperty('steps')) {
            var steps = flowchartData.steps;
            for (var i = 0; i < steps.length; i++) {
             if (selectedStep.includes(steps[i].id)) {

              if (steps[i].hasOwnProperty('notas')) {
                delete steps[i].notas;
              }

              if (steps[i].hasOwnProperty('fechafin')) {
                delete steps[i].fechafin;
              }else{
                const fechaCompleta = new Date();
                const fecha = obtenerFormatoFecha(fechaCompleta);
                const okornot = fechaRealizada(steps[i].id, fecha);
                  if(fechaRealizada(steps[i].id, fecha)){
                    steps[i].fechafin=fecha;
                  }
              }
                 break;
             }
            }
          }
        }
        if(pathSelected=true){
          if (flowchartData.hasOwnProperty('paths')) {
            var paths = flowchartData.paths;
            for (var i = 0; i < paths.length; i++) {
             if (paths[i].id === selectedPath) {
              if (paths[i].hasOwnProperty('closed')) {
                delete paths[i].closed;
              }else{
                paths[i].closed=true;

              }
                 break;
             }
            }
          }
        }
        guardarEstado();
        drawFlowchart();
      }










      function fechaRealizada(stepId, fecha) {
          // Poner código para comprobar que steps anteriores no tienen fecha posterior o steps posteriores no tengan fecha anterior. En caso contrario mostrar mensaje de error.
        return true;
    }



      function obtenerFormatoFecha(fechaCompleta) {
    const year = fechaCompleta.getFullYear();
    const month = String(fechaCompleta.getMonth() + 1).padStart(2, '0'); // Sumamos 1 al mes porque los meses en JavaScript van de 0 a 11
    const day = String(fechaCompleta.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}



        var canvas = document.getElementById('flowchartCanvas');
        var ctx = canvas.getContext('2d');


        var stepsHeight=[];

        //**********************************************************************************************************//
        function drawFlowchart() {


            if (flowchartData==null){return;};

            document.getElementById("flowChartName").value=flowchartData.title;

            let newCanvasWidth=600;
            let newCanvasHeight=800;
            if (flowchartData.hasOwnProperty('steps')) {
            flowchartData.steps.forEach(function (step) {
              if (step.x > newCanvasWidth-250) {
                newCanvasWidth=step.x+250;
             }
             if (step.y > newCanvasHeight-250) {
              newCanvasHeight=step.y+250;
             }
            });
            canvas.width= newCanvasWidth;
            canvas.height= newCanvasHeight;
          }

          if(flowchartData.hasOwnProperty("estadoProyecto")&&(flowchartData.estadoProyecto==="cerrado")){
              ctx.fillStyle = "lightgrey";
            }else{
              ctx.fillStyle = "white";
            }

            //ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillRect(0, 0, canvas.width, canvas.height);



			ctx.font = "11px Arial";

      if(flowchartData.hasOwnProperty("estadoProyecto")&&(flowchartData.estadoProyecto==="cerrado")){
            //ctx.strokeStyle = 'green';
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'black';
                // Configurar el estilo de texto
                ctx.font = '12px Arial';
                ctx.fillStyle = 'green';
                ctx.textAlign = 'left';
            ctx.fillText("PROYECTO CERRADO", 10, 20);
            //ctx.strokeStyle = '#000000';
            }

      if (flowchartData.hasOwnProperty('steps')) {

            //Calculamos las fechas:
            const stepsConFechas = asignarFechas(flowchartData);

            flowchartData.steps.forEach(function (step) {
                const stepId = step.id;
                //Separate text in different lines depending on text length:
                const anchoMaximo = 180;
                // Dividir el texto en palabras
                const palabras = step.label.split(' ');
                // Variable para almacenar las líneas de texto
                let lineas = [''];
                // Iterar sobre las palabras
                for (const palabra of palabras) {
                const lineaActual = lineas[lineas.length - 1];
                const textoLineaActual = lineaActual + ' ' + palabra;
                // Obtener el ancho del texto actual
                const anchoTexto = ctx.measureText(textoLineaActual).width;
                if (anchoTexto <= anchoMaximo) {
                    // Agregar la palabra a la línea actual si no excede el ancho máximo
                    lineas[lineas.length - 1] = textoLineaActual.trim();
                } else {
                    // Crear una nueva línea con la palabra actual
                    lineas.push(palabra);
                }
                }
                // Obtener el ancho y alto del rectángulo que engloba todo el texto
                const rectanguloAncho = anchoMaximo + 10; // Añade un margen de 10 píxeles
                var rectanguloAlto = lineas.length * 12 + 4; // Añade un margen de 10 píxeles
                if(rectanguloAlto < 40){
                    rectanguloAlto=40;
                }
                stepsHeight.push([step.id,rectanguloAlto]);

                //Borramos espacio (colocamos fondo blanco o verde):
                if(step.hasOwnProperty("fechafin")){
                    ctx.fillStyle = '#cceedb';
                }else{
                  ctx.fillStyle = '#fff';
                }
                
                if((step.tipo==="step")||(!step.hasOwnProperty('tipo'))){
                  ctx.fillRect(step.x - 100, step.y - rectanguloAlto/2, 200, rectanguloAlto);
                }
                if(step.tipo==="milestone"){
                  ctx.fillRect(step.x - 100, step.y - rectanguloAlto/2, 195, rectanguloAlto);
                  ctx.beginPath()
                  ctx.moveTo(step.x +95, step.y - rectanguloAlto/2);
                  ctx.lineTo(step.x + 105, step.y);
                  ctx.lineTo(step.x + 95, step.y+ rectanguloAlto/2);
                  ctx.lineTo(step.x + 95, step.y+ rectanguloAlto/2);
                  ctx.fill();
                  ctx.stroke()
                  ctx.closePath()
                }



                // Set outline color based on selection
                if ((stepSelected==true)&&(selectedStep.includes(step.id))) {
                    ctx.strokeStyle = '#ff0000'; // Red outline for selected step
                } else {
                    ctx.strokeStyle = '#000000'; // Black outline for unselected steps
                }

                if((step.tipo==="step")||(!step.hasOwnProperty('tipo'))){
                  console.log(step); // Verifica el contenido completo
                  console.log('is_a_multiple_task:', step.is_a_multiple_task);
                  if((step.hasOwnProperty('is_a_multiple_task'))&&(step.is_a_multiple_task==="true")){

                      // Calcular progreso
                      const dataInstancias = step.infoElementsDataPorInstancia || {};
                      console.log('Barra - dataInstancias: ', dataInstancias);
                      const nombres = Object.keys(dataInstancias);
                      console.log('Barra - nombres: ', dataInstancias);
                      let total = nombres.length;
                      let finalizados = 0;

                      nombres.forEach(nombre => {
                          const estado = dataInstancias[nombre]?.finalState?.value;
                          if (estado === "completed" || estado === "cancelled") {
                              finalizados++;
                          }
                      });

                      const progreso = total > 0 ? finalizados / total : 0;
                      const porcentaje = Math.round(progreso * 100);

                      console.log('Barra - progreso: ', progreso);
                       console.log('Barra - porcentaje: ', progreso);

                      // Coordenadas de la barra
                      const barraX = step.x + 100;
                      const barraYInicio = step.y + rectanguloAlto / 2 - 2;
                      const barraYFin = step.y - rectanguloAlto / 2 + 2;
                      const alturaTotal = barraYInicio - barraYFin;
                      const alturaProgreso = alturaTotal * progreso;

                      // Fondo gris de la barra
                      ctx.beginPath();
                      ctx.fillStyle = "#e0e0e0";
                      ctx.rect(barraX, barraYFin, 8, alturaTotal);
                      ctx.fill();
                      ctx.closePath();

                      // Barra verde de progreso
                      ctx.beginPath();
                      ctx.fillStyle = color_OK_fondo; // Verde
                      ctx.rect(barraX, barraYInicio - alturaProgreso, 8, alturaProgreso);
                      ctx.fill();
                      ctx.closePath();

                      // Contorno de la barra
                      ctx.beginPath();
                      //ctx.strokeStyle = "#666";
                      ctx.rect(barraX, barraYFin, 8, alturaTotal);
                      ctx.stroke();
                      ctx.closePath();

                      // Mostrar porcentaje al lado derecho de la barra
                      if (total > 0) {
                        ctx.save(); // Guarda estado actual
                        ctx.font = "12px Arial";
                        ctx.fillStyle = color_OK_fondo;
                        ctx.textAlign = "left";
                        ctx.textBaseline = "middle";
                        ctx.fillText(`${porcentaje}%`, barraX + 10, step.y);
                        ctx.restore(); // Restaura estado previo (alineaciones, estilos, etc.)
                      }

                  }
                 ctx.strokeRect(step.x - 100, step.y - rectanguloAlto/2, 200, rectanguloAlto);

                }
                if(step.tipo==="milestone"){
                  ctx.beginPath();
                  ctx.moveTo(step.x - 100, step.y - rectanguloAlto/2);
                  ctx.lineTo(step.x + 95, step.y - rectanguloAlto/2);
                  ctx.lineTo(step.x + 105, step.y);
                  ctx.lineTo(step.x + 95, step.y+ rectanguloAlto/2);
                  ctx.lineTo(step.x - 100, step.y+ rectanguloAlto/2);
                  ctx.lineTo(step.x - 100, step.y - rectanguloAlto/2);
                  ctx.moveTo(step.x - 105, step.y+ rectanguloAlto/2+5);
                  ctx.lineTo(step.x - 105, step.y - rectanguloAlto/2-5);
                  ctx.stroke();
                  ctx.beginPath();
                  ctx.arc(step.x - 105, step.y - rectanguloAlto/2-10, 5, 0, 2 * Math.PI);
                  ctx.fill();
                  //ctx.closePath()
                  //ctx.strokeStyle = 'black';
                  ctx.lineWidth = 1;
                  ctx.stroke();
                  
                }

                
                ctx.beginPath();
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'black';
                ctx.stroke();
                // Configurar el estilo de texto
                ctx.font = '12px Arial';
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                // Dibujar el texto línea por línea
                lineas.forEach((linea, indice) => {
                ctx.fillText(linea, step.x, step.y-15-(lineas.length-1) * 6-(indice*8) + (indice + 1) * 20);
                });

                
                // Dibujamos las fechas inicial y final:
                const stepConFechas = stepsConFechas[stepId];
                    // Verificar si stepConFechas está definido (podría ser null si no tiene paths de entrada)
                if (stepConFechas) {
                  const startDate = stepConFechas.start_date ? formatearFecha(stepConFechas.start_date) : 'ND';
                  const endDate = stepConFechas.end_date ? formatearFecha(stepConFechas.end_date): 'ND';
                  const duracion = stepConFechas.duracion === 0 ? '0' : (stepConFechas.duracion ? stepConFechas.duracion.toString() : 'ND');
                  //const duracion = stepConFechas.duracion ? stepConFechas.duracion.toString() : '0';
                  const unidad = stepConFechas.unidad ? stepConFechas.unidad.toString() : 'ND';
                  if((!modoProcesosGenerales)&&(mostrar_fecha_inicio)){
                  ctx.fillText(startDate, step.x-70, step.y-22-(rectanguloAlto-40)/2);
                  }
                  var unidadPresentada="";
                  switch(unidad){
                    case "l":
                    if (duracion===1){
                      unidadPresentada="día lab.";
                    }else{
                      unidadPresentada="días lab.";
                    }
                    break;
                    case "h":
                    if (duracion===1){
                      unidadPresentada="día háb.";
                    }else{
                      unidadPresentada="días hab.";
                    }
                    break;
                    case "n":
                    if (duracion===1){
                      unidadPresentada="día nat.";
                    }else{
                      unidadPresentada="días nat.";
                    }

                    break;
                    case "m":
                    if (duracion===1){
                      unidadPresentada="mes";
                    }else{
                      unidadPresentada="meses";
                    }
                    break;
                    case "a":
                    if (duracion===1){
                      unidadPresentada="año";
                    }else{
                      unidadPresentada="años";
                    }
                    break;
                  }
                


                  if(step.tipo !=="milestone"){
                    if(mostrar_duracion){
                      ctx.fillText(duracion+' '+unidadPresentada, step.x+70, step.y-22-(rectanguloAlto-40)/2);
                    }
                    var rol = step.rol;
                    if(!modoProcesosGenerales){
                      if(mostrar_fecha_fin){
                        ctx.fillText(endDate, step.x-70, step.y+32 +(rectanguloAlto-40)/2);
                      }

                    // Comprobar si hay una asignación de cargo en flowchartData.asignacionRoles para este rol
                    if (flowchartData.asignacionRoles && flowchartData.asignacionRoles[rol]) {
                       rol = flowchartData.asignacionRoles[rol]; // Usar el cargo asignado en lugar del rol
                    }
                  }
                    var xpos=95-6*rol.length;
                    if(xpos<3){
                       xpos=3;
                    }
                    ctx.textAlign = 'left';
                    if(mostrar_rol){
                    ctx.fillText(rol, step.x + xpos, step.y + 32 +(rectanguloAlto-40)/2);
                    }
                    
                  }
                  //ctx.fillText(step.id, step.x, step.y-22);
                  if(stepConFechas.hasOwnProperty("NOCumpleLig")){
                    ctx.fillStyle = "red";
                    ctx.fillText("NO CUMPLE", step.x+102, step.y-10);
                    ctx.fillText("LIGADURA", step.x+102, step.y+4);
                    ctx.fillText("TEMPORAL", step.x+102, step.y+18);

                    //ctx.fillStyle = '#000';
                  }
                  ctx.textAlign = 'center';
                }
              
            });
          }



          if (flowchartData.hasOwnProperty('paths')) {
            flowchartData.paths.forEach(function (path) {
                var startStep = getStepById(path.startStep);
                var endStep = getStepById(path.endStep);
                var startHeight = (getStepHeightById(path.startStep)/2);
                var endHeight = (getStepHeightById(path.endStep)/2);
                var condicion = path.condicion;
                var duracion = path.duracion;
                var maxmin = path.maxmin;
                var tipoduracion = path.tipoduracion;
                var unidadduracion = path.unidadduracion;

                                // Set outline color based on selection
                if ((pathSelected==true)&&(selectedPath === path.id)) {
                    ctx.strokeStyle = '#ff0000'; // Red outline for selected step
                    ctx.fillStyle = '#ff0000';
                } else {
                    ctx.strokeStyle = '#000000'; // Black outline for unselected steps
                    ctx.fillStyle = '#000000';
                }

                if((endStep.hasOwnProperty('multiple_task_following_previous'))&&(endStep.multiple_task_following_previous.startsWith("step"))&&(startStep.id===endStep.multiple_task_following_previous)){
                  ctx.lineWidth = 3;
                }else{
                  ctx.lineWidth = 1;
                }

                ctx.beginPath();

                if((!(path.hasOwnProperty('type')))||((path.hasOwnProperty('type'))&& (path.type === 'path'))){

                var radio=Math.abs((endStep.x-startStep.x)/2); //radio de las esquinas del path
                if(radio>10){radio=10}; // radio máximo
                var radio2=radio;
                if(((endStep.y-endHeight-16)<(startStep.y+startHeight+16))&&(((startStep.y+startHeight+16)-(endStep.y-endHeight-16)))<(2*radio2)){
                  radio2=((startStep.y+startHeight+16)-(endStep.y-endHeight-16))/2;
                }

                ctx.moveTo(startStep.x, startStep.y+startHeight);

                 //Primer segmento corto hacia abajo
                if(endStep.y<(startStep.y+32+((startHeight+endHeight)/2))){ //el segundo step está por encima de el primero (no habitual)
                    if(endStep.x>(startStep.x+220)){ //Segundo a la derecha
                      ctx.lineTo(startStep.x, startStep.y+startHeight+16-radio);
                      ctx.arc (startStep.x+radio, startStep.y+startHeight+16-radio, radio, Math.PI, 0.5*Math.PI, true);
                        ctx.lineTo(endStep.x-110-radio, startStep.y+startHeight+16);
                        ctx.arc (endStep.x-110-radio2, startStep.y+startHeight+16-radio2, radio2, 0.5*Math.PI, 0, true);
                        ctx.lineTo(endStep.x-110, endStep.y-endHeight-16+radio2);
                        ctx.arc (endStep.x-110+radio2, endStep.y-endHeight-16+radio2, radio2, Math.PI, 1.5*Math.PI, false);
                        ctx.lineTo(endStep.x-radio, endStep.y-endHeight-16);
                        ctx.arc (endStep.x-radio, endStep.y-endHeight-16+radio, radio, 1.5*Math.PI, 0, false );
                    }else{
                      if(endStep.x>(startStep.x-220)){ //Uno Encima del otro
                        radio1=10;
                        radio2=10;
                        if (endStep.x>(startStep.x)){ //encima pero a la redercha
                            ctx.lineTo(startStep.x, startStep.y+startHeight+16-radio1);
                            ctx.arc (startStep.x+radio1, startStep.y+endHeight+16-radio1, radio1, Math.PI, 0.5*Math.PI, true );
                            ctx.lineTo(endStep.x+110-radio2, startStep.y+startHeight+16);
                            ctx.arc (endStep.x+110-radio2, startStep.y+startHeight+16-radio2, radio2, 0.5*Math.PI, 0, true);
                            ctx.lineTo(endStep.x+110, endStep.y-endHeight-16+radio2);
                            ctx.arc (endStep.x+110-radio2, endStep.y-endHeight-16+radio2, radio2, 0, 1.5*Math.PI, true);
                            ctx.lineTo(endStep.x+radio, endStep.y-endHeight-16);
                            ctx.arc (endStep.x+radio, endStep.y-endHeight-16+radio, radio, 1.5*Math.PI, Math.PI, true );
                        }else{ //encima pero a la izquierda
                          ctx.lineTo(startStep.x, startStep.y+startHeight+16-radio1);
                          ctx.arc (startStep.x-radio1, startStep.y+startHeight+16-radio1, radio1, 0, 0.5*Math.PI, false);
                            ctx.lineTo(endStep.x-110+radio2, startStep.y+startHeight+16);
                            ctx.arc (endStep.x-110+radio2, startStep.y+startHeight+16-radio2, radio2, 0.5*Math.PI, Math.PI, false);
                            ctx.lineTo(endStep.x-110, endStep.y-endHeight-16+radio2);
                            ctx.arc (endStep.x-110+radio2, endStep.y-endHeight-16+radio2, radio2, Math.PI, 1.5*Math.PI, false);
                            ctx.lineTo(endStep.x-radio, endStep.y-endHeight-16);
                            ctx.arc (endStep.x-radio, endStep.y-endHeight-16+radio, radio, 1.5*Math.PI, 0, false );
                        }
                      }else{ //Segundo a la izquierda
                        ctx.lineTo(startStep.x, startStep.y+startHeight+16-radio);
                        ctx.arc (startStep.x-radio, startStep.y+startHeight+16-radio, radio, 0, 0.5*Math.PI, false);
                        ctx.lineTo(endStep.x+110+radio2, startStep.y+startHeight+16);
                        ctx.arc (endStep.x+110+radio2, startStep.y+startHeight+16-radio2, radio2, 0.5*Math.PI, Math.PI, false);
                        ctx.lineTo(endStep.x+110, endStep.y-endHeight-16+radio2);
                        ctx.arc (endStep.x+110-radio2, endStep.y-endHeight-16+radio2, radio2, 0, 1.5*Math.PI, true);
                        ctx.lineTo(endStep.x+radio, endStep.y-endHeight-16);
                        ctx.arc (endStep.x+radio, endStep.y-endHeight-16+radio, radio, 1.5*Math.PI, Math.PI, true );
                      }
                        //ctx.arc (startStep.x-radio, startStep.y+startHeight+16, radio, 0, 0.5*Math.PI);
                        //ctx.arc (startStep.x-radio, startStep.y+startHeight+16-radio, radio, 0, 0.5*Math.PI, false);

                    }
                }else{ //el segundo step está por debajo del primero (lo habitual)
                  if((endStep.y<(startStep.y+32+((startHeight+endHeight))))&&(endStep.y>=(startStep.y+32+((startHeight+endHeight)/2)))){
                    radio=1;
                  }else{
                    
                  }
                  ctx.lineTo(startStep.x, endStep.y-endHeight-16-radio);
                  if(endStep.x>startStep.x){
                    ctx.arc (startStep.x+radio, endStep.y-endHeight-16-radio, radio, Math.PI, 0.5*Math.PI, true );
                    ctx.lineTo(endStep.x-radio, endStep.y-endHeight-16);
                    ctx.arc (endStep.x-radio, endStep.y-endHeight-16+radio, radio, 1.5*Math.PI, 0, false );
                  }else{
                    ctx.arc (startStep.x-radio, endStep.y-endHeight-16-radio, radio, 0, 0.5*Math.PI, false);
                    ctx.lineTo(endStep.x+radio, endStep.y-endHeight-16);
                    ctx.arc (endStep.x+radio, endStep.y-endHeight-16+radio, radio, 1.5*Math.PI, Math.PI, true );
                  }
                }
                ctx.lineTo(endStep.x, endStep.y-endHeight);
                //Texto:
                
                if(typeof condicion == "undefined"){}else{
                  ctx.font = '12px Arial';
                  //ctx.fillStyle = '#000';
                  ctx.textAlign = 'center';
                  var xpos= startStep.x+6+(ctx.measureText(condicion).width/2); //texto junto a línea 
                 // var xpos= startStep.x-(startStep.x-endStep.x)/2+15; // texto en el centro
                  var ypos=endStep.y-endHeight-20;
                  

                  if(endStep.y<(startStep.y+32+startHeight+endHeight)){
                  ypos=startStep.y+startHeight+12;
                  }else{
                  ypos=endStep.y-endHeight-20;
                  }

                  var ytext =ypos-2;
                  var xtext = xpos;
                  //var xtext = xpos-(ctx.measureText(condicion).width/6);//texto al centro
              //    if((endStep.x>=startStep.x)&&(endStep.x<(startStep.x+12+(ctx.measureText(condicion).width)))){xtext=startStep.x+6+(ctx.measureText(condicion).width/2)}; //texto al centro
               //   if((endStep.x<startStep.x)&&(endStep.x>(startStep.x-12-(ctx.measureText(condicion).width)))){xtext=startStep.x-6-(ctx.measureText(condicion).width/2)};  // texto al centro
                if(endStep.x<startStep.x){xtext=startStep.x-6-(ctx.measureText(condicion).width/2)};


                 //   if((endStep.y<(startStep.y+32+startHeight+endHeight))&&(xpos>endStep.x-102)){ //texto al centro
                  if(endStep.y<(startStep.y+32+startHeight+endHeight)){
                        xpos=endStep.x-102;
                       // if(endStep.x < (250+startStep.x)){
                          ytext=ypos+20;
                      //  }
                        
                    }

                  ctx.fillText(condicion, xtext, ytext);
                  //ctx.fillText(path.id, xtext, ytext+14);
                }
                  ctx.stroke();
                  //flecha:
                ctx.beginPath();
                ctx.lineTo(endStep.x-3, endStep.y-endHeight-5);
                ctx.lineTo(endStep.x+3, endStep.y-endHeight-5);
                ctx.lineTo(endStep.x, endStep.y-endHeight);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#000000';

                //ctx.fillText(path.id, endStep.x+15, endStep.y-endHeight-20);

                // Dibuja la aspa si path cerrado:
                if ((path.type === 'path')&&(path.hasOwnProperty('closed'))) {
                  const crossSize = 10; // Tamaño de la aspa

                  ctx.strokeStyle = 'black';
                  ctx.lineWidth = 2;
                  // Dibuja la primera línea de la aspa
                  ctx.beginPath();
                  ctx.moveTo(xpos - crossSize * 2, ypos);
                  ctx.lineTo(xpos - crossSize, ypos + crossSize);
                  ctx.stroke();
                  // Dibuja la segunda línea de la aspa
                  ctx.beginPath();
                  ctx.moveTo(xpos - crossSize, ypos);
                  ctx.lineTo(xpos - crossSize * 2, ypos + crossSize);
                  ctx.stroke();
                  }
                }
                //Si es ligadura temporal
              if((path.hasOwnProperty('type'))&& (path.type === 'ligtime')){
                ctx.setLineDash([5, 8]);
                if((tipoduracion==="IF")||(tipoduracion==="II")){
                  ctx.moveTo(startStep.x+100, startStep.y-startHeight);
                  ctx.lineTo(Math.max(startStep.x, endStep.x)+125, startStep.y-startHeight);
                }else{
                  ctx.moveTo(startStep.x+100, startStep.y+startHeight);
                  ctx.lineTo(Math.max(startStep.x, endStep.x)+125, startStep.y+startHeight);
                }

                if((tipoduracion==="II")||(tipoduracion==="FI")){
                  ctx.lineTo(Math.max(startStep.x, endStep.x)+125, endStep.y-startHeight);
                  ctx.lineTo(endStep.x+100, endStep.y-startHeight);
                }else{
                  ctx.lineTo(Math.max(startStep.x, endStep.x)+125, endStep.y+endHeight);
                  ctx.lineTo(endStep.x+100, endStep.y+endHeight);
                }
                ctx.stroke();
                ctx.setLineDash([]);
                if(typeof duracion == "undefined"){}else{
                  ctx.font = '12px Arial';
                  ctx.textAlign = 'left';
                  var ligtimetext="";
                  if(maxmin==="MX") ligtimetext="Máx: ";
                  if(maxmin==="MN") ligtimetext="Min: ";
                  ligtimetext=ligtimetext+duracion;
                  if(unidadduracion==="n") ligtimetext=ligtimetext+" días naturales";
                  if(unidadduracion==="h") ligtimetext=ligtimetext+" días hábiles";
                  if(unidadduracion==="l") ligtimetext=ligtimetext+" días laborables";
                  if(unidadduracion==="m") ligtimetext=ligtimetext+" meses";
                  if(unidadduracion==="a") ligtimetext=ligtimetext+" años";
                  
                  ctx.fillText(ligtimetext, Math.max(startStep.x, endStep.x)+130, startStep.y+(endStep.y-startStep.y)/2);
                }
              }


            });
          }

          // Dibujamosel rectángulo de selección si `isSelecting` es true
          if ((!stepCanMove)&&isSelecting) {
              //var ctx = canvas.getContext('2d');
              ctx.strokeStyle = 'black'; // Color negro
              ctx.lineWidth = 1; // Línea fina
              ctx.setLineDash([5, 3]); // Línea de puntos (5 píxeles pintados, 3 píxeles de espacio)

              var startX = Math.min(selectionStart.x, selectionEnd.x);
              var endX = Math.max(selectionStart.x, selectionEnd.x);
              var startY = Math.min(selectionStart.y, selectionEnd.y);
              var endY = Math.max(selectionStart.y, selectionEnd.y);

              ctx.strokeRect(startX, startY, endX - startX, endY - startY);
          }
            //Set flowchart title:
			//ctx.font = "14px Arial";
			//ctx.fillText(flowchartData.title, 60, 30);
        }
        function getStepById(id) {
            return flowchartData.steps.find(function (step) {
                return step.id === id;
            });
        }
        function getStepHeightById(id) {
            var result;
            for( var i = 0, len = stepsHeight.length; i < len; i++ ) {
                if( stepsHeight[i][0] === id ) {
                    result = stepsHeight[i][1];
                   break;
                 }
            }
            return result;
        }

        let ctrlPressed = false;

// Detectar cuándo se presiona la tecla CTRL
document.addEventListener('keydown', function (event) {
    if (event.key === 'Control') {
        ctrlPressed = true;
    }
});

// Detectar cuándo se libera la tecla CTRL
document.addEventListener('keyup', function (event) {
    if (event.key === 'Control') {
        ctrlPressed = false;
    }
});


        // Handle click events on the canvas
        canvas.addEventListener('mousedown', function (event) {
    stepCanMove = false;

    var rect = canvas.getBoundingClientRect();
    var clickX = event.clientX - rect.left;
    var clickY = event.clientY - rect.top;

    // Iniciar selección múltiple (por si el usuario arrastra)
    selectionStart = { x: clickX, y: clickY };
    selectionEnd = { x: clickX, y: clickY };
    isSelecting = true;

    if (expiredTime) {
        expiredTime = false;

        var stepselection = stepClicked(clickX, clickY);

        // Verificar si se hizo clic en una tarea
        if (stepselection === null) {
            // Si se clicó fuera de cualquier tarea, deseleccionar todo
            stepSelected = false;
            selectedStep = [];
            stepCanMove = false;
        } else {
          
            // Si la tarea clicada ya está en la selección, no cambiar selectedStep
            if (!selectedStep.includes(stepselection)) {
              if (ctrlPressed) {
                  // Si CTRL está presionado, agregar o quitar tarea de la selección
                  if (selectedStep.includes(stepselection)) {
                      // Si la tarea ya está seleccionada, quitarla de la selección
                      selectedStep = selectedStep.filter(step => step !== stepselection);
                  } else {
                      // Si no está seleccionada, agregarla
                      selectedStep.push(stepselection);
                  }
              } else {
                  // Si CTRL no está presionado, seleccionar solo la tarea clicada
                  selectedStep = [stepselection];
              }
            }

            stepSelected = true;
            pathSelected = false;

                // Determinar si se ha hecho clic en una tarea seleccionada
            var stepselection = stepClicked(clickX, clickY);

            if (selectedStep.includes(stepselection)) {
                // Si el clic está sobre una tarea seleccionada, habilitar movimiento
                stepCanMove = true;
                dragStart = { x: event.clientX - rect.left, y: event.clientY - rect.top };

                // Guardar posiciones iniciales de las tareas seleccionadas
                initialPositions = flowchartData.steps
                    .filter(step => selectedStep.includes(step.id))
                    .map(step => ({ id: step.id, x: step.x, y: step.y }));
            } else {
                // Si no estás moviendo tareas, activa la selección múltiple
                stepCanMove = false;
                isSelecting = true;
                selectionStart = { x: clickX, y: clickY };
                selectionEnd = { x: clickX, y: clickY };
            }


        }

        var pathselection=pathClicked(clickX, clickY);
                if ( pathselection=== null) {
                  pathSelected=false;
                  selectedPath = null;

                  var boton = document.getElementById("doneButton");
                  // Cambiar el ícono
                  boton.innerHTML = '<img src="media/okStep.png" title="Cerrar"/>';

                }else{
                    pathSelected=true;
                    stepSelected=false;
                    selectedPath = pathselection; // Set the selected step
                    expiredTime = true;

                    var boton = document.getElementById("doneButton");
                    // Cambiar el ícono
                    boton.innerHTML = '<img src="media/closePath.png" title="Cerrar"/>';


                   drawFlowchart(); 
                }

        setTimeout(() => {
            expiredTime = true;
        }, 300);

        drawFlowchart(); // Redibujar el diagrama con los pasos seleccionados
    }
});


        canvas.addEventListener('dblclick', function (event) {

stepCanMove=false;
var rect = canvas.getBoundingClientRect();
var clickX = event.clientX - rect.left;
var clickY = event.clientY - rect.top;

// Check if the click intersects with any step
flowchartData.steps.forEach(function (step) {
    if (
        clickX >= step.x - 100 &&
        clickX <= step.x + 100 &&
        clickY >= step.y - 20 &&
        clickY <= step.y + 20
    ) {
      selectedStep = [step.id];
      //showStepOptionsDialog();
      showNameAndInstructions();

      // Do something with the selectedOption, if needed
      //break;
     }
});
stepSelected=false;
drawFlowchart();
});


        canvas.addEventListener('contextmenu', function (event) { //Botón derecho /right click
    event.preventDefault(); // Evitar que aparezca el menú contextual del navegador

    stepCanMove = false;
    var rect = canvas.getBoundingClientRect();
    var clickX = event.clientX - rect.left;
    var clickY = event.clientY - rect.top;

    // Check if the click intersects with any step
    flowchartData.steps.forEach(function (step) {
        if (
            clickX >= step.x - 100 &&
            clickX <= step.x + 100 &&
            clickY >= step.y - 20 &&
            clickY <= step.y + 20
        ) {
            selectedStep = [step.id];

            showStepDialog(false, step.tipo, step.id, step.label, step.rol, step.Duracion, step.instrucciones, step.unidadduracion, step.fechafin, step.notas, step.is_a_multiple_task, step.multiple_task_following_previous); // isNew se establece en false para actualizar el step seleccionado
          
        }
    });


    var pathselection=pathClicked(clickX, clickY);
    if(pathselection === null){

    }else{
      selectedPath = pathselection;

                  // Actualizar el step seleccionado en flowchartData.steps
      var selectedPathData = flowchartData.paths.find(function (path) {
                return path.id === pathselection;
            });
      showPathDialog(false, selectedPathData.startStep, selectedPathData.endStep, selectedPathData.id, selectedPathData.type, selectedPathData.condicion, selectedPathData.maxmin, selectedPathData.duracion, selectedPathData.unidadduracion, selectedPathData.tipoduracion);

    }


    stepSelected = false;
    drawFlowchart();
});


          function showStepOptionsDialog() {
                //Poner aquí el menú de selección de elementos
                alert("Seleccionar entre Texto o Página html");
           }

function stepClicked(clickX, clickY){
  var respuesta=null;
  if (flowchartData.hasOwnProperty('steps')) {
  flowchartData.steps.forEach(function (step) {
                if (
                    clickX >= step.x - 100 &&
                    clickX <= step.x + 100 &&
                    clickY >= step.y - 20 &&
                    clickY <= step.y + 20
                ) {
                    respuesta = step.id; // Set the selected step
                }

              });
  }
  return respuesta;
}

function pathClicked(clickX, clickY){
  var respuesta=null;

  if (flowchartData.hasOwnProperty('paths')) {
            flowchartData.paths.forEach(function (path) {
              var startStep = getStepById(path.startStep);
              var endStep = getStepById(path.endStep);
             var startHeight = (getStepHeightById(path.startStep)/2);
             var endHeight = (getStepHeightById(path.endStep)/2);


                if ( //Primer tramo - descendente
                  ((!(path.hasOwnProperty('type')))||((path.hasOwnProperty('type'))&& (path.type === 'path')))&&(
                    (clickX >= startStep.x - 10 && 
                    clickX <= startStep.x + 10 &&
                    clickY >= startStep.y+startHeight &&
                    clickY <= endStep.y- endHeight-16) ||
                      (clickX >= Math.min(startStep.x, endStep.x) && //segundo tramo - horizontal
                    clickX <= Math.max(startStep.x, endStep.x-110)  &&
                    clickY >= Math.max(endStep.y- endHeight-16,startStep.y+ endHeight+20)-10 &&
                    clickY <= Math.max(endStep.y- endHeight-16,startStep.y+ endHeight+20)+10) ||
                    (clickX >= endStep.x+Math.sign(startStep.x-endStep.x)*100 -10  && //tercer tramo - vertical (si está más alto el segundo step)
                    clickX <= endStep.x+Math.sign(startStep.x-endStep.x)*100 +10 &&
                    clickY >= endStep.y-startHeight-16 &&
                    clickY <= startStep.y+ endHeight+20) ||
                    (clickX >= Math.min(endStep.x,endStep.x+Math.sign(startStep.x-endStep.x)*100) && //cuarto tramo - horizontal
                    clickX <= Math.max(endStep.x+Math.sign(startStep.x-endStep.x)*100,endStep.x)  &&
                    clickY >= endStep.y- endHeight-16-10 &&
                    clickY <= endStep.y- endHeight-16+10) ||
                    (clickX >= endStep.x - 10 && // último tramo - descendente
                    clickX <= endStep.x + 10 &&
                    clickY >= endStep.y- endHeight -16 + 1 &&
                    clickY <= endStep.y- endHeight) 
                  )||(((path.hasOwnProperty('type'))&&(path.type === 'ligtime'))&&(
                    (clickX >= startStep.x+100 && 
                    clickX <= Math.max(startStep.x, endStep.x)+125 &&
                    clickY >= startStep.y+startHeight-10 &&
                    clickY <= startStep.y+startHeight+10)||
                    (clickX >= Math.max(startStep.x, endStep.x)+125 - 10 && 
                    clickX <= Math.max(startStep.x, endStep.x)+125 + 10 &&
                    clickY >= Math.min(startStep.y+startHeight, endStep.y+endHeight) &&
                    clickY <= Math.max(startStep.y+startHeight, endStep.y+endHeight)) ||
                    (clickX >= endStep.x+100 && 
                    clickX <= Math.max(startStep.x, endStep.x)+125 &&
                    clickY >= endStep.y+endHeight-10 &&
                    clickY <= endStep.y+endHeight+10) 
                  ))
                ) {
                  respuesta=path.id;
                }
            

            }); // 0 milisegundos de retraso antes de permitir mover de nuevo
          }
          return respuesta;
}



function openRestrictedTableEditor(element, nombre, tempInfoElementsDataPorInstancia, tempTablasGenerales, labelsPorNombreYInstancia) {

    let tablaGuardada;
    const tablaOriginalBase = element.tabla || { rows: [] };

    let originalBaseData = Array.isArray(tablaOriginalBase?.rows)
        ? tablaOriginalBase.rows.map(row => {
            if (typeof row === "string") return row.split("|||");
            if (Array.isArray(row) && typeof row[0] === "string" && row.length === 1) return row[0].split("|||");
            return row;
        })
        : [];

        if (nombre) {
            // "Uno para cada ítem"
            tablaGuardada = tempInfoElementsDataPorInstancia?.[nombre]?.[element.name]?.value;

            if (!tablaGuardada) {
                // No había tabla aún editada → usar la de definición
                tablaGuardada = element.tabla || { rows: [] };
            }
        } else {
            // "Uno para todos los ítems"
            tablaGuardada = tempTablasGenerales?.[element.name];

            if (!tablaGuardada) {
                // No había tabla aún editada → usar la de definición
                tablaGuardada = element.tabla || { rows: [] };
            }
        }


        const baseRows = Array.isArray(element.tabla?.rows) ? element.tabla.rows : [];
        const editedRows = Array.isArray(tablaGuardada?.rows) ? tablaGuardada.rows : [];

        // Convertir cada fila a arrays usando separador |||
        const splitRow = r =>
        Array.isArray(r) && r.length === 1 && typeof r[0] === "string"
            ? r[0].split("|||")
            : typeof r === "string"
            ? r.split("|||")
            : Array.isArray(r)
            ? r
            : [];

        const baseData = baseRows.map(splitRow);
        let editedData = editedRows.map(splitRow);



        // Mezclar: usar valores editados si existen, si no dejar vacío (pero mantener la estructura)
        const totalRows = Math.max(baseData.length, editedData.length);
        const totalCols = Math.max(
            ...[...baseData, ...editedData].map(row => row.length)
        );

        let tableData = [];

        for (let r = 0; r < totalRows; r++) {
            const row = [];
            for (let c = 0; c < totalCols; c++) {
                const valorEditado = editedData?.[r]?.[c];
                const valorBase = baseData?.[r]?.[c];
                const valor = (valorEditado !== undefined && valorEditado !== null)
                    ? valorEditado.trim()
                    : (valorBase !== undefined && valorBase !== null)
                        ? valorBase.trim()
                        : "";
                row.push(valor);
            }
            tableData.push(row);
        }



        // Esto se usa para bloquear las celdas del formato original
        originalBaseData = baseData;


    const editorDiv = document.createElement("div");
    editorDiv.style.position = "fixed";
    editorDiv.style.left = "50%";
    editorDiv.style.top = "50%";
    editorDiv.style.transform = "translate(-50%, -50%)";
    editorDiv.style.padding = "20px";
    editorDiv.style.backgroundColor = "#fff";
    editorDiv.style.border = "1px solid #ccc";
    editorDiv.style.borderRadius = "8px";
    editorDiv.style.zIndex = "1000";
    editorDiv.style.fontFamily = "Arial";

    const title = document.createElement("h3");
    title.textContent = "Editor de tabla";
    title.style.marginBottom = "10px";
    editorDiv.appendChild(title);

    const table = document.createElement("table");
    table.style.borderCollapse = "collapse";
    table.style.marginBottom = "10px";
    table.style.border = "1px solid #ccc"; // borde general

    const renderTable = () => {
        table.innerHTML = "";

        // Botones eliminar columna
        const headerRow = document.createElement("tr");
        const cornerCell = document.createElement("th");
        cornerCell.style.border = "none";
        headerRow.appendChild(cornerCell);

        for (let c = 0; c < (tableData[0]?.length || 0); c++) {
            const th = document.createElement("th");
            th.style.border = "none";
            th.style.textAlign = "center";
            const btn = document.createElement("button");
            btn.textContent = "🗑️";
            btn.style.border = "0";
            btn.style.backgroundColor = "transparent"; //  sin fondo gris
            btn.style.padding = "0"; //  elimina espacio alrededor
            btn.style.cursor = "pointer"; // (opcional, da sensación de interactividad)

            btn.onclick = () => {
                let canDelete = true;
                for (let r = 0; r < originalBaseData.length; r++) {
                    if (originalBaseData[r]?.[c]?.trim()) {
                        canDelete = false;
                        break;
                    }
                }
                if (!canDelete) {
                    alert("No se puede eliminar una columna con datos originales.");
                    return;
                }
                tableData.forEach(row => row.splice(c, 1));
                renderTable();
            };
            th.appendChild(btn);
            headerRow.appendChild(th);
        }
        table.appendChild(headerRow);

        tableData.forEach((row, rowIndex) => {
            const tr = document.createElement("tr");

            const deleteBtnCell = document.createElement("td");
            deleteBtnCell.style.textAlign = "center";
            const btn = document.createElement("button");
            btn.textContent = "🗑️";
            btn.style.border = "0";
            btn.style.backgroundColor = "transparent"; //  sin fondo gris
            btn.style.padding = "0"; //  elimina espacio alrededor
            btn.style.cursor = "pointer"; // (opcional, da sensación de interactividad)
            btn.onclick = () => {
                let canDelete = true;
                for (let c = 0; c < originalBaseData[0]?.length || 0; c++) {
                    if (originalBaseData[rowIndex]?.[c]?.trim()) {
                        canDelete = false;
                        break;
                    }
                }
                if (!canDelete) {
                    alert("No se puede eliminar una fila con datos originales.");
                    return;
                }
                tableData.splice(rowIndex, 1);
                renderTable();
            };
            deleteBtnCell.appendChild(btn);
            tr.appendChild(deleteBtnCell);

            row.forEach((cell, colIndex) => {
                const td = document.createElement("td");
                td.style.border = "1px solid #ccc"; //  línea gris
                const input = document.createElement("input");
                input.type = "text";
                input.value = cell;
                input.style.border = "none";
                input.style.margin = "0";
                input.style.padding = "0";
                input.style.width = "100px";
                input.style.fontFamily = "Arial";

                const isFromOriginal = originalBaseData?.[rowIndex]?.[colIndex]?.trim();
                input.disabled = !!isFromOriginal;

                if (input.disabled) {
                    input.style.backgroundColor = "#f0f0f0"; // 👈 fondo gris claro más oscuro
                }
                input.oninput = () => {
                    tableData[rowIndex][colIndex] = input.value;
                };

                td.appendChild(input);
                tr.appendChild(td);
            });

            table.appendChild(tr);
        });
    };

    const addRowBtn = document.createElement("button");
    addRowBtn.textContent = "Añadir fila";
    addRowBtn.onclick = () => {
        const cols = tableData[0]?.length || 1;
        tableData.push(new Array(cols).fill(""));
        renderTable();
    };

    const addColBtn = document.createElement("button");
    addColBtn.textContent = "Añadir columna";
    addColBtn.onclick = () => {
        tableData.forEach(row => row.push(""));
        renderTable();
    };

    const guardarBtn = document.createElement("button");
    guardarBtn.textContent = "Guardar tabla";
    guardarBtn.style.marginLeft = "20px";
    guardarBtn.onclick = () => {
        const nuevaTabla = {
            rows: tableData.map(row => row.map(cell => cell.trim()).join("|||"))
        };

        // 🔍 Verificar si hay al menos una celda no vacía
        const tieneContenido = tableData.some(row =>
            row.some(cell => cell.trim() !== "")
        );

        if (nombre) {
            if (!tempInfoElementsDataPorInstancia[nombre]) {
                tempInfoElementsDataPorInstancia[nombre] = {};
            }
            tempInfoElementsDataPorInstancia[nombre][element.name] = {
                type: "Tabla",
                value: nuevaTabla
            };

            // 🔄 Eliminar clase de error si hay contenido válido
            const clave = `${element.name}|||${nombre}`;
            const label = labelsPorNombreYInstancia?.[clave];
            if (label && tieneContenido) {
                label.classList.remove("label-error");
                console.log("🟢 Se eliminó error de:", clave);
            } else if (!label) {
                console.warn("⚠️ No se encontró label para limpiar error:", clave);
            }
        } else {
            // "Uno para todos"
            tempTablasGenerales[element.name] = nuevaTabla;

            const clave = element.name;
            const label = labelsPorNombreYInstancia?.[clave];
            if (label && tieneContenido) {
                label.classList.remove("label-error");
                console.log("🟢 Se eliminó error de:", clave);
            } else if (!label) {
                console.warn("⚠️ No se encontró label para limpiar error:", clave);
            }
        }

        document.body.removeChild(editorDiv);
    };




    const cancelarBtn = document.createElement("button");
    cancelarBtn.textContent = "Cancelar";
    cancelarBtn.onclick = () => {
        document.body.removeChild(editorDiv);
    };

    renderTable();
    editorDiv.appendChild(table);
    editorDiv.appendChild(addRowBtn);
    editorDiv.appendChild(addColBtn);
    editorDiv.appendChild(guardarBtn);
    editorDiv.appendChild(cancelarBtn);
    document.body.appendChild(editorDiv);
}


function showCustomDialog({ title, content, onAccept, onCancel }) {
    // Fondo semitransparente para bloquear el resto
    const overlay = document.createElement("div");
    overlay.style.position = "fixed";
    overlay.style.left = "0";
    overlay.style.top = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.backgroundColor = "rgba(0, 0, 0, 0.3)";
    overlay.style.zIndex = "99998";

    // Diálogo flotante centrado
    const dialog = document.createElement("div");
    dialog.className = "custom-dialog";
    dialog.style.position = "fixed";
    dialog.style.left = "50%";
    dialog.style.top = "50%";
    dialog.style.transform = "translate(-50%, -50%)";
    dialog.style.backgroundColor = "#fff";
    dialog.style.border = "1px solid #ccc";
    dialog.style.padding = "20px";
    dialog.style.zIndex = "99999"; // Más alto que todo
    dialog.style.maxWidth = "600px";
    dialog.style.width = "90%";
    dialog.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.3)";
    dialog.style.borderRadius = "8px";

    const titleElem = document.createElement("h3");
    titleElem.textContent = title;
    dialog.appendChild(titleElem);

    dialog.appendChild(content);

    const buttonsDiv = document.createElement("div");
    buttonsDiv.style.marginTop = "15px";
    buttonsDiv.style.textAlign = "right";

    const btnAceptar = document.createElement("button");
    btnAceptar.textContent = "Aceptar";
    btnAceptar.onclick = () => {
        document.body.removeChild(dialog);
        document.body.removeChild(overlay);
        onAccept();
    };

    const btnCancelar = document.createElement("button");
    btnCancelar.textContent = "Cancelar";
    btnCancelar.style.marginLeft = "10px";
    btnCancelar.onclick = () => {
        document.body.removeChild(dialog);
        document.body.removeChild(overlay);
        if (onCancel) onCancel();
    };

    buttonsDiv.appendChild(btnAceptar);
    buttonsDiv.appendChild(btnCancelar);
    dialog.appendChild(buttonsDiv);

    document.body.appendChild(overlay);
    document.body.appendChild(dialog);
}




function crearSeparadorSeccion(texto) {
    const wrapper = document.createElement("div");
    wrapper.style.display = "flex";
    wrapper.style.alignItems = "center";
    wrapper.style.marginTop = "30px";
    wrapper.style.marginBottom = "10px";

    const lineaIzquierda = document.createElement("div");
    lineaIzquierda.style.flex = "1";
    lineaIzquierda.style.height = "6px";
    lineaIzquierda.style.backgroundColor = color_menu_titles;
    lineaIzquierda.style.marginRight = "10px";

    const titulo = document.createElement("span");
    titulo.textContent = texto;
    titulo.style.color = color_menu_titles;
    titulo.style.fontWeight = "bold";
    titulo.style.fontFamily = "Arial";

    const lineaDerecha = document.createElement("div");
    lineaDerecha.style.flex = "1";
    lineaDerecha.style.height = "6px";
    lineaDerecha.style.backgroundColor = color_menu_titles;
    lineaDerecha.style.marginLeft = "10px";

    wrapper.appendChild(lineaIzquierda);
    wrapper.appendChild(titulo);
    wrapper.appendChild(lineaDerecha);

    return wrapper;
}








function showNameAndInstructions() {

    
    // Buscar el elemento en flowchartData con el ID igual a selectedStep

    var selectedStepData = flowchartData.steps.find(function (step) {
        return step.id === selectedStep[0];
    });

    var tempInfoElementsDataPorInstancia = JSON.parse(JSON.stringify(selectedStepData.infoElementsDataPorInstancia || {}));
    var tempTablasGenerales = JSON.parse(JSON.stringify(selectedStepData.tabla || {}));


    var inputsContainer = null;
    var selector = null;
    const infoInputs = {};
    const labelsPorNombreYInstancia = {}; // Clave: nombre+instancia, Valor: label



    if (selectedStepData) {
        var name = selectedStepData.label;
        var instructions = selectedStepData.instrucciones || "";
        var notes = selectedStepData.notas || "";
        var rol = selectedStepData.rol || "";
        var duracion = selectedStepData.Duracion || "";
        var unidadduracion = selectedStepData.unidadduracion || "";
        var tipo = selectedStepData.tipo || "";
        var fechafin = selectedStepData.fechafin || "";
        var elementosRequeridos = selectedStepData.infoElements || [];
        if (!selectedStepData.infoElementsDataPorInstancia) {
            selectedStepData.infoElementsDataPorInstancia = {};
        }






        var unidadText=" días naturales";

            // Crear las opciones para el desplegable "Unidad de duración"
    switch (unidadduracion){
      case "n":
      unidadText= " días naturales";
            break;
      case "h":
      unidadText= " días hábiles";
            break;
      case "l":
      unidadText= " días laborables";
            break;
      case "m":
      unidadText= " meses";
            break;
      case "a":
      unidadText= " años";
            break;
    }


        // Crear un div para el cuadro de diálogo
        // Crear un div para el cuadro de diálogo principal
        var dialogDiv = document.createElement("div");
        dialogDiv.style.display = "flex";
        dialogDiv.style.flexDirection = "column";
        dialogDiv.style.position = "fixed";
        dialogDiv.style.left = "50%";
        dialogDiv.style.top = "50%";
        dialogDiv.style.transform = "translate(-50%, -50%)";
        dialogDiv.style.backgroundColor = "white";
        dialogDiv.style.padding = "20px";
        dialogDiv.style.border = "1px solid #ccc";
        dialogDiv.style.borderRadius = "5px";
        dialogDiv.style.maxHeight = "80vh";
        dialogDiv.style.width = "800px"; // Puedes ajustar esto si lo necesitas
        dialogDiv.style.overflow = "hidden";
        dialogDiv.style.boxShadow = "0 4px 10px rgba(0,0,0,0.2)";
        document.body.appendChild(dialogDiv);

        if (tipo === "step") {
          var nameParagraph = document.createElement("p");
          nameParagraph.style.fontFamily = "Arial";
          nameParagraph.style.fontSize = "14px";
          nameParagraph.style.fontWeight = "bold";
          nameParagraph.style.color = "white";
          nameParagraph.style.backgroundColor = "black";
          nameParagraph.style.padding = "8px 0";
          nameParagraph.style.textAlign = "center";
          nameParagraph.style.margin = "0 0 10px 0"; // sin márgenes laterales, separación inferior
          nameParagraph.textContent = name;
        }else{
          // Mostrar el nombre anterior en negrita (bold)
          var nameParagraph = document.createElement("p");
          nameParagraph.style.fontFamily = "Arial";
          nameParagraph.style.fontSize = "14px";
          nameParagraph.style.fontWeight = "bold";
          nameParagraph.textContent = "" + name;
        }
        dialogDiv.appendChild(nameParagraph);

        // Contenedor desplazable para el contenido
        const contentContainer = document.createElement("div");
        contentContainer.style.overflowY = "auto";
        contentContainer.style.flex = "1";
        contentContainer.style.paddingRight = "10px";
        dialogDiv.appendChild(contentContainer);



        if (tipo === "step") {

            contentContainer.appendChild(crearSeparadorSeccion("INFORMACIÓN DISPONIBLE"));

            var rolParagraphLabel = document.createElement("label");
            rolParagraphLabel.style.fontFamily = "Arial";
            rolParagraphLabel.style.fontSize = "14px";
            rolParagraphLabel.textContent = "Rol: ";
            rolParagraphLabel.style.fontWeight = "bold";
            contentContainer.appendChild(rolParagraphLabel);

            var rolParagraph = document.createElement("label");
            rolParagraph.style.fontFamily = "Arial";
            rolParagraph.style.fontSize = "14px";
            rolParagraph.textContent = rol;
            contentContainer.appendChild(rolParagraph);
            contentContainer.appendChild(document.createElement("br"));
            contentContainer.appendChild(document.createElement("br"));

            var duracionParagraphLabel = document.createElement("label");
            duracionParagraphLabel.style.fontFamily = "Arial";
            duracionParagraphLabel.style.fontSize = "14px";
            duracionParagraphLabel.style.fontWeight = "bold";
            duracionParagraphLabel.textContent = "Duración estimada: ";
            contentContainer.appendChild(duracionParagraphLabel);

            var duracionParagraph = document.createElement("label");
            duracionParagraph.style.fontFamily = "Arial";
            duracionParagraph.style.fontSize = "14px";
            duracionParagraph.textContent = duracion+unidadText;
            contentContainer.appendChild(duracionParagraph);
            contentContainer.appendChild(document.createElement("br"));




 
            var instLabelParagraph = document.createElement("p");
        instLabelParagraph.style.fontFamily = "Arial";
        instLabelParagraph.style.fontSize = "14px";
        instLabelParagraph.style.fontWeight = "bold";
        instLabelParagraph.textContent = "Instrucciones:";
        contentContainer.appendChild(instLabelParagraph);

        var instructionsParagraph = document.createElement("p");
        instructionsParagraph.style.fontFamily = "Arial";
        instructionsParagraph.style.fontSize = "14px";
        instructionsParagraph.style.overflowY = "auto"; // Añade la barra de desplazamiento si es necesario
        instructionsParagraph.style.maxHeight = "200px"; // Altura máxima antes de mostrar la barra de desplazamiento



        // La variable 'Ruta' contiene la ruta base
        var instructionsWithLinks = convertLinks(instructions, Ruta);
        var instructionsFormatted = instructionsWithLinks.replace(/\n/g, "<br>");

          if (tipo === "step") {
            instructionsParagraph.innerHTML = instructionsFormatted;
          } else if (tipo === "milestone") {
            instructionsParagraph.innerHTML = instructionsFormatted;
          }
        

          contentContainer.appendChild(instructionsParagraph);
          contentContainer.appendChild(document.createElement("br"));


          // Mostrar elementos recibidos en modo solo lectura
if (selectedStepData.receivedElements && Array.isArray(selectedStepData.receivedElements)) {

    const receivedHeader = document.createElement("h4");
    receivedHeader.textContent = "Elementos de información recibidos:";
    receivedHeader.style.fontFamily = "Arial";
    receivedHeader.style.marginTop = "20px";
    receivedHeader.style.color = color_menu_titles;
    contentContainer.appendChild(receivedHeader);


    const elementosGenerales = [];
    const elementosPorInstancia = {};

    selectedStepData.receivedElements.forEach(received => {
        if (selectedStepData.receivedElements && Array.isArray(selectedStepData.receivedElements)) {


    if (received.type === "htmlBlock") {
        // 🧩 Mostrar directamente el bloque de HTML sin fondo ni borde
        const bloque = document.createElement("div");
        bloque.innerHTML = received.html || "";
        bloque.style.all = "unset"; // sin estilos visibles
        contentContainer.appendChild(bloque);
        return;
    }

    // 👇 Resto de elementos normales
    const origen = flowchartData.steps.find(s => s.id === received.stepId);
    const elem = received.element;
    const nombre = elem.name;

    let valorGeneral = origen?.valor?.[nombre];
    if (valorGeneral && typeof valorGeneral === "object") {
        if (valorGeneral.hasOwnProperty("valor")) valorGeneral = valorGeneral.valor;
        else if (valorGeneral.hasOwnProperty("value")) valorGeneral = valorGeneral.value;
    }

    if (elem.scope !== "Uno para cada ítem") {
        const row = document.createElement("div");
        row.className = "container";

        const label = document.createElement("label");
        label.style.fontWeight = "bold";
        label.style.marginRight = "5px";
        label.textContent = `${nombre}:`;
        row.appendChild(label);

        const valueSpan = document.createElement("span");
        if (elem.type?.startsWith("Check")) {
            valueSpan.textContent = valorGeneral === true || valorGeneral === "on" ? "Sí" : "No";
        } else if (elem.type === "Tabla" && origen.tabla?.[nombre]) {
            const tablaValor = origen.tabla[nombre].rows;
            const tablaOriginal = origen.infoElements.find(el => el.name === nombre)?.tabla?.rows;

            const tablaHTML = document.createElement("table");
            tablaHTML.style.borderCollapse = "collapse";
            tablaHTML.style.marginTop = "5px";
            tablaHTML.style.marginBottom = "5px";

            tablaValor.forEach((fila, i) => {
                const tr = document.createElement("tr");
                fila.split("|||").forEach((celda, j) => {
                    const td = document.createElement("td");
                    td.textContent = celda;
                    td.style.border = "1px solid #ccc";
                    td.style.padding = "4px 8px";
                    if (tablaOriginal && tablaOriginal[i]?.[j] && tablaOriginal[i][j] !== "") {
                        td.style.backgroundColor = "#eee"; // celda bloqueada
                    }
                    tr.appendChild(td);
                });
                tablaHTML.appendChild(tr);
            });

            valueSpan.appendChild(tablaHTML);
        } else {
            valueSpan.textContent = valorGeneral || "(sin valor)";
            if (!valorGeneral) {
                valueSpan.style.fontStyle = "italic";
                valueSpan.style.color = "gray";
            }
        }

        row.appendChild(valueSpan);
        contentContainer.appendChild(row);

    } else if (origen?.infoElementsDataPorInstancia) {
        const instancias = Object.entries(origen.infoElementsDataPorInstancia)
            .filter(([inst, datos]) => datos.hasOwnProperty(nombre))
            .map(([inst, datos]) => {
                let val = datos[nombre];
                if (val && typeof val === "object") {
                    if (val.hasOwnProperty("valor")) val = val.valor;
                    else if (val.hasOwnProperty("value")) val = val.value;
                }
                return { instancia: inst, valor: val };
            });

        if (instancias.length > 0) {
            const contenedorDesplegable = document.createElement("div");
            contenedorDesplegable.style.marginTop = "10px";

            const select = document.createElement("select");
            select.style.marginBottom = "5px";
            instancias.forEach(inst => {
                const opt = document.createElement("option");
                opt.value = inst.instancia;
                opt.textContent = inst.instancia;
                select.appendChild(opt);
            });

            const valorContenedor = document.createElement("div");
            valorContenedor.style.marginTop = "5px";

            const renderValor = (instancia) => {
                const encontrado = instancias.find(i => i.instancia === instancia);
                valorContenedor.innerHTML = "";

                const row = document.createElement("div");
                row.className = "container";

                const label = document.createElement("label");
                label.style.fontWeight = "bold";
                label.style.marginRight = "5px";
                label.textContent = `${nombre}:`;
                row.appendChild(label);

                const valor = encontrado?.valor;
                const valueSpan = document.createElement("span");
                if (elem.type?.startsWith("Check")) {
                    valueSpan.textContent = valor === true || valor === "on" ? "Sí" : "No";
                } else if (elem.type === "Tabla" && valor?.rows) {
                    const tablaHTML = document.createElement("table");
                    tablaHTML.style.borderCollapse = "collapse";
                    tablaHTML.style.marginTop = "5px";
                    tablaHTML.style.marginBottom = "5px";

                    const tablaOriginal = origen.infoElements.find(el => el.name === nombre)?.tabla?.rows;

                    valor.rows.forEach((fila, i) => {
                        const tr = document.createElement("tr");
                        fila.split("|||").forEach((celda, j) => {
                            const td = document.createElement("td");
                            td.textContent = celda;
                            td.style.border = "1px solid #ccc";
                            td.style.padding = "4px 8px";
                            if (tablaOriginal && tablaOriginal[i]?.[j] && tablaOriginal[i][j] !== "") {
                                td.style.backgroundColor = "#eee";
                            }
                            tr.appendChild(td);
                        });
                        tablaHTML.appendChild(tr);
                    });

                    valueSpan.appendChild(tablaHTML);
                } else {
                    valueSpan.textContent = valor || "(sin valor)";
                    if (!valor) {
                        valueSpan.style.fontStyle = "italic";
                        valueSpan.style.color = "gray";
                    }
                }

                row.appendChild(valueSpan);
                valorContenedor.appendChild(row);
            };

            select.addEventListener("change", () => renderValor(select.value));
            renderValor(select.value);

            contenedorDesplegable.appendChild(select);
            contenedorDesplegable.appendChild(valorContenedor);
            contentContainer.appendChild(contenedorDesplegable);
        }
    }


        }

    });

    function crearTablaVisual(tablaEditable, tablaOriginal) {
        const tablaHTML = document.createElement("table");
        tablaHTML.style.borderCollapse = "collapse";
        tablaHTML.style.marginTop = "4px";
        tablaHTML.style.fontFamily = "Arial";

        const filas = (tablaEditable?.rows || []).map(linea =>
            linea.split("|||").map(c => c.trim())
        );

        const celdasBloqueadas = (tablaOriginal?.rows || []).map(linea =>
            linea.map(c => c.trim() !== "")
        );

        filas.forEach((fila, i) => {
            const tr = document.createElement("tr");

            fila.forEach((valor, j) => {
                const td = document.createElement("td");
                td.textContent = valor;
                td.style.border = "1px solid #ccc";
                td.style.padding = "4px 6px";

                if (celdasBloqueadas[i]?.[j]) {
                    td.style.backgroundColor = "#eee";
                }

                tr.appendChild(td);
            });

            tablaHTML.appendChild(tr);
        });

        return tablaHTML;
    }

    // 🔹 Mostrar primero los elementos generales
    elementosGenerales.forEach(e => {
        const row = document.createElement("div");
        row.className = "container";

        const label = document.createElement("label");
        label.style.fontWeight = "bold";
        label.style.marginRight = "5px";
        label.textContent = `${e.nombre}:`;
        row.appendChild(label);

        if (e.tipo === "Tabla" && e.valor?.rows) {
            const tablaOriginal = e.stepOrigen?.infoElements?.find(el => el.name === e.nombre)?.tabla;
            const tablaHTML = crearTablaVisual(e.valor, tablaOriginal);
            row.appendChild(tablaHTML);
        } else {
            const valueSpan = document.createElement("span");

            if (e.valor === undefined || e.valor === null || e.valor === "") {
                valueSpan.textContent = "(sin valor)";
                valueSpan.style.fontStyle = "italic";
                valueSpan.style.color = "gray";
            } else if (e.tipo?.startsWith("Check")) {
                valueSpan.textContent = e.valor === true || e.valor === "on" ? "Sí" : "No";
            } else {
                valueSpan.textContent = e.valor;
            }

            row.appendChild(valueSpan);
        }

        contentContainer.appendChild(row);
    });

    // 🔸 Desplegable para elegir instancia
    const nombresInstancia = Object.keys(elementosPorInstancia);
    if (nombresInstancia.length > 0) {
        contentContainer.appendChild(document.createElement("br"));
        const selectorLabel = document.createElement("label");
        selectorLabel.textContent = "Selecciona elemento:";
        selectorLabel.style.fontFamily = "Arial";
        selectorLabel.style.fontWeight = "bold";
        selectorLabel.style.marginTop = "10px";
        contentContainer.appendChild(selectorLabel);

        const selector = document.createElement("select");
        selector.style.marginLeft = "10px";
        selector.style.fontFamily = "Arial";
        nombresInstancia.forEach(inst => {
            const option = document.createElement("option");
            option.value = inst;
            option.textContent = inst;
            selector.appendChild(option);
        });
        contentContainer.appendChild(selector);

        const instanciaContainer = document.createElement("div");
        instanciaContainer.style.marginTop = "10px";
        contentContainer.appendChild(instanciaContainer);

        function mostrarInstancia(nombre) {
            instanciaContainer.innerHTML = "";
            const elementos = elementosPorInstancia[nombre] || [];

            const tarjeta = document.createElement("div");
            tarjeta.style.border = "1px solid #ccc";
            tarjeta.style.borderRadius = "6px";
            tarjeta.style.padding = "10px 15px";
            tarjeta.style.marginTop = "10px";
            tarjeta.style.marginBottom = "10px";
            tarjeta.style.backgroundColor = "#fdfdfd";

            elementos.forEach(e => {
                const row = document.createElement("div");
                row.className = "container";
                row.style.marginBottom = "6px";

                const label = document.createElement("label");
                label.style.fontWeight = "bold";
                label.style.marginRight = "5px";
                label.textContent = `${e.nombre}:`;
                row.appendChild(label);

                if (e.tipo === "Tabla" && e.valor?.rows) {
                    const tablaOriginal = e.stepOrigen?.infoElements?.find(el => el.name === e.nombre)?.tabla;
                    const tablaHTML = crearTablaVisual(e.valor, tablaOriginal);
                    row.appendChild(tablaHTML);
                } else {
                    const valueSpan = document.createElement("span");

                    if (e.valor === undefined || e.valor === null || e.valor === "") {
                        valueSpan.textContent = "(sin valor)";
                        valueSpan.style.fontStyle = "italic";
                        valueSpan.style.color = "gray";
                    } else if (e.tipo?.startsWith("Check")) {
                        valueSpan.textContent = e.valor === true || e.valor === "on" ? "Sí" : "No";
                    } else {
                        valueSpan.textContent = e.valor;
                    }

                    row.appendChild(valueSpan);
                }

                tarjeta.appendChild(row);
            });

            instanciaContainer.appendChild(tarjeta);

        }

        // Mostrar la primera por defecto
        mostrarInstancia(nombresInstancia[0]);

        selector.addEventListener("change", () => {
            mostrarInstancia(selector.value);
        });
    }
}









          contentContainer.appendChild(crearSeparadorSeccion("INFORMACIÓN A APORTAR"));


          contentContainer.appendChild(document.createElement("br"));


          // 🔵 Construir jerarquía directamente desde los elementos
          const elementosGenerales = elementosRequeridos.filter(e => e.scope === "Uno para todos los ítems");
          const elementosPorInstancia = elementosRequeridos.filter(e => e.scope === "Uno para cada ítem");


          let apartadosEnOrden = new Set();

          // 1. Recoger todos los apartados definidos
          elementosGenerales.forEach(e => {
              const partes = (e.apartado || "(Seleccionar apartado)").split(">");
              for (let i = 1; i <= partes.length; i++) {
                  const ruta = partes.slice(0, i).join(">");
                  apartadosEnOrden.add(ruta);
              }
          });

          // 2. Añadir "(Seleccionar apartado)" si hay elementos sin apartado definido
          const haySinAsignar = elementosGenerales.some(e => !e.apartado);
          if (haySinAsignar) apartadosEnOrden.add("(Seleccionar apartado)");

          apartadosEnOrden = [...apartadosEnOrden];
          console.log("🧭 apartadosEnOrden construidos desde los elementos:", apartadosEnOrden);


          console.log("🧱 apartadosEnOrden (después del parseo):", apartadosEnOrden);

          // Añadir todos los niveles intermedios para asegurarse de que se pintan encabezados padres
          let jerarquiaCompleta = new Set();
          apartadosEnOrden.forEach(ruta => {
              const partes = ruta.split(">");
              for (let i = 1; i <= partes.length; i++) {
                  const subRuta = partes.slice(0, i).join(">");
                  jerarquiaCompleta.add(subRuta);
              }
          });
          apartadosEnOrden = [...jerarquiaCompleta];
          console.log("✅ apartadosEnOrden con jerarquía expandida:", apartadosEnOrden);

          // Añadir "(Seleccionar apartado)" si hay elementos no asignados correctamente
          if (haySinAsignar) apartadosEnOrden.push("(Seleccionar apartado)");

          console.log("📌 apartadosEnOrden con (Seleccionar apartado):", apartadosEnOrden);

          // Crear copia sin tocar los elementos originales
          const elementosGeneralesCopia = elementosGenerales.map(e => {
              const apartadoLimpio = (e.apartado || "").trim();
              return {
                  ...e,
                  apartado: apartadoLimpio || "(Seleccionar apartado)"
              };
          });

          // Mostrar encabezados y elementos agrupados
          apartadosEnOrden.forEach(function (apartadoRutaCompleta) {
              const partes = apartadoRutaCompleta.split(">");
              const nivel = partes.length - 1;
              const nombreVisible = partes[partes.length - 1];

              console.log("🔽 Mostrando encabezado:", apartadoRutaCompleta);

              const header = document.createElement("h5");
              header.innerHTML = apartadoRutaCompleta === "(Seleccionar apartado)"
                  ? "Elementos sin asignar:"
                  : "&nbsp;".repeat(nivel * 4) + nombreVisible;

              header.style.fontFamily = "Arial";
              header.style.marginTop = nivel === 0 ? "32px" : "16px";
              header.style.marginBottom = "12px";
              header.style.color = apartadoRutaCompleta === "(Seleccionar apartado)" ? "red" : color_text_titles;
              header.style.fontSize = nivel === 0 ? "16px" : nivel === 1 ? "14px" : "13px";
              if (nivel > 1) header.style.fontStyle = "italic";
              if (apartadoRutaCompleta === "(Seleccionar apartado)") header.style.fontWeight = "bold";

              contentContainer.appendChild(header);

              // Mostrar elementos de este apartado
              const elementosEnEsteApartado = elementosGeneralesCopia.filter(e => e.apartado === apartadoRutaCompleta);
              console.log("🧩 Elementos en", apartadoRutaCompleta, ":", elementosEnEsteApartado.map(e => e.name));

              elementosEnEsteApartado.forEach(function (element) {
                  const tipo = element.type;
                  const valor = element.valor || "";
                  const bloque = crearBloqueCampoInformacion(tipo, element, valor);
                  if (bloque) {
                      // Crear contenedor general para el campo + ayuda
                      const bloqueConAyuda = document.createElement("div");
                      bloqueConAyuda.style.display = "flex";
                      bloqueConAyuda.style.flexDirection = "column";
                      bloqueConAyuda.style.alignItems = "flex-start";
                      if (element.type !== "Texto o html (no editable)") {
                          bloqueConAyuda.style.marginBottom = "10px";
                      }

                      bloqueConAyuda.appendChild(bloque);

                      // Añadir información adicional siempre debajo
                      if (element.informacion && element.informacion.trim() !== "") {
                          const infoDiv = document.createElement("div");
                          infoDiv.innerHTML = element.informacion;
                          infoDiv.style.fontFamily = "Arial";
                          if (tipo!=="Texto o html (no editable)"){
                            infoDiv.style.marginTop = "4px";
                            infoDiv.style.fontSize = "13px";
                            infoDiv.style.color = "#555";
                            infoDiv.style.maxWidth = "600px";
                          }
                          infoDiv.style.whiteSpace = "pre-wrap";
                          bloqueConAyuda.appendChild(infoDiv);
                      }

                      infoInputs[element.name] = bloque.querySelector("input, textarea, select, button");
                      contentContainer.appendChild(bloqueConAyuda);
                  }

              });
          });




        //const elementosPorInstancia = elementosRequeridos.filter(e => e.scope === "Uno para cada ítem");


        if (elementosPorInstancia.length > 0) {

          const tituloCada = document.createElement("div");
          tituloCada.style.fontFamily = "Arial";
          tituloCada.style.fontSize = "14px";
          tituloCada.style.fontWeight = "bold";
          tituloCada.style.color = color_menu_titles;
          tituloCada.style.padding = "8px";
          tituloCada.style.margin = "20px 0 10px 0";
          tituloCada.textContent = "PARA CADA ÍTEM:";
          contentContainer.appendChild(tituloCada);

            const container = document.createElement("div");
            container.style.border = "1px solid #ccc";
            container.style.padding = "8px";
            container.style.margin = "1px 0";
            container.style.borderRadius = "5px";

            const labelSelector = document.createElement("label");
            labelSelector.textContent = "Selecciona ítem:";
            labelSelector.style.fontFamily = "Arial";
            labelSelector.style.fontWeight = "bold";
            container.appendChild(labelSelector);

            selector = document.createElement("select");
            selector.style.marginLeft = "10px";
            selector.style.fontFamily = "Arial";

            const defaultOption = document.createElement("option");
            defaultOption.value = "";
            defaultOption.textContent = selectedStepData.multiple_task_following_previous
                ? "-- Selecciona --"
                : "-- Selecciona o añade --";
            selector.appendChild(defaultOption);


            container.appendChild(selector);

            const btnAdd = document.createElement("button");
            btnAdd.textContent = "Añadir";
            btnAdd.style.marginLeft = "10px";

            const btnDel = document.createElement("button");
            btnDel.textContent = "Eliminar";
            btnDel.style.marginLeft = "5px";

            // Ocultar si la lista viene de otra tarea
            if (selectedStepData.multiple_task_following_previous) {
                btnAdd.style.display = "none";
                btnDel.style.display = "none";
            }

            container.appendChild(btnAdd);
            container.appendChild(btnDel);
            contentContainer.appendChild(container);

            // Input fields por cada tipo, dentro de este contenedor
            inputsContainer = document.createElement("div");
            inputsContainer.style.marginTop = "10px";
            container.appendChild(inputsContainer);




            // Si viene de otra tarea, copiar sus instancias
            const instanciasIgnoradasDeTareaAnterior = new Set();
            if (selectedStepData.multiple_task_following_previous) {
              const stepIdAnterior = selectedStepData.multiple_task_following_previous;
              const tareaAnterior = flowchartData.steps.find(s => s.id === stepIdAnterior);

              if (tareaAnterior && tareaAnterior.infoElementsDataPorInstancia) {
                const nombresInstanciasPrevias = Object.keys(tareaAnterior.infoElementsDataPorInstancia);

                nombresInstanciasPrevias.forEach(nombre => {
                    // Evitar duplicados en el selector
                    const yaExiste = [...selector.options].some(opt => opt.value === nombre);
                    if (yaExiste) return;

                    const datosPrevios = tareaAnterior.infoElementsDataPorInstancia[nombre];
                    const estadoFinalPrevio = datosPrevios?.finalState?.value;

                    // Mostrar solo los que estaban OK en el desplegable
                    if (estadoFinalPrevio === "completed") {
                        const option = document.createElement("option");
                        option.value = nombre;
                        option.text = `${nombre} (de ${tareaAnterior.label})`;
                        selector.appendChild(option);
                    }else{
                      instanciasIgnoradasDeTareaAnterior.add(nombre);
                    }

                    // En cualquier caso, añadir a la variable temporal
                    if (!tempInfoElementsDataPorInstancia[nombre]) {
                        tempInfoElementsDataPorInstancia[nombre] = {};
                    }

                    elementosPorInstancia.forEach(e => {
                        const valorPrevio = datosPrevios?.[e.name];
                        if (valorPrevio) {
                            tempInfoElementsDataPorInstancia[nombre][e.name] = JSON.parse(JSON.stringify(valorPrevio));
                        }
                    });

                    if (estadoFinalPrevio === "cancelled") {
                        tempInfoElementsDataPorInstancia[nombre]["finalState"] = JSON.parse(JSON.stringify(datosPrevios.finalState));
                    } else if (!estadoFinalPrevio) {
                        tempInfoElementsDataPorInstancia[nombre]["finalState"] = undefined;
                    }
                });
            }

          }

            // Cargar instancias existentes (solo las que NO provienen de la tarea anterior o ya estaban en el selector)
            const nombresYaCargados = new Set([...selector.options].map(opt => opt.value));
            const instancias = Object.keys(selectedStepData.infoElementsDataPorInstancia || {});

            instancias.forEach(nombre => {
                if (nombresYaCargados.has(nombre)) return;
                if (instanciasIgnoradasDeTareaAnterior.has(nombre)) return; // 👈 NO añadir si fue ignorada

                const option = document.createElement("option");
                option.value = nombre;
                option.text = nombre;
                selector.appendChild(option);
            });


            actualizarOpcionesSelectorEstado();

            // Redibujar campos al seleccionar instancia
            function renderInputsForItem(nombre) {
                console.log("🟡 renderInputsForItem - nombre:", nombre);
                inputsContainer.innerHTML = "";

                if (!nombre) return;

                const estructuraTexto = selectedStepData.estructuraApartados || "";
                console.log("📄 Estructura original:\n", estructuraTexto);
                const lineas = estructuraTexto.split("\n").map(l => l.trim()).filter(Boolean);
                console.log("📚 Líneas interpretadas:", lineas);

                let rutaActual = [];
                const rutasMostradas = new Set();

                lineas.forEach((linea, i) => {
                    console.log(`🔹 Procesando línea ${i + 1}: "${linea}"`);
                    let nivel = 0;
                    if (linea.startsWith(">>")) {
                        nivel = 2;
                    } else if (linea.startsWith(">")) {
                        nivel = 1;
                    }

                    const texto = linea.replace(/^>+/, "").trim();

                    // Actualizar ruta actual según el nivel
                    rutaActual = rutaActual.slice(0, nivel); // recorta a nivel anterior
                    rutaActual[nivel] = texto;

                    console.log("📍 Ruta actual:", rutaActual);
                    const rutaCompleta = rutaActual.join(">");
                    console.log("📍 Ruta completa:", rutaCompleta);

                    // Buscar elementos en esta ruta
                    const elementos = elementosPorInstancia.filter(e =>
                        (e.scope === "Uno para cada ítem") &&
                        e.apartado === rutaCompleta
                    );

                    console.log(`🧩 Elementos en ${rutaCompleta} :`, elementos.map(e => e.name));

                    if (elementos.length > 0) {
                        // Mostrar encabezados para todos los niveles previos
                        for (let j = 0; j <= nivel; j++) {
                            const subRuta = rutaActual.slice(0, j + 1).join(">");
                            if (!rutasMostradas.has(subRuta) && rutaActual[j] !== "Sin título") {
                                const header = document.createElement("h5");
                                header.innerHTML = "&nbsp;".repeat(j * 4) + rutaActual[j];
                                header.style.fontFamily = "Arial";
                                header.style.marginTop = j === 0 ? "32px" : "16px";
                                header.style.marginBottom = "12px";
                                header.style.color = color_text_titles;

                                if (j === 0) {
                                    header.style.fontSize = "16px";
                                    header.style.fontWeight = "bold";
                                } else if (j === 1) {
                                    header.style.fontSize = "14px";
                                } else {
                                    header.style.fontSize = "13px";
                                    header.style.fontStyle = "italic";
                                }

                                inputsContainer.appendChild(header);
                                rutasMostradas.add(subRuta);
                                console.log("📢 Mostrado encabezado:", subRuta);
                            }
                        }

                        // Mostrar los inputs del apartado
                        elementos.forEach(element => {
                            console.log("🔍 Información para", element.name, ":", element.informacion);

                            const valor = tempInfoElementsDataPorInstancia?.[nombre]?.[element.name]?.value || "";
                            const bloque = crearBloqueCampoInformacion(element.type, element, valor, nombre);

                            if (bloque) {
                                // 🔁 Contenedor vertical que envuelve el campo + texto de ayuda
                                const bloqueConAyuda = document.createElement("div");
                                bloqueConAyuda.style.display = "flex";
                                bloqueConAyuda.style.flexDirection = "column";
                                bloqueConAyuda.style.alignItems = "flex-start";
                                if (element.type !== "Texto o html (no editable)") {
                                    bloqueConAyuda.style.marginBottom = "10px";
                                }


                                bloqueConAyuda.appendChild(bloque);

                                if (element.informacion && element.informacion.trim() !== "") {
                                    const infoDiv = document.createElement("div");
                                    infoDiv.innerHTML = element.informacion;
                                    infoDiv.style.fontFamily = "Arial";
                                    if (element.type!=="Texto o html (no editable)"){
                                      infoDiv.style.marginTop = "4px";
                                      infoDiv.style.fontSize = "13px";
                                      infoDiv.style.color = "#555";
                                      infoDiv.style.maxWidth = "600px";
                                    }
                                    infoDiv.style.whiteSpace = "pre-wrap";
                                    bloqueConAyuda.appendChild(infoDiv);
                                }

                                inputsContainer.appendChild(bloqueConAyuda);
                            }
                        });




                    }
                });

                // Botones finales
                const estadoDiv = document.createElement("div");
                estadoDiv.style.marginTop = "10px";
                estadoDiv.style.marginBottom = "10px";

                const btnOK = document.createElement("button");
                btnOK.innerHTML = "✅ Ítem finalizado";
                btnOK.style.marginRight = "10px";
                btnOK.style.padding = "6px 12px";
                btnOK.style.borderRadius = "4px";
                btnOK.style.fontWeight = "bold";

                btnOK.addEventListener("click", function () {
                    // Guardar los datos antes de validar
                    guardarDatosDeInputs(nombre);

                    const faltan = getElementosObligatoriosNoRellenadosPorInstancia(selectedStepData, nombre);

                    if (faltan.length > 0) {
                        remarcarObligatoriosFaltantesDeInstancia(selectedStepData, nombre); // Para que lo pinte en rojo

                       // const mensaje = faltan.map(f => f.nombre).join("\n");
                       // alert("Faltan campos obligatorios:\n\n" + mensaje);
                        return;
                    }

                    // Si todo bien, marcar como finalizado
                    if (confirm("¿Deseas marcar esta tarea como completada?")) {
                        if (!tempInfoElementsDataPorInstancia[nombre]) {
                            tempInfoElementsDataPorInstancia[nombre] = {};
                        }
                        tempInfoElementsDataPorInstancia[nombre]["finalState"] = {
                            type: "Estate",
                            value: "completed"
                        };
                        actualizarOpcionesSelectorEstado();
                    }
                });




                const btnCancel = document.createElement("button");
                btnCancel.innerHTML = "❌ Ítem cancelado";
                btnCancel.style.padding = "6px 12px";
                btnCancel.style.borderRadius = "4px";
                btnCancel.style.fontWeight = "bold";

                btnCancel.addEventListener("click", function () {
                  if (confirm("¿Deseas cancelar esta tarea?")) {
                    if (!tempInfoElementsDataPorInstancia[nombre]) {
                        tempInfoElementsDataPorInstancia[nombre] = {};
                    }
                    tempInfoElementsDataPorInstancia[nombre]["finalState"] = {
                        type: "Estate",
                        value: "cancelled"
                    };
                    actualizarOpcionesSelectorEstado();
                }
                });

                estadoDiv.appendChild(btnOK);
                estadoDiv.appendChild(btnCancel);
                inputsContainer.appendChild(estadoDiv);
            }




            function actualizarOpcionesSelectorEstado() {
                [...selector.options].forEach(option => {
                    const nombre = option.value;
                    if (!nombre || nombre === "") return;

                    const datos = tempInfoElementsDataPorInstancia[nombre];
                    const estado = datos?.["finalState"]?.value || "";
                    const explicacion = datos?.["finalState"]?.explicacion || "";

                    let sufijo = "";
                    if (estado === "completed") sufijo = " ✅";
                    else if (estado === "cancelled") sufijo = " ❌";

                    option.textContent = nombre + sufijo;

                    // Tooltip solo si hay explicación
                    if (estado === "cancelled" && explicacion) {
                        option.title = `Motivo de cancelación: ${explicacion}`;
                    } else {
                        option.removeAttribute("title");
                    }
                });
            }



            function guardarDatosDeInputs(nombre) {
                if (!nombre) {
                    console.warn("⛔ Nombre no válido en guardarDatosDeInputs");
                    return;
                }

                console.log(`🔄 Guardando datos de inputs para la instancia: ${nombre}`);

                // Forzar que todos los campos pierdan el foco para aplicar posibles cambios pendientes
                inputsContainer.querySelectorAll("input, textarea, select").forEach(el => el.blur());

                // Asegurar la estructura de datos temporal
                if (!tempInfoElementsDataPorInstancia[nombre]) {
                    tempInfoElementsDataPorInstancia[nombre] = {};
                    console.log(`📦 Se ha creado una nueva entrada vacía para ${nombre}`);
                }

                // Recorremos todos los elementos con data-elementName
                const campos = [...inputsContainer.getElementsByTagName("*")].filter(el => el.dataset?.elementName);
                console.log(`🔍 Se han encontrado ${campos.length} campos con data-elementName`);

                console.log("🔍 Campos detectados:", campos.map(c => c.dataset.elementName));


                campos.forEach(input => {
                    const elementName = input.dataset.elementName;
                    if (!elementName) {
                        console.warn("❗ Campo sin elementName detectado");
                        return;
                    }

                    const elemento = elementosPorInstancia.find(e => e.name === elementName);
                    if (!elemento) {
                        console.warn(`❗ No se encontró el elemento en elementosPorInstancia con name=${elementName}`);
                        return;
                    }

                    const tipo = elemento.type;
                    let valor;

                    if (tipo === "Archivo") {
                        console.log(`📁 Procesando archivo para ${elementName}`);
                        if (input?.type === "file" && input.files?.length > 0) {
                            valor = input.files[0].name;
                            console.log(`✅ Archivo desde input: ${valor}`);
                        } else {
                            const contenedor = input?.parentNode || inputsContainer;
                            const spans = contenedor?.querySelectorAll("span");
                            spans?.forEach(s => console.log("🔍 span detectado:", s.textContent));

                            // Buscar el span que contenga un texto que parezca un nombre de archivo
                            const labelArchivo = [...spans || []].find(s =>
                                s.textContent?.trim() &&
                                !s.textContent.includes("•") &&
                                !s.textContent.endsWith(":")
                            );

                            valor = labelArchivo?.textContent?.trim() || "";
                            if (valor) {
                                console.log(`✅ Archivo desde label: ${valor}`);
                            } else {
                                console.warn(`⚠️ No se detectó archivo visible para ${elementName}`);
                            }
                        }
                    } else if (tipo === "Check independiente" || tipo === "Check ligado a grupo") {
                        valor = input.checked;
                    } else if (tipo === "Desplegable selección múltiple") {
                        valor = [...input.selectedOptions].map(o => o.value);
                    } else {
                        valor = input.value;
                    }

                    // Guardamos en la estructura temporal
                    tempInfoElementsDataPorInstancia[nombre][elementName] = {
                        type: tipo,
                        value: valor
                    };

                    console.log(`✅ Guardado: ${elementName} =`, valor);
                });

                console.log("📥 Estado final tempInfoElementsDataPorInstancia[nombre]:", tempInfoElementsDataPorInstancia[nombre]);
            }








            selector.addEventListener("change", function () {
                const previousNombre = selector.dataset.previousNombre;
                if (previousNombre) {
                    guardarDatosDeInputs(previousNombre); //  guardar todo lo editado
                }

                selector.dataset.previousNombre = selector.value; // actualizar el nombre actual

                renderInputsForItem(selector.value); // dibujar los inputs del nuevo
                //remarcarObligatoriosFaltantesParaStepCompleto(selectedStepData, selector.value);

            });

            function remarcarObligatoriosFaltantesParaStepCompleto(stepData, nombreInstancia = null) {
                const faltan = getElementosObligatoriosNoRellenadosParaStepCompleto(stepData)
                    .filter(f => !nombreInstancia || !f.instancia || f.instancia === nombreInstancia);

                console.log(`🧪 Validando campos obligatorios para instancia: ${nombreInstancia || "(global y activa)"}`);
                console.log("❗ Elementos no rellenados:", faltan);

                if (faltan.length > 0) {
                    const fechaInput = document.getElementById("fechaFin");
                    if (fechaInput) {
                        fechaInput.value = "";
                        console.log("🗑 Fecha eliminada por campos obligatorios sin rellenar");
                    }

                    marcarLabelsEnRojo(faltan);
                    alert("Faltan campos obligatorios:\n\n" + generarMensajeFaltantes(faltan));
                    return false;
                }

                return true;
            }

            function remarcarObligatoriosFaltantesDeInstancia(stepData, nombreInstancia) {
                const faltan = getElementosObligatoriosNoRellenadosPorInstancia(stepData, nombreInstancia);

                console.log(`🧪 Validando solo instancia: ${nombreInstancia}`);
                console.log("❗ Elementos no rellenados:", faltan);

                if (faltan.length > 0) {
                    marcarLabelsEnRojo(faltan);
                    alert("Faltan campos obligatorios:\n\n" + generarMensajeFaltantes(faltan));
                    return false;
                }

                return true;
            }

            function marcarLabelsEnRojo(faltan) {
                faltan.forEach(({ nombre, instancia }) => {
                    const clave = instancia ? `${nombre}|||${instancia}` : nombre;
                    const label = labelsPorNombreYInstancia[clave];

                    if (label) {
                        label.classList.add("label-error");
                        console.log(`🔴 Label marcado en rojo: ${clave}`);
                    } else {
                        console.warn(`⚠️ No se encontró label para: ${clave}`);
                    }

                    const input = instancia
                        ? document.querySelector(`[data-elementname="${nombre}"][data-instancia="${instancia}"]`)
                        : infoInputs[nombre];

                   if (input) {
                    const limpiarError = () => {
                        const claveLimpieza = instancia ? `${nombre}|||${instancia}` : nombre;
                        const labelLimpieza = labelsPorNombreYInstancia[claveLimpieza];
                        if (labelLimpieza) {
                            labelLimpieza.classList.remove("label-error");
                            console.log(`✅ Eliminado error visual de: ${claveLimpieza}`);
                        }
                    };

                    input.addEventListener("input", limpiarError, { once: true });
                    input.addEventListener("change", limpiarError, { once: true });
                }

                });
            }

            function generarMensajeFaltantes(faltan) {
                return faltan.map(({ nombre, instancia }) =>
                    instancia ? `${nombre} (instancia: ${instancia})` : nombre
                ).join("\n");
            }








            btnAdd.addEventListener("click", function () {
              const selectedNombre = selector.value;
              if (selectedNombre) {
                  guardarDatosDeInputs(selectedNombre);
              }

              const miniDialog = document.createElement("div");
              miniDialog.style.position = "fixed";
              miniDialog.style.left = "50%";
              miniDialog.style.top = "50%";
              miniDialog.style.transform = "translate(-50%, -50%)";
              miniDialog.style.backgroundColor = "white";
              miniDialog.style.border = "1px solid #ccc";
              miniDialog.style.borderRadius = "6px";
              miniDialog.style.padding = "20px";
              miniDialog.style.fontFamily = "Arial";
              miniDialog.style.zIndex = "1000";
              miniDialog.style.boxShadow = "0px 4px 10px rgba(0,0,0,0.2)";

              const title = document.createElement("p");
              title.textContent = "Nombre del nuevo ítem";
              title.style.fontSize = "14px";
              title.style.fontWeight = "bold";
              title.style.marginBottom = "10px";
              miniDialog.appendChild(title);

              const inputNombre = document.createElement("input");
              inputNombre.type = "text";
              inputNombre.placeholder = "Escribe un nombre";
              inputNombre.style.fontFamily = "Arial";
              inputNombre.style.fontSize = "14px";
              inputNombre.style.padding = "6px";
              inputNombre.style.width = "260px";
              inputNombre.style.marginBottom = "10px";
              inputNombre.style.border = "1px solid #ccc";
              inputNombre.style.borderRadius = "4px";
              miniDialog.appendChild(inputNombre);
              miniDialog.appendChild(document.createElement("br"));

              const btnAceptarNuevo = document.createElement("button");
              btnAceptarNuevo.textContent = "Aceptar";
              btnAceptarNuevo.style.fontFamily = "Arial";
              btnAceptarNuevo.style.fontSize = "14px";
              btnAceptarNuevo.style.marginRight = "10px";
              btnAceptarNuevo.style.padding = "6px 12px";
              btnAceptarNuevo.style.borderRadius = "4px";

              const btnCancelarNuevo = document.createElement("button");
              btnCancelarNuevo.textContent = "Cancelar";
              btnCancelarNuevo.style.fontFamily = "Arial";
              btnCancelarNuevo.style.fontSize = "14px";
              btnCancelarNuevo.style.padding = "6px 12px";
              btnCancelarNuevo.style.borderRadius = "4px";

              miniDialog.appendChild(btnCancelarNuevo);
              miniDialog.appendChild(btnAceptarNuevo);

              document.body.appendChild(miniDialog);

              btnAceptarNuevo.addEventListener("click", function () {
                  const nuevo = inputNombre.value.trim();
                  if (!nuevo) {
                      alert("El nombre no puede estar vacío.");
                      return;
                  }
                  if ([...selector.options].some(o => o.value === nuevo)) {
                      alert("Ese nombre ya existe.");
                      return;
                  }

                  // Añadir al selector y preseleccionar
                  const option = document.createElement("option");
                  option.value = nuevo;
                  option.textContent = nuevo;
                  selector.appendChild(option);
                  selector.value = nuevo;

                  // AÑADIR VACÍO a la variable temporal aunque no se rellenen los campos
                  if (!tempInfoElementsDataPorInstancia[nuevo]) {
                      tempInfoElementsDataPorInstancia[nuevo] = {};
                  }

                  // Disparar el cambio para renderizar los inputs
                  setTimeout(() => {
                        selector.dispatchEvent(new Event("change"));
                    }, 0);


                  document.body.removeChild(miniDialog);
              });

              btnCancelarNuevo.addEventListener("click", function () {
                  document.body.removeChild(miniDialog);
              });
          });




          btnDel.addEventListener("click", function () {
            const val = selector.value;
            if (!val) return;

            if (confirm(`¿Eliminar '${val}'?`)) {
                // Eliminar la opción del selector
                [...selector.options].forEach(opt => {
                    if (opt.value === val) selector.removeChild(opt);
                });

                // Eliminar de la copia temporal
                delete tempInfoElementsDataPorInstancia[val];

                // También, si hay tablas por instancia, eliminarlas si existen
                if (tempTablasGenerales) {
                    elementosPorInstancia.forEach(e => {
                        if (tempTablasGenerales[e.name] &&
                            tempTablasGenerales[e.name][val]) {
                            delete tempTablasGenerales[e.name][val];
                        }
                    });
                }

                // Limpiar los inputs
                selector.value = "";
                selector.dataset.previousNombre = "";
                inputsContainer.innerHTML = "";
            }

        });


          }

          contentContainer.appendChild(document.createElement("br"));
          contentContainer.appendChild(crearSeparadorSeccion("ESTADO DE LA TAREA"));
          // Mostrar "Notas:" en una línea nueva
          var notesLabel = document.createElement("label");
      notesLabel.for = "notas";
      notesLabel.style.verticalAlign = "top";
      notesLabel.style.fontFamily = "Arial";
      notesLabel.style.fontSize = "14px";
      notesLabel.textContent = "Notas: ";
      notesLabel.style.fontWeight = "bold";
      contentContainer.appendChild(notesLabel);

      var notesExpLabel = document.createElement("label");
      notesExpLabel.for = "explicación notas";
      notesExpLabel.style.verticalAlign = "top";
      notesExpLabel.style.fontFamily = "Arial";
      notesExpLabel.style.fontSize = "14px";
      notesExpLabel.textContent = "Poner información útil del estado actual, p.ej. si se encuentra pendiente de otra acción. Dejar vacío si está en proceso normalmente. Para vínculo a archivo cargado poner /*nombrearchivo*/. Esta nota se borrará automáticamente al finalizar la tarea.";
      contentContainer.appendChild(notesExpLabel);
      contentContainer.appendChild(document.createElement("br"));

        // Mostrar el campo de notas en una línea nueva
        var notesTextarea = document.createElement("textarea");
      notesTextarea.id = "notas";
      notesTextarea.rows = "10";
      notesTextarea.cols = "65";
      notesTextarea.style.fontFamily = "Arial";
      notesTextarea.style.overflowY = "auto"; // Añade la barra de desplazamiento si es necesario
      notesTextarea.style.maxHeight = "50px"; // Altura máxima antes de mostrar la barra de desplazamiento
      notesTextarea.textContent = notes;
      contentContainer.appendChild(notesTextarea);
      contentContainer.appendChild(document.createElement("br"));
    
      
        }




        if ((tipo==='step')&&(!modoProcesosGenerales)){
      

      // Agregar un retorno de carro
      contentContainer.appendChild(document.createElement("br"));

const fechaWrapper = document.createElement("div");
fechaWrapper.style.display = "flex";
fechaWrapper.style.alignItems = "center";
fechaWrapper.style.marginBottom = "8px";

const validacionOK = document.createElement("span");
validacionOK.id = "iconoValidacionFecha";
validacionOK.textContent = "✅";
validacionOK.style.color = "green";
validacionOK.style.fontWeight = "bold";
validacionOK.style.marginRight = "6px";

const fechafinLabel = document.createElement("label");
fechafinLabel.textContent = "Fecha en que la tarea ha finalizado:";
fechafinLabel.setAttribute("for", "fechaFin");
fechafinLabel.style.fontFamily = "Arial";
fechafinLabel.style.fontSize = "14px";
fechafinLabel.style.fontWeight = "bold";
fechafinLabel.style.marginRight = "8px";

fechafinSelect = document.createElement("input");
fechafinSelect.type = "date";
fechafinSelect.id = "fechaFin";
fechafinSelect.value = fechafin;
fechafinSelect.style.fontSize = "14px";

fechaWrapper.appendChild(validacionOK);
fechaWrapper.appendChild(fechafinLabel);
fechaWrapper.appendChild(fechafinSelect);
contentContainer.appendChild(fechaWrapper);



fechafinSelect.addEventListener("change", () => {
    const valor = fechafinSelect.value;
    if (esFechaValida(valor) && valor !== "") {
        console.log("📅 Fecha válida introducida, activando validación visual");

        const instanciaActiva = selector?.value;
        if (instanciaActiva) {
            guardarDatosDeInputs(instanciaActiva);
        }

        remarcarObligatoriosFaltantesParaStepCompleto(selectedStepData);
    }
});

/* //El selector de fechas ya tiene dentro un Borrar fecha.
var borrarFechaButton = document.createElement("button");
borrarFechaButton.textContent = "Borrar fecha";
borrarFechaButton.addEventListener("click", function() {
  // Borra la selección de fecha
  fechafinSelect.value = "";
});

contentContainer.appendChild(borrarFechaButton);
*/
contentContainer.appendChild(document.createElement("br"));
contentContainer.appendChild(document.createElement("br"));

  }

        var btnAceptar = document.createElement("button");
        btnAceptar.textContent = "Aceptar";
        btnAceptar.style.position = "absolute";
        btnAceptar.style.bottom = "10px";
        btnAceptar.style.right = "90px";
        const originalAceptar = btnAceptar.onclick || (() => {});
        btnAceptar.addEventListener("click", function () {
            var selectedStepData = flowchartData.steps.find(function (step) {
                return step.id === selectedStep[0];
            });

            if (selectedStepData) {
                if (tipo === "step") {
                    var notas = document.getElementById("notas").value;
                    if (!modoProcesosGenerales) {
                        selectedStepData.notas = notas;
                        selectedStepData.fechafin = fechaFin.value;

                        if (!esFechaValida(fechafinSelect.value)) {
                            delete selectedStepData.fechafin;
                        }
                    }

                    if (!selectedStepData.infoElements) {
                        selectedStepData.infoElements = [];
                    }

                    // Volcar los datos temporales de tablas generales a selectedStepData.tabla
                    if (!selectedStepData.tabla) selectedStepData.tabla = {};
                    Object.keys(tempTablasGenerales).forEach(nombre => {
                        selectedStepData.tabla[nombre] = JSON.parse(JSON.stringify(tempTablasGenerales[nombre]));
                    });

                    // Mapeamos cada elemento requerido, guardando además el valor obtenido de los inputs
                    selectedStepData.infoElements = elementosRequeridos.map(function (element) {
                        let obj = {
                            name: element.name,
                            type: element.type,
                            scope: element.scope,
                            apartado: element.apartado || "(Seleccionar apartado)"
                        };

                        const input = infoInputs[element.name];

                        if (element.type === "Archivo") {
                            if (input && input.type === "file" && input.files.length > 0) {
                                obj.valor = input.files[0].name;
                            } else {
                                obj.valor = element.valor || "";
                            }
                        } else if (element.type === "Tabla") {
                            if (element.opciones) obj.opciones = [...element.opciones];
                            if (element.tabla) obj.tabla = JSON.parse(JSON.stringify(element.tabla));
                        } else if (element.type === "Check independiente") {
                            obj.valor = !!input?.checked; // ✅ guardamos true/false real
                        } else if (element.type === "Check ligado a grupo") {
                            if (input?.type === "checkbox") {
                            // caso de checkbox individual
                            obj.valor = !!input.checked;
                            } else {
                                // caso de contenedor con varios checkboxes
                                const checkboxes = input?.querySelectorAll("input[type='checkbox']");
                                const marcados = [];
                                checkboxes?.forEach(chk => {
                                    if (chk.checked) marcados.push(chk.value);
                                });
                                obj.valor = marcados;
                            }

                        } else if (element.type === "Desplegable selección múltiple") {
                            const seleccionados = [...input?.selectedOptions || []].map(opt => opt.value);
                            obj.valor = seleccionados;
                            if (element.opciones) obj.opciones = [...element.opciones];
                        } else if (element.type === "Coordenadas WGS84") {
                            const lat = input?.querySelector("input[data-coord='lat']")?.value || "";
                            const lon = input?.querySelector("input[data-coord='lon']")?.value || "";
                            obj.valor = { lat, lon };
                        } else if (element.type === "Texto o html (no editable)") {
                            obj.valor = element.valor || "";
                        } else {
                            // Otros casos: texto, número, ocultado, NIF, IBAN, localidad, etc.
                            obj.valor = input?.value || "";
                            if (element.type === "Desplegable selección única" && Array.isArray(element.opciones)) {
                                obj.opciones = [...element.opciones];
                            }
                        }


                        return obj;
                    });

                    // NUEVO BLOQUE: Guardar en selectedStepData.valor los valores reales de cada elemento
                    if (!selectedStepData.valor) {
                        selectedStepData.valor = {};
                    }
                    selectedStepData.infoElements.forEach(function (element) {
                        selectedStepData.valor[element.name] = element.valor;
                    });

                    // ✅ Guardar el contenido del último elemento seleccionado (incluso si no se cambió la selección)
                    if (selector && selector.value && inputsContainer) {
                        guardarDatosDeInputs(selector.value);
                    }

                    // Si hay fecha de finalización, hacer comprobación:
                    const inputFecha = document.getElementById("fechafinSelect");
                    if (esFechaValida(fechafinSelect.value) && fechafinSelect.value !== "") {
                        const todoOk = remarcarObligatoriosFaltantesParaStepCompleto(selectedStepData);
                        if (!todoOk) return; // ⛔ No continuar si hay errores
                    }

                    // ✅ Volcar los datos por instancia actualizados
                    selectedStepData.infoElementsDataPorInstancia = JSON.parse(JSON.stringify(tempInfoElementsDataPorInstancia));
                }
            }

            if (tipo === "step" && esFechaValida(fechafinSelect.value) && fechafinSelect.value !== "") {
                const todoOk = remarcarObligatoriosFaltantesParaStepCompleto(selectedStepData);
                if (!todoOk) return;

                activarMilestones(selectedStepData.id, flowchartData);
            }

            document.body.removeChild(dialogDiv);
            drawFlowchart();
        });





        var btnCancelar = document.createElement("button");
  btnCancelar.textContent = "Cancelar";
  btnCancelar.style.position = "absolute";
  btnCancelar.style.bottom = "10px";
  btnCancelar.style.right = "10px"; // Mover a la esquina inferior derecha

  // Manejador de eventos para el botón "Cancelar"
  btnCancelar.addEventListener("click", function () {
      // Cerrar el cuadro de diálogo sin guardar los datos
      document.body.removeChild(dialogDiv);
  });

        // Botones de aceptar y cancelar en la parte inferior
        var buttonsContainer = document.createElement("div");
        buttonsContainer.style.display = "flex";
        buttonsContainer.style.justifyContent = "flex-end";
        buttonsContainer.style.gap = "10px";
        buttonsContainer.style.borderTop = "1px solid #ccc";
        buttonsContainer.style.paddingTop = "10px";
        buttonsContainer.style.marginTop = "10px";

        // Estilo limpio para botones
        btnAceptar.style.position = "static";
        btnAceptar.style.margin = "0";
        btnCancelar.style.position = "static";
        btnCancelar.style.margin = "0";

        buttonsContainer.appendChild(btnCancelar);
        buttonsContainer.appendChild(btnAceptar);
        dialogDiv.appendChild(buttonsContainer);
    }


      function getElementosObligatoriosNoRellenadosParaStepCompleto(stepData) {
          if (!stepData || !stepData.infoElements) return [];

          const faltan = [];

          // 1. Comprobar campos "Uno para todos los ítems"
          stepData.infoElements.forEach(element => {
              let esObligatorio = element.optional !== true;
              if (element.type === "Texto o html (no editable)") esObligatorio = false;
              if (!esObligatorio || element.scope === "Uno para cada ítem") return;

              const valor = element.valor;
              const estaVacio =
                  valor === null || valor === undefined || valor === "" ||
                  (element.type === "Check independiente" && valor !== true) ||
                  (typeof valor === "object" && Object.keys(valor).length === 0);

              if (estaVacio) {
                  faltan.push({ nombre: element.name, instancia: null });
              }
          });

          // 2. Comprobar campos "Uno para cada ítem"
          const datosPorInstancia = tempInfoElementsDataPorInstancia || {};
          const nombresInstancias = Object.keys(datosPorInstancia);

          nombresInstancias.forEach(instancia => {
              const datos = datosPorInstancia[instancia];
              const finalState = datos?.finalState;
              const instanciaCancelada = finalState?.value === "cancelled";
              if (instanciaCancelada) return;

              const faltantesInstancia = getElementosObligatoriosNoRellenadosPorInstancia(stepData, instancia);
              faltan.push(...faltantesInstancia);
          });

          return faltan;
      }

            function getElementosObligatoriosNoRellenadosPorInstancia(stepData, nombreInstancia) {
                const faltantes = [];
                const datosInstancia = tempInfoElementsDataPorInstancia?.[nombreInstancia] || {};

                // Agrupar elementos por tipo y grupo
                const checksLigadosPorGrupo = {};

                (stepData.infoElements || []).forEach(element => {
                    if (element.scope !== "Uno para cada ítem") return;
                    if (element.optional === true) return;
                    if (element.type === "Texto o html (no editable)") return;

                    const tipo = element.type;
                    const nombre = element.name;
                    const valor = datosInstancia[nombre]?.value;

                    if (tipo === "Check ligado a grupo") {
                        const grupo = element.apartado || "__sinGrupo";
                        if (!checksLigadosPorGrupo[grupo]) {
                            checksLigadosPorGrupo[grupo] = [];
                        }
                        checksLigadosPorGrupo[grupo].push({ nombre, valor });
                        return;
                    }

                    const estaVacio =
                        valor === undefined ||
                        valor === null ||
                        valor === "" ||
                        (element.type === "Check independiente" && valor !== true) ||
                        (Array.isArray(valor) && valor.length === 0) ||
                        (typeof valor === "object" && valor.lat === "" && valor.lon === "");

                    if (estaVacio) {
                        faltantes.push({ nombre, instancia: nombreInstancia });
                    }
                });

                // Validar los grupos de checks ligados
                for (const grupo in checksLigadosPorGrupo) {
                    const items = checksLigadosPorGrupo[grupo];
                    const algunoMarcado = items.some(i => i.valor === true || i.valor === "true");

                    if (!algunoMarcado) {
                        items.forEach(i => {
                            faltantes.push({ nombre: i.nombre, instancia: nombreInstancia });
                        });
                    }
                }

                return faltantes;
            }



function registrarLimpiezaDeErrores(input, nombre, instancia = null) {
    const clave = instancia ? `${nombre}|||${instancia}` : nombre;
    const label = labelsPorNombreYInstancia[clave];

    if (!label) return;

    const limpiar = () => {
        // Si no es Check ligado a grupo, simplemente limpiar este
        const tipo = input.type;
        const isCheckbox = tipo === "checkbox";
        const esCheckLigado = input.dataset?.apartado && isCheckbox;

        if (esCheckLigado) {
            const grupo = input.dataset.apartado;

            const selector = instancia
                ? `input[type="checkbox"][data-apartado="${grupo}"][data-instancia="${instancia}"]`
                : `input[type="checkbox"][data-apartado="${grupo}"]`;

            const relacionados = document.querySelectorAll(selector);

            relacionados.forEach(relatedInput => {
                const nombreRelacionado = relatedInput.dataset.elementname;
                const instanciaRelacionada = relatedInput.dataset.instancia;
                const claveRelacionado = instanciaRelacionada
                    ? `${nombreRelacionado}|||${instanciaRelacionada}`
                    : nombreRelacionado;

                const labelRelacionado = labelsPorNombreYInstancia[claveRelacionado];
                if (labelRelacionado) {
                    labelRelacionado.classList.remove("label-error");
                }
            });
        } else {
            // Normal
            label.classList.remove("label-error");
        }
    };

    input.addEventListener("input", limpiar, { once: true });
    input.addEventListener("change", limpiar, { once: true });
}





function crearBloqueCampoInformacion(tipo, element, valorActual, nombreInstancia = null, todosSonRequeridosPorDefecto = false) {
    const container = document.createElement("div");
    container.style.display = "flex";
    container.style.alignItems = "center";
    container.style.marginBottom = "8px";

    const label = document.createElement("label");

    label.style.fontFamily = "Arial";
    label.style.fontSize = "14px";
    label.style.fontWeight = "bold";
    label.style.marginRight = "10px";

    // 🟠 Punto delante del título si es obligatorio (no es optional)
    const esRequerido = element.optional !== true;
    if (esRequerido&&(tipo!=="Archivo")) {
        const punto = document.createElement("span");
        punto.innerText = "• ";
        punto.style.color = color_text_titles;
        label.appendChild(punto);
    }

    let input;




  switch (tipo) {
    case "Texto corto":
    case "Texto ocultado":
    case "Fecha":
    case "Hora":
    case "Número":
    case "Importe en €":
    case "Coordenadas WGS84":
    case "NIF":
    case "Cuenta bancaria":
    case "Código postal":
        label.append(element.name + ":");
        input = document.createElement("input");
        input.type = tipo === "Texto ocultado" ? "password" :
                     tipo === "Fecha" ? "date" :
                     tipo === "Hora" ? "time" :
                     tipo === "Número" || tipo === "Importe en €" ? "number" : "text";
        input.style.width = (tipo === "Código postal") ? "100px" :
                            (tipo === "Cuenta bancaria") ? "300px" :
                            (tipo === "NIF") ? "200px" :
                            (tipo === "Coordenadas WGS84") ? "300px" :
                            "400px";
        input.value = valorActual || "";
        break;

    case "Texto largo":
        label.append(element.name + ":");
        label.style.display = "block";
        input = document.createElement("textarea");
        input.rows = 3;
        input.cols = 60;
        input.value = valorActual || "";
        container.style.display = "block";
        break;

    case "Porcentaje":
        label.append(element.name + " (%):");
        input = document.createElement("input");
        input.type = "number";
        input.min = 0;
        input.max = 100;
        input.step = 0.01;
        input.style.width = "100px";
        input.value = valorActual || "";
        break;

    case "Check independiente":
    case "Check ligado a grupo":
        label.textContent = " " + element.name + ".";
        input = document.createElement("input");
        input.type = "checkbox";
        input.checked = valorActual === true || valorActual === "true";
        if (tipo === "Check ligado a grupo") {
            const apartado = element.apartado || "";
            input.dataset.apartado = apartado;

            input.addEventListener("change", () => {
                if (input.checked) {
                    const allInputs = document.querySelectorAll(`input[type="checkbox"][data-apartado="${apartado}"]`);

                    allInputs.forEach(chk => {
                        if (chk !== input) chk.checked = false;
                    });

                    // 🔄 También eliminar marcas de error en todos los labels del grupo
                    allInputs.forEach(chk => {
                        const nombre = chk.dataset.elementname;
                        const instancia = chk.dataset.instancia;
                        const clave = instancia ? `${nombre}|||${instancia}` : nombre;
                        const label = labelsPorNombreYInstancia?.[clave];
                        if (label) {
                            label.classList.remove("label-error");
                            console.log(`🟢 Limpieza de error para check ligado: ${clave}`);
                        }
                    });
                }
            });
        }

        input.dataset.elementName = element.name;
        if (nombreInstancia) {
            input.dataset.instancia = nombreInstancia;
        }

        // 👉 Registrar label ANTES de registrar listeners
        const claveCheck = nombreInstancia ? `${element.name}|||${nombreInstancia}` : element.name;
        labelsPorNombreYInstancia[claveCheck] = label;
        console.log("📌 Registrado label para clave:", claveCheck);

        // 🔁 Si es 'Check ligado a grupo', registrar listeners para todos los del mismo grupo
        if (tipo === "Check ligado a grupo") {
            input.addEventListener("change", () => {
                const grupo = element.apartado || "";
                const relacionados = document.querySelectorAll(`input[type="checkbox"][data-apartado="${grupo}"]`);
                relacionados.forEach(chk => {
                    const nombre = chk.dataset.elementName;
                    const instancia = chk.dataset.instancia;
                    const clave = instancia ? `${nombre}|||${instancia}` : nombre;
                    const lbl = labelsPorNombreYInstancia[clave];
                    if (lbl) {
                        lbl.classList.remove("label-error");
                        console.log(`🟢 Limpieza grupo ligado: ${clave}`);
                    }
                });
            });
        } else {
            // 👉 Registrar listener normal para eliminar error individual
            registrarLimpiezaDeErrores(input, element.name, nombreInstancia);
        }

        container.appendChild(input);
        container.appendChild(label);
        return container;


    case "Desplegable selección única":
        label.append(element.name + ":");
        input = document.createElement("select");
        (element.opciones || []).forEach(op => {
            const opt = document.createElement("option");
            opt.value = op;
            opt.textContent = op;
            input.appendChild(opt);
        });
        input.value = valorActual || "";
        break;

    case "Desplegable selección múltiple":
        label.append(element.name + " (se pueden seleccionar varios con ctrl+click):");
        input = document.createElement("select");
        input.multiple = true;
        input.style.width = "300px";
        input.style.height = "100px";
        (element.opciones || []).forEach(op => {
            const opt = document.createElement("option");
            opt.value = op;
            opt.textContent = op;
            if ((valorActual || []).includes(op)) opt.selected = true;
            input.appendChild(opt);
        });
        break;

    case "Archivo":
        const archivoPrevio = valorActual || "";

        label.style.fontFamily = "Arial";
        label.style.fontSize = "14px";
        label.style.fontWeight = "bold";
        label.style.marginRight = "10px";

        if (element.optional !== true) {
            const punto = document.createElement("span");
            punto.innerText = "• ";
            punto.style.color = color_text_titles;
            label.appendChild(punto);
        }
        label.append(`${element.name}:`);

        const archivoLabel = document.createElement("span");
        archivoLabel.textContent = archivoPrevio ? ` ${archivoPrevio}` : "";
        archivoLabel.style.fontStyle = "italic";
        archivoLabel.style.fontSize = "13px";
        archivoLabel.style.color = "#333";
        archivoLabel.style.marginLeft = "6px";
        archivoLabel.dataset.elementName = element.name;
        if (nombreInstancia) {
            archivoLabel.dataset.instancia = nombreInstancia;
        }

        const btnBorrar = document.createElement("button");
        btnBorrar.textContent = "Borrar";
        btnBorrar.style.marginLeft = "8px";
        btnBorrar.style.fontSize = "12px";
        btnBorrar.style.padding = "2px 6px";

        function mostrarInputArchivo() {
            input = document.createElement("input");
            input.type = "file";
            input.dataset.elementName = element.name;
            if (nombreInstancia) {
                input.dataset.instancia = nombreInstancia;
            }

            input.addEventListener("change", () => {
                const archivo = input.files?.[0];
                if (archivo) {
                    archivoLabel.textContent = ` ${archivo.name}`;
                    input.remove();
                    container.appendChild(archivoLabel);
                    container.appendChild(btnBorrar);
                    registrarLimpiezaDeErrores(input, element.name, nombreInstancia);
                }
            });

            container.appendChild(input);
        }

        btnBorrar.addEventListener("click", () => {
            archivoLabel.textContent = "";
            if (btnBorrar.parentNode) btnBorrar.remove();
            if (archivoLabel.parentNode) archivoLabel.remove();
            mostrarInputArchivo();
            if (nombreInstancia) {
                delete tempInfoElementsDataPorInstancia?.[nombreInstancia]?.[element.name];
            } else {
                element.valor = "";
            }
        });

        const claveArchivo = nombreInstancia ? `${element.name}|||${nombreInstancia}` : element.name;
        labelsPorNombreYInstancia[claveArchivo] = label;

        container.appendChild(label);
        if (archivoPrevio) {
            container.appendChild(archivoLabel);
            container.appendChild(btnBorrar);
        } else {
            mostrarInputArchivo();
        }
        return container;

    case "Tabla":
        label.append(element.name + ":");
        input = document.createElement("button");
        input.textContent = "Editar tabla";
        input.addEventListener("click", function () {
            openRestrictedTableEditor(element, nombreInstancia, tempInfoElementsDataPorInstancia, tempTablasGenerales, labelsPorNombreYInstancia);
        });
        break;

    case "Localidad":
        label.append(element.name + ":");
        input = document.createElement("select");
        listaLocalidades.forEach(loc => {
            const opt = document.createElement("option");
            opt.value = loc;
            opt.textContent = loc;
            input.appendChild(opt);
        });
        input.value = valorActual || "";
        break;

    case "Texto o html (no editable)":
        const htmlPreview = document.createElement("div");
        htmlPreview.innerHTML = element.valor || "";
        htmlPreview.style.margin = "0";
        htmlPreview.style.padding = "0";
        htmlPreview.style.width = "100%";
        htmlPreview.style.maxWidth = "600px";
        htmlPreview.style.overflowX = "auto";
        htmlPreview.style.whiteSpace = "normal";
        htmlPreview.style.userSelect = "text";
        htmlPreview.style.fontFamily = "Arial";
        htmlPreview.style.fontSize = "14px";

        const reduceMarginsStyle = document.createElement("style");
        reduceMarginsStyle.textContent = `
            .previewHtmlReducido p,
            .previewHtmlReducido h1,
            .previewHtmlReducido h2,
            .previewHtmlReducido h3,
            .previewHtmlReducido h4,
            .previewHtmlReducido h5,
            .previewHtmlReducido h6,
            .previewHtmlReducido ul,
            .previewHtmlReducido ol,
            .previewHtmlReducido li,
            .previewHtmlReducido div {
                margin-top: 2px;
                margin-bottom: 2px;
            }
        `;
        document.head.appendChild(reduceMarginsStyle);
        htmlPreview.classList.add("previewHtmlReducido");

        const claveHTML = nombreInstancia ? `${element.name}|||${nombreInstancia}` : element.name;
        labelsPorNombreYInstancia[claveHTML] = label;

        container.appendChild(htmlPreview);
        container.style.display = "block";
        container.style.marginTop = "0px";
        container.style.marginBottom = "6px";
        return container;

    default:
        return null;
}


    container.appendChild(label);

    if (input) {
        container.appendChild(input);

        if (input.tagName === "INPUT" || input.tagName === "TEXTAREA" || input.tagName === "SELECT") {
            input.dataset.elementName = element.name;
            if (nombreInstancia) {
                input.dataset.instancia = nombreInstancia;
            }
        }

        // 👉 Registrar label ANTES de registrar listeners
        const clave = nombreInstancia ? `${element.name}|||${nombreInstancia}` : element.name;
        labelsPorNombreYInstancia[clave] = label;
        console.log("📌 Registrado label para clave:", clave);

        // Ahora sí es seguro registrar el listener
        if (input.tagName === "INPUT" || input.tagName === "TEXTAREA" || input.tagName === "SELECT") {
            registrarLimpiezaDeErrores(input, element.name, nombreInstancia);
        }

    }
    


    return container;

}

}






function convertLinks(text, basePath) {
    // Expresión regular para identificar los marcadores
    var regex = /\/\*(.*?)\*\//g;
    // Reemplazar los marcadores por elementos <a>
    return text.replace(regex, function(match, fileName) {
        // Verifica si el texto capturado comienza con "https://"
        if (fileName.startsWith("https://")) {
            return '<a href="' + fileName + '" target="_blank" rel="noopener noreferrer">' + fileName + '</a>';
        } else {
            var url = basePath + "/tareas/" + fileName;
            return '<a href="' + url + '" target="_blank" rel="noopener noreferrer">' + fileName + '</a>';
        }
    });
}
function siguienteTareasPreparadas(idTarea, flowchartData) {
    console.log("🔍 Buscando tareas siguientes para:", idTarea);

    const siguientes = [];
    const pathsDesdeTarea = flowchartData.paths.filter(p => p.startStep === idTarea);
    console.log("➡️ Paths desde la tarea:", pathsDesdeTarea);

    for (const path of pathsDesdeTarea) {
        const destino = path.endStep;
        const tareaDestino = flowchartData.steps.find(s => s.id === destino);
        console.log("🎯 Evaluando destino:", destino, "→", tareaDestino?.label);

        const tareasPrevias = flowchartData.paths
            .filter(p => p.endStep === destino)
            .map(p => p.startStep);

        console.log("🔗 Tareas previas que llegan a", destino, ":", tareasPrevias);

        const todasCompletadas = tareasPrevias.every(idPrev => {
            const step = flowchartData.steps.find(s => s.id === idPrev);
            const completada = !!step?.fechafin;
            console.log(`  ✅ ${idPrev} (${step?.label}): completada =`, completada);
            return completada;
        });

        if (todasCompletadas) {
            const fechas = tareasPrevias.map(idPrev => {
                const step = flowchartData.steps.find(s => s.id === idPrev);
                return step?.fechafin;
            }).filter(Boolean);

            const fechaMax = fechas.sort().reverse()[0];
            console.log(`📅 Todas completadas. Fecha máxima de entrada a ${destino}: ${fechaMax}`);
            siguientes.push({ id: destino, fechaMax });
        } else {
            console.log(`⛔ No se activa ${destino} porque no todas las tareas previas están completadas.`);
        }
    }

    console.log("📌 Tareas siguientes preparadas:", siguientes);
    return siguientes;
}

function activarMilestones(idStep, flowchartData) {
    console.log("🚀 Ejecutando activarMilestones para:", idStep);
    const siguientes = siguienteTareasPreparadas(idStep, flowchartData);

    siguientes.forEach(({ id, fechaMax }) => {
        const step = flowchartData.steps.find(s => s.id === id);
        if (step?.tipo === "milestone") {
            step.fechafin = fechaMax;
            console.log(`🏁 Milestone '${step.label}' (${id}) marcado como completado en ${fechaMax}`);
        } else {
            console.log(`ℹ️ Tarea '${step?.label}' (${id}) no es milestone. No se modifica.`);
        }
    });
}





canvas.addEventListener('mousemove', function (event) {
    if (isSelecting) {
        var rect = canvas.getBoundingClientRect();
        var currentX = event.clientX - rect.left;
        var currentY = event.clientY - rect.top;

        // Actualizar las coordenadas del rectángulo
        selectionEnd = { x: currentX, y: currentY };
        drawFlowchart(); // Redraw to show selection box
    }

    if (stepSelected && stepCanMove && dragStart && expiredTime) {
        var rect = canvas.getBoundingClientRect();
        var currentX = event.clientX - rect.left;
        var currentY = event.clientY - rect.top;

        // Calcular desplazamiento
        var dx = currentX - dragStart.x;
        var dy = currentY - dragStart.y;

        // Actualizar las posiciones de las tareas seleccionadas
        flowchartData.steps.forEach(function (step) {
            if (selectedStep.includes(step.id)) {
                var initialPosition = initialPositions.find(pos => pos.id === step.id);
                if (initialPosition) {
                    step.x = initialPosition.x + dx;
                    step.y = initialPosition.y + dy;
                }
            }
        });

        drawFlowchart(); // Redibujar el diagrama con las posiciones actualizadas
    }
});


canvas.addEventListener('mouseup', function () {




    dragStart = null; // Restablecer el punto inicial del movimiento
    initialPositions = []; // Limpiar las posiciones iniciales

    if (isSelecting) {
        isSelecting = false;

        // Obtener el área de selección
        var startX = Math.min(selectionStart.x, selectionEnd.x);
        var endX = Math.max(selectionStart.x, selectionEnd.x);
        var startY = Math.min(selectionStart.y, selectionEnd.y);
        var endY = Math.max(selectionStart.y, selectionEnd.y);

        // Seleccionar los pasos dentro del rectángulo
        var newSelection = flowchartData.steps.filter(function (step) {
            return (
                step.x >= startX &&
                step.x <= endX &&
                step.y >= startY &&
                step.y <= endY
            );
        }).map(step => step.id);

        // Si se seleccionaron elementos dentro del área, actualizar la selección
        if ((!stepCanMove)&&(newSelection.length > 0)) {
            selectedStep = newSelection;
            //stepSelected = true;
        } else {
            //stepSelected = false;
        }


    }
    if(selectedStep.length>0){
      stepSelected=true;
    }
    drawFlowchart(); // Redibujar el diagrama con los pasos seleccionados

    // Lógica para crear un nuevo path al dar dos clics consecutivos
    numClicksAfterCreatePathButton++;
    if(stepSelected&&selectedStep.length===1){              
            if (numClicksAfterCreatePathButton==1){
                NewStepIni=selectedStep[0];
                if(createPathOn){
                document.getElementById("messages").innerHTML = "Haga click en el segundo paso a relacionar";
                }

                //ctx.clearRect(500, 0, 1000, 24);
                //ctx.fillText("Haga click en el segundo proceso", 500, 12);
            }
            if (numClicksAfterCreatePathButton==2){
                NewStepEnd=selectedStep[0];
                if(createPathOn){
                  var PathText="Escriba condición si debe darse";
                  if(createligtimeOn) PathText="Escriba el plazo máximo";
                  
                    if(createligtimeOn){
                      showPathDialog(true, NewStepIni, NewStepEnd, '', 'ligtime', '', '', '', '', '');
                      //insertarNuevoPath(NewStepIni, NewStepEnd, condicion, 'ligtime');
                      document.getElementById("createLigtimeButton").style.backgroundColor="#4c77af";
                    }else{
                      showPathDialog(true, NewStepIni, NewStepEnd, '', 'path', '', '', '', '', '');
                        //insertarNuevoPath(NewStepIni, NewStepEnd, condicion, 'path');
                        document.getElementById("createPathButton").style.backgroundColor="#4c77af";
                    }
                }
                document.getElementById("messages").innerHTML = "";
                //ctx.clearRect(500, 0, 1000, 24);
                createPathOn=false;
                createligtimeOn=false;
                NewStepIni=null;
                NewStepEnd=null;
            }
        
    }else{
        createPathOn=false;
        createligtimeOn=false;
        NewStepIni=null;
        NewStepEnd=null;
    }
    stepCanMove = false;

    guardarEstado();

    
    console.log("1 selectedPath: "+selectedPath);
    console.log("1 pathSelected: "+pathSelected);
    console.log("1 selectedStep: "+selectedStep);
    console.log("1 stepSelected: "+stepSelected);

});


// Obtener el elemento input.
const inputElement = document.querySelector("#flowChartName");

var valorInputTitulo=inputElement.value;
// Manejador de eventos para la tecla Enter.
inputElement.addEventListener("keyup", event => {
  valorInputTitulo=inputElement.value;
    if(event.key !== "Enter") return;
    doActions();
    inputElement.blur(); // Por ejemplo, hacer que el input pierda el foco.
    event.preventDefault();
});

// Manejador de eventos para el evento blur (perder foco).
inputElement.addEventListener("blur", event => {
  inputElement.value=valorInputTitulo;
    doActions();
});

// Función para realizar las acciones deseadas.
function doActions() {
    // Aquí colocas las acciones que quieres realizar.
    inputElement.value=valorInputTitulo;
    setupFlowChartName();
   
}

        drawFlowchart(); // Initial drawing of the flowchart
    </script>
</body>
</html>